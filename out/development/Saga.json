{"slots":{"-5":{"name":"library","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}}},"handlers":[{"key":1,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":";(function()\nlocal a={}local b=0;function library.addEventHandlers(c)if not c or c.onEvent and c.triggerEvent then return false end;b=b+1;a[b]=c;local d,e,f='table','function','thread'if d~=type(c)then error('You can only add event handlers to table objects!')end;local g={}local function h(c)local i=type(c)return e==i or d==i and h(getmetatable(c).__call)or f==i end;c.onEvent=function(self,j,k,l)if not h(k)then error('Event handler must be a function, a callable object or a thread!')end;l=l or self;if d~=type(l)then error('The value of self must be a table!')end;if not g[j]then g[j]={_=0}end;local m=f==type(k)and function(...)coroutine.resume(k,...)end or k;local k=g[j]local n=k._+1;k[n]={m,l}k._=n;return n end;c.clearEvent=function(self,j,o)if g[j]and g[j][o]then g[j][o]=nil end end;c.clearAllEvents=function(self)g={}end;c.triggerEvent=function(self,j,...)local p=g[j]if p then for q=1,p._ do local k=p[q]if k then k[1](k[2],...)end end end end;return true end;function library.clearAllEventHandlers()for q=1,b do local c=a[q]if c and c.clearAllEvents then c:clearAllEvents()end end end\nend)()"},{"key":2,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":";(function()\nlocal a=DULibrary or{}function a.getLinks(b,c)local d={}if not b then b={}end;for e,f in pairs(unit.getOutPlugs())do local g=unit[f.name]if'table'==type(g)and'function'==type(g.getClass)then local h=true;for i,j in pairs(b)do if not('function'==type(g[i])and j==g[i]():sub(1,#j))then h=false;break end end;if h then if c then table.insert(d,g)else d[f.name]=g end end end end;return d end;function a.getLinksByClass(k,c)return a.getLinks({getClass=k},c)end;function a.getLinkByClass(k)return a.getLinksByClass(k,true)[1]end;function a.getCoreUnit()return a.getLinkByClass('CoreUnit')end;function a.getLinkByName(l)local m=a.getCoreUnit()if not m then error('getLinkByName requires a linked CoreUnit to work')end;local d=a.getLinks()for n,o in pairs(d)do if l==m.getElementNameById(o.getLocalId())then return o end end end\nend)()"},{"key":3,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":"package.preload['Saga:data/links.lua']=(function()\nlinks = {\n    core = nil,\n    warpdrive = nil,\n    shield = nil,\n    antigrav = nil,\n    gyro = nil,\n    transponder = nil,\n    databanks = {},\n    weapons = {},\n    switches = {},\n    electronics = nil,\n    radars = {},\n    telemeter = nil,\n    hovers = {},\n    hoverCount = 0,\n\tscreen = nil,\n    vboosters = {},\n    vBoosterCount = 0\n}\n\nfunction scanLinks()\n\tfor slotName, slot in pairs(unit) do\n\t\tif type(slot) == \"table\"\n\t\t\tand type(slot.export) == \"table\"\n\t\t\tand slot.getClass\n\t\tthen\n\t\t\tlocal elementClass = slot.getClass():lower()\n\t\t\tslot.slotName = slotName\n\t\t\tslot.elementClass = elementClass\n\t\t\tif elementClass:find(\"coreunit\") then\n\t\t\t\tlinks.core = slot\n\t\t\telseif elementClass:find(\"screen\") then\n\t\t\t\tlinks.screen = slot\n\t\t\telseif elementClass:find(\"radar\") then\n\t\t\t\ttable.insert(links.radars, slot)\n\t\t\telseif elementClass:find(\"warpdriveunit\") then\n\t\t\t\tlinks.warpdrive = slot\n\t\t\telseif elementClass:find(\"databankunit\") then\n\t\t\t\ttable.insert(links.databanks, slot)\n\t\t\telseif elementClass:find(\"shieldgenerator\") then\n\t\t\t\tlinks.shield = slot\n\t\t\telseif elementClass:find(\"weapon\") then\n\t\t\t\ttable.insert(links.weapons, slot)\n\t\t\telseif elementClass:find(\"gyrounit\") then\n\t\t\t\tlinks.gyro = slot\n\t\t\telseif elementClass:find(\"antigravitygeneratorunit\") then\n\t\t\t\tlinks.antigrav = slot\n\t\t\telseif elementClass:find(\"combatdefense\") then\n\t\t\t\tlinks.transponder = slot\n\t\t\telseif elementClass:find('manualswitchunit') then\n\t\t\t\ttable.insert(links.switches, slot)\n\t\t\telseif elementClass:find(\"telemeter\") then\n\t\t\t\tlinks.telemeter = slot\n\t\t\telseif elementClass:find(\"hover\") then\n\t\t\t\ttable.insert(links.hovers, slot)\n                links.hoverCount = links.hoverCount + 1\n\t\t\telseif elementClass:find(\"verticalbooster\") then\n\t\t\t\ttable.insert(links.vboosters, slot)\n                links.vBoosterCount = links.vBoosterCount + 1\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction finaliseLinks()\n\tlinks.electronics = Electronics\n\n\t\tfor _,databank in ipairs(links.databanks) do\n\t\tdatabank.id = databank.getLocalId()\n\t\tdatabank.name = links.core.getElementNameById(databank.id)\n\tend\n\t\ttable.sort(links.databanks, function(a,b) return a.id < b.id end)\n\n\t\tfor _,switch in ipairs(links.switches) do\n\t\tlocal switchName = links.core.getElementNameById(switch.getLocalId())\n\t\tif switchName:lower():find('door') then\n\t\t\ttable.insert(links.electronics.doors, switch)\n\t\telseif switchName:lower():find('forcefield') then\n\t\t\ttable.insert(links.electronics.forcefields, switch)\n\t\telse\n\t\t\ttable.insert(links.electronics.switches, switch)\n\t\tend\n\tend\n\n\t\tfor _,radar in ipairs(links.radars) do\n\t\tradar.pvp = (radar.slotName == 'slot21' or radar.slotName == 'slot14')\n\tend\nend\nend)\npackage.preload['Saga:events/keyboard.lua']=(function()\nmmbClick = 0 forwardClick = 0 \ninputs = {\n\tpitch = 0,\n\troll = 0,\n\tyaw = 0,\n\tbrake = 0,\n\tmanualBrake = false,\n\tbrakeLock = false,\n\tup = false,\n\tdown = false,\n\tleft = false,\n\tright = false,\n\talt = false,\n\tshift = false,\n\tmouseLeft = false,\n\tdirection = vec3(0,0,0),\n\trotation = vec3(0,0,0),\n\tmu = false,\n\tmd = false,\n\tml = false,\n\tmr = false\n}\nlocal axisLong = axisCommandId.longitudinal\nlocal axisLat = axisCommandId.lateral\nlocal axisVert = axisCommandId.vertical\n\nfunction onShift(on)\n\tinputs.shift = on\n\tend\n\nfunction onAlt(on)\n\tinputs.alt = on\n\tend\n\nfunction onMouseDown()\n\tinputs.mouseLeft = true\nend\n\nfunction onMouseUp()\n\tinputs.mouseLeft = false\nend\n\nfunction onAlt1()\n\tif inputs.shift then return HUD.toggleMainMenu() end\n\tlocal ap, s, cD = AutoPilot, ship, cData\n\tif not globals.maneuverMode then\n\t\treturn ap:toggleState(not ap.enabled)\n\tend\n\t\tif not ap.target then return end\n\tif s.gotoLock then\n\t\ts.resetMoving()\n\t\tresetAP()\n\t\tap.target = nil\n\telseif cD.isLanded then\n\t\tP'[E] Liftoff first!'\n\telse\n\t\tinputs.brakeLock = false\n\t\ts.switchState('ALTITUDE')\n\t\ts.gotoLock = ap.target\n\t\ts.targetVector = (s.gotoLock - cD.position):normalize()\n\t\ts.travel = true\n\t\tP(\"Moving to: \" .. tostring(Vec3ToPosString(ap.target)))\n\tend\nend\n\nfunction onAlt2()\n\tlocal gC, _inputs = globals, inputs\n\tif cData.warpOn or ship.landingMode then\n\t\tgC.altitudeHold = false\n\t\tgC.followMode = false\n\t\treturn\n\tend\n\tgC.manualOrbitAlt = 0\n\tif not (gC.altitudeHold or gC.followMode) then\n\t\tif gC.maneuverMode or not _inputs.shift then\n\t\t\tgC.holdAltitude = cData.altitude\n\t\t\tgC.altitudeHold = true\n\t\telse\n\t\t\tif player.isSeated() == false then\n\t\t\t\tgC.followMode = true\n\t\t\telse\n\t\t\t\tP('[E] Not on Remote, follow disabled!')\n\t\t\tend\n\t\tend\n\t\treturn\n\tend\n\tif not gC.altitudeHold and gC.followMode then\n\t\tgC.followMode = false\n\telseif gC.altitudeHold and not gC.followMode then\n\t\tgC.altitudeHold = false\n\tend\nend\n\nfunction onAlt3()\n\tlocal gC = globals\n\tif cData.warpOn or gC.maneuverMode then return end\n\tgC.manualOrbitAlt = 0\n\tif not gC.orbitalHold then\n\t\tif gC.spaceCapable then\n\t\t\tresetModes()\n\t\t\tgC.orbitalHold = true\n\t\t\tsetTargetOrbitAlt()\n\t\telse\n\t\t\tP('Space thrust not detected: Orbital Hold Disabled')\n\t\t\tgC.orbitalHold = false\n\t\tend\n\telse\n\t\tgC.orbitalHold = false\n\tend\nend\n\nfunction onAlt4()\n\tlocal gC = globals\n\tif not gC.radialOut and not gC.radialIn and not gC.cameraAim then\n\t\tgC.radialMode = 'radial out'\n\t\tgC.radialOut = not gC.radialOut\n\telseif gC.radialOut then\n\t\tgC.radialMode = 'radial in'\n\t\tgC.radialOut = not gC.radialOut\n\t\tgC.radialIn = not gC.radialIn\n\telseif gC.radialIn then\n\t\tgC.radialMode = 'camera aim'\n\t\tgC.cameraAim = true\n\t\tgC.radialIn = not gC.radialIn\n\telse\n\t\tgC.radialMode = 'off'\n\t\tgC.cameraAim = false\n\tend\nend\n\nfunction onAlt5()\n\tlocal gC = globals\n\tif gC.boostMode == 'all' then\n\t\tgC.boostMode = 'primary'\n\telseif gC.boostMode == 'primary' then\n\t\tgC.boostMode = 'hybrid'\n\telseif gC.boostMode == 'hybrid' then\n\t\tgC.boostMode = 'locked'\n\telse gC.boostMode = 'all'\n\tend\nend\n\nlocal function newRtIdx(current, maxIdx, down)\n\tif down then return math.max(1, current - 1) end\n\treturn math.min(maxIdx, current + 1)\nend\n\nfunction onAlt6()\n\tlocal ap, rdb = AutoPilot, RouteDatabase\n\tif ap.enabled or #rdb.routes < 1 then return end\n\tif not inputs.shift and inputs.alt then\n\t\tap.currentRouteIndex = newRtIdx(ap.currentRouteIndex or 1, #rdb.routes, true)\n\t\tap:setActiveRoute(ap.currentRouteIndex)\n\telseif inputs.shift and inputs.alt then\n\t\tsetApTarget(Config:getValue(configDatabankMap.base))\n\tend\nend\n\nfunction onAlt7()\n\tlocal ap, rdb = AutoPilot, RouteDatabase\n\tif ap.enabled or #rdb.routes < 1 then return end\n\tif not inputs.shift and inputs.alt then\n\t\tap.currentRouteIndex = newRtIdx(ap.currentRouteIndex or 1, #rdb.routes, false)\n\t\tap:setActiveRoute(ap.currentRouteIndex)\n\telseif inputs.shift and inputs.alt then\n\t\tConfig:setValue(configDatabankMap.base, cData.position)\n\t\tlocal aPos = Vec3ToPosString(cData.position)\n\t\tP(\"Base set to: \" .. tostring(aPos))\n\tend\nend\n\n\nfunction onAlt8()\n\tlocal gC, ap = globals, AutoPilot\n\tif inputs.shift then\n\t\tap.userConfig.slowFlat = not ap.userConfig.slowFlat\n\telseif inputs.alt then\n\t\tgC.rotationDampening = not gC.rotationDampening \tend\nend\n\nfunction onAlt9()\n\tlocal gC, ap = globals, AutoPilot\n\tif cData.warpOn or ap.enabled then\n\t\treturn P\"[E] Can't toggle now\"\n\tend\n\tif gC.maneuverMode then ship.resetMoving() end\n\tgC.maneuverMode = not gC.maneuverMode\n\tConfig:setValue(configDatabankMap.maneuverMode, gC.maneuverMode)\n\tif gC.maneuverMode then return end\n\tsetThrottle()\n\tnavCom:resetCommand(axisCommandId.vertical)\n\tnavCom:deactivateGroundEngineAltitudeStabilization()\nend\n\nfunction onWarpDown() \tif links.warpdrive ~= nil then links.warpdrive.activateWarp() end\nend\n\nfunction onAntigravDown() \tif links.antigrav ~= nil then links.antigrav.toggle() end\nend\n\nfunction onBoosterDown() \tNav:toggleBoosters()\nend\n\nfunction onLightDown() \tif unit.isAnyHeadlightSwitchedOn() then\n\t\tunit.switchOffHeadlights()\n\telse\n\t\tunit.switchOnHeadlights()\n\tend\nend\n\nlocal DOUBLE_CLICK_MIN_THRESHOLD = 0.1 local DOUBLE_CLICK_MAX_THRESHOLD = 0.4 \nfunction onMmbDown() \tif globals.maneuverMode then\n\t\tlocal currentTime = system.getUtcTime()\n\t\tmmbClick = mmbClick or 0\n\t\tlocal time_since_last_click = currentTime - mmbClick\n\t\tif mmbClick == 0 or\n\t\t\ttime_since_last_click < DOUBLE_CLICK_MIN_THRESHOLD or\n\t\t\tcurrentTime - mmbClick >= DOUBLE_CLICK_MAX_THRESHOLD then\n\t\t\t\t\t\tmmbClick = currentTime\n\t\telse\n\t\t\tmmbClick = 0 \t\t\tship.toggleMmb()\n\t\tend\n\telse\n\t\tnavCom:resetCommand(axisLong)\n\tend\nend\n\nfunction onMmbUp() end\n\nfunction onLandingGearDown() \tlocal gC, ap = globals, AutoPilot\n\n\t\tif ap.enabled then ap:toggleState(false) end\n\tif ship.mmbThrottle then ship.toggleMmb() end\n\tgC.altitudeHold = false\n\tgC.prevStdMode = false\n\n\tinputs.brake = 0\n\tinputs.brakeLock = false\n\t\tif cData.isLanded then\n\t\tship.landingMode = false\n\t\t\t\tif not gC.maneuverMode then\n\t\t\treturn ap:toggleLandingMode(false)\n\t\tend\n\t\tmoveVert(ap.userConfig.hoverHeight)\n\t\tship.takeoff = true\n\t\tship.travel = false\n\t\tship.vertical = false\n\t\treturn\n\tend\n\n\t\tif (ap.landingMode or ship.landingMode) then\n\t\tap.landingMode = false\n\t\tship.landingMode = false\n\t\tif gC.maneuverMode then\n\t\t\t\t\t\tship.resetMoving()\n\t\t\tif gC.prevStdMode then\n\t\t\t\tgC.maneuverMode = false\n\t\t\tend\n\t\tend\n\t\tif not gC.maneuverMode then\n\t\t\tsetThrottle()\n\t\t\tnavCom:activateGroundEngineAltitudeStabilization()\n\t\t\tif not gC.startup then\n\t\t\t\tap:toggleLandingMode(false)\n\t\t\tend\n\t\tend\n\t\treturn\n\tend\n\n\t\tif not gC.maneuverMode then\n\t\tship.resetManeuver()\n\t\tgC.prevStdMode = true\n\tend\n\tship.landingMode = true\n\tap.landingMode = false\n\t\tship.prepLanding()\n\tsetThrottle(1,1,1)\nend\n\nfunction onUpArrowDown() \tinputs.md = false\n\tlocal gC = globals\n\tif HUD.Config.mainMenuVisible then\n\t\tinputs.mu = true\n\telse\n\t\tinputs.up = true\n\t\tif gC.maneuverMode then\n\t\t\tisStartup = false\n\t\t\tinputs.brakeLock = false\n\t\t\tinputs.brake = 0\n\t\telse\n\t\t\tnavCom:resetCommand(axisVert)\n\t\t\tnavCom:deactivateGroundEngineAltitudeStabilization()\n\t\t\tnavCom:updateCommandFromActionStart(axisVert, 1.0)\n\t\tend\n\tend\n\tgC.verticalState = true\nend\n\nfunction onUpArrowUp() \tinputs.mu = false\n\tinputs.up = false\n\tlocal gC = globals\n\tif not HUD.Config.mainMenuVisible then\n\t\tif gC.maneuverMode then\n\t\t\tif gC.altitudeHold then gC.holdAltitude = cData.altitude end\n\t\telse\n\t\t\tnavCom:resetCommand(axisVert)\n\t\t\tnavCom:activateGroundEngineAltitudeStabilization()\n\t\tend\n\tend\n\tgC.verticalState = false\nend\n\nfunction onDownArrowDown() \tinputs.mu = false\n\tlocal gC = globals\n\tif HUD.Config.mainMenuVisible then\n\t\tinputs.md = true\n\telse\n\t\tinputs.down = true\n\t\tif not (cData.isLanded or gC.maneuverMode) then\n\t\t\tnavCom:resetCommand(axisVert)\n\t\t\tnavCom:deactivateGroundEngineAltitudeStabilization()\n\t\t\tnavCom:updateCommandFromActionStart(axisVert, -1.0)\n\t\tend\n\tend\n\tgC.verticalState = true\nend\n\nfunction onDownArrowUp() \tinputs.md = false\n\tinputs.down = false\n\tlocal gC = globals\n\tif not HUD.Config.mainMenuVisible then\n\t\tif gC.maneuverMode then\n\t\t\tif gC.altitudeHold then gC.holdAltitude = cData.altitude end\n\t\telse\n\t\t\t\t\t\tnavCom:resetCommand(axisVert)\n\t\t\tnavCom:activateGroundEngineAltitudeStabilization()\n\t\tend\n\tend\n\tgC.verticalState = false\nend\n\nlocal function isForStdMode()\n\treturn not (globals.maneuverMode or HUD.Config.mainMenuVisible)\nend\n\nlocal function axLat(isStart,value)\n\tif globals.maneuverMode then return end\n\tif isStart then\n\t\tnavCom:updateCommandFromActionStart(axisLat, value)\n\telse\n\t\tnavCom:updateCommandFromActionStop(axisLat, value)\n\tend\nend\n\nlocal function resetLeftRight()\n\tinputs.direction.x = 0\n\tinputs.left = false\n\tinputs.right = false\n\tinputs.ml = false\n\tinputs.mr = false\nend\n\nfunction onLeftArrowDown() \tresetLeftRight()\n\tif HUD.Config.mainMenuVisible then inputs.ml = true return end\n\tinputs.direction.x = -1\n\tinputs.left = true\n\tif isForStdMode() then axLat(true,-1) end\n\tglobals.lateralState = true\nend\n\nfunction onLeftArrowUp() \tresetLeftRight()\n\tif isForStdMode() then axLat(false,1) end\n\tglobals.lateralState = false\nend\n\nfunction onRightArrowDown() \tresetLeftRight()\n\tif HUD.Config.mainMenuVisible then inputs.mr = true return end\n\tinputs.direction.x = 1\n\tinputs.right = true\n\tif isForStdMode() then axLat(true,1) end\n\tglobals.lateralState = true\nend\n\nfunction onRightArrowUp() \tresetLeftRight()\n\tif isForStdMode() then axLat(false,-1) end\n\tglobals.lateralState = false\nend\n\nfunction onForwardDown() \tinputs.pitch = inputs.pitch - 1\n\tif not globals.maneuverMode or not inputs.alt then return end\n\tlocal currentTime = system.getUtcTime()\n\tforwardClick = forwardClick or 0\n\tlocal time_since_last_click = currentTime - forwardClick\n\tif forwardClick == 0 or\n\t\ttime_since_last_click < DOUBLE_CLICK_MIN_THRESHOLD or\n\t\tcurrentTime - forwardClick >= DOUBLE_CLICK_MAX_THRESHOLD then\n\t\tforwardClick = currentTime\n\telse\n\t\tforwardClick = 0\n\t\tship.toggleMmb()\n\tend\nend\n\nfunction onForwardUp() \tinputs.pitch = 0\nend\n\nfunction onBackwardDown() \tinputs.pitch = inputs.pitch + 1\nend\n\nfunction onBackwardUp() \tinputs.pitch = 0\nend\n\nfunction onLeftDown() \tinputs.roll = inputs.roll - 1\nend\n\nfunction onLeftUp() \tinputs.roll = 0\nend\n\nfunction onRightDown() \tinputs.roll = inputs.roll + 1\nend\n\nfunction onRightUp() \tinputs.roll = 0\nend\n\nfunction onYawLeftDown()\n\tif inputs.yaw < 0 then\n\t\tship.rotationSpeed = ship.rotationSpeedMin\n\tend\n\tinputs.yaw = 1\nend\n\nfunction onYawLeftUp()\n\tif inputs.yaw > 0 then\n\t\tinputs.yaw = 0\n\telse\n\t\tship.rotationSpeed = ship.rotationSpeedMin\n\tend\nend\n\nfunction onYawRightDown()\n\tif inputs.yaw > 0 then\n\t\tship.rotationSpeed = ship.rotationSpeedMin\n\tend\n\tinputs.yaw = -1\nend\n\nfunction onYawRightUp()\n\tif inputs.yaw < 0 then\n\t\tinputs.yaw = 0\n\telse\n\t\tship.rotationSpeed = ship.rotationSpeedMin\n\tend\nend\n\nfunction onGroundAltitudeDownDown(loop) \tlocal gC, s = globals, ship\n\tif gC.maneuverMode and gC.altitudeHold then\n\t\tif s.holdAltitude > 109 then\n\t\t\ts.holdAltitude = RoundAlt(s.holdAltitude, ternary(loop, -5, -10))\n\t\tend\n\telse\n\t\tAutoPilot:addHoverHeight(-0.25, loop)\n\tend\nend\n\nfunction onGroundAltitudeUpDown(loop) \tlocal gC, s = globals, ship\n\tif gC.maneuverMode and gC.altitudeHold then\n\t\ts.holdAltitude = RoundAlt(s.holdAltitude, ternary(loop, 5, 10))\n\telse\n\t\tAutoPilot:addHoverHeight(0.25, loop)\n\tend\nend\n\nfunction onSpeedUpDown() \tnavCom:updateCommandFromActionStart(axisLong, 5.0)\n\tglobals.safetyThrottle = false\nend\n\nfunction onSpeedUpLoop() \tnavCom:updateCommandFromActionLoop(axisLong, 1.0)\n\tglobals.safetyThrottle = false\nend\n\nfunction onSpeedDownDown() \tnavCom:updateCommandFromActionStart(axisLong, -5.0)\n\tglobals.safetyThrottle = false\nend\n\nfunction onSpeedDownLoop() \tnavCom:updateCommandFromActionLoop(axisLong, -1.0)\n\tglobals.safetyThrottle = false\nend\n\nfunction onBrakeDown() \tinputs.brake = 1\n\tinputs.manualBrake = true\n\tAutoPilot.enabled = false\n\tresetAP()\n\tinputs.brakeLock = inputs.alt\nend\n\nfunction onBrakeLoop() \tif globals.maneuverMode then inputs.brake = 1 return end\n\tif navCom:getAxisCommandType(axisLong) == axisCommandType.byTargetSpeed then\n\t\tlocal speed = navCom:getTargetSpeed(axisLong)\n\t\tif (math.abs(speed) > 0.01) then\n\t\t\tnavCom:updateCommandFromActionLoop(axisLong, - utils.sign(speed))\n\t\tend\n\tend\nend\n\nfunction onBrakeUp() \tif not inputs.alt then\n\t\tinputs.brake = 0\n\t\tinputs.manualBrake = false\n\tend\nend\n\nfunction onActionStart(id)\n\tif id == \"lalt\" then onAlt(true) end\n\tif id == \"lshift\" then onShift(true) end\n\tif id == \"brake\" then onBrakeDown() end\n\tif id == \"option1\" then\n\t\tonAlt1()\n\telseif id == \"option2\" then\n\t\tonAlt2()\n\telseif id == \"option3\" then\n\t\tonAlt3()\n\telseif id == \"option4\" then\n\t\tonAlt4()\n\telseif id == \"option5\" then\n\t\tonAlt5()\n\telseif id == \"option6\" then\n\t\tonAlt6()\n\telseif id == \"option7\" then\n\t\tonAlt7()\n\telseif id == \"option8\" then\n\t\tonAlt8()\n\telseif id == \"option9\" then\n\t\tonAlt9()\n\telseif id == \"forward\" then\n\t\tonForwardDown()\n\telseif id == \"backward\" then\n\t\tonBackwardDown()\n\telseif id == \"left\" then\n\t\tif globals.maneuverMode then\n\t\t\tonLeftArrowDown()\n\t\telse\n\t\t\tonLeftDown()\n\t\tend\n\telseif id == \"right\" then\n\t\tif globals.maneuverMode then\n\t\t\tonRightArrowDown()\n\t\telse\n\t\t\tonRightDown()\n\t\tend\n\telseif id == \"yawleft\" then\n\t\tonYawLeftDown()\n\telseif id == \"yawright\" then\n\t\tonYawRightDown()\n\telseif id == \"strafeleft\" then\n\t\tonLeftArrowDown()\n\telseif id == \"straferight\" then\n\t\tonRightArrowDown()\n\telseif id == \"up\" then\n\t\tonUpArrowDown()\n\telseif id == \"down\" then\n\t\tonDownArrowDown()\n\telseif id == \"groundaltitudeup\" then\n\t\tonGroundAltitudeUpDown()\n\telseif id == \"groundaltitudedown\" then\n\t\tonGroundAltitudeDownDown()\n\telseif id == \"gear\" then\n\t\tonLandingGearDown()\n\telseif id == \"light\" then\n\t\tonLightDown()\n\telseif id == \"leftmouse\" then\n\t\tonMouseDown()\n\telseif id == \"stopengines\" then\n\t\tonMmbDown()\n\telseif id == \"antigravity\" then\n\t\tonAntigravDown()\n\telseif id == \"booster\" then\n\t\tonBoosterDown()\n\tend\n\tif not globals.maneuverMode then\n\t\tif id == \"speedup\" then\n\t\t\tonSpeedUpDown()\n\t\telseif id == \"speeddown\" then\n\t\t\tonSpeedDownDown()\n\t\tend\n\tend\nend\n\nfunction onActionEnd(id)\n\tif id == \"lalt\" then onAlt(false) end\n\tif id == \"lshift\" then onShift(false) end\n\tif id == \"brake\" then onBrakeUp() end\n\tif id == \"forward\" then\n\t\tonForwardUp()\n\telseif id == \"backward\" then\n\t\tonBackwardUp()\n\telseif id == \"left\" then\n\t\tif globals.maneuverMode then\n\t\t\tonLeftArrowUp()\n\t\telse\n\t\t\tonLeftUp()\n\t\tend\n\telseif id == \"right\" then\n\t\tif globals.maneuverMode then\n\t\t\tonRightArrowUp()\n\t\telse\n\t\t\tonRightUp()\n\t\tend\n\telseif id == \"yawleft\" then\n\t\tonYawLeftUp()\n\t\tship.rotationSpeed = ship.rotationSpeedMin\n\telseif id == \"yawright\" then\n\t\tonYawRightUp()\n\t\tship.rotationSpeed = ship.rotationSpeedMin\n\telseif id == \"strafeleft\" then\n\t\tonLeftArrowUp()\n\telseif id == \"straferight\" then\n\t\tonRightArrowUp()\n\telseif id == \"up\" then\n\t\tonUpArrowUp()\n\telseif id == \"down\" then\n\t\tonDownArrowUp()\n\telseif id == \"leftmouse\" then\n\t\tonMouseUp()\n\tend\nend\n\nfunction onActionLoop(id)\n\tif id == \"groundaltitudeup\" then\n\t\tonGroundAltitudeUpDown(true)\n\telseif id == \"groundaltitudedown\" then\n\t\tonGroundAltitudeDownDown(true)\n\telseif id == \"brake\" then\n\t\tonBrakeLoop()\n\telseif id == \"left\" then\n\t\tif globals.maneuverMode then\n\t\t\tonLeftArrowDown()\n\t\telse\n\t\t\tonLeftDown()\n\t\tend\n\telseif id == \"right\" then\n\t\tif globals.maneuverMode then\n\t\t\tonRightArrowDown()\n\t\telse\n\t\t\tonRightDown()\n\t\tend\n\tend\n\tif not globals.maneuverMode then\n\t\tif id == \"speedup\" then\n\t\t\tonSpeedUpLoop()\n\t\telseif id == \"speeddown\" then\n\t\t\tonSpeedDownLoop()\n\t\telseif id == \"strafeleft\" then\n\t\t\tonLeftArrowDown()\n\t\telseif id == \"straferight\" then\n\t\t\tonRightArrowDown()\n\t\tend\n\tend\nend\nend)\npackage.preload['Saga:events/system_flush.lua']=(function()\nfunction onSystemFlush()\n\tif links.core == nil or construct == nil then return end\n\tcData = getConstructData(construct, links.core)\n\t    if globals.maneuverMode then\n        ship.apply(cData)\n    else\n\t    applyShipInputs()\n    end\n    shipLandingTask(cData)\nend\nend)\npackage.preload['Saga:events/system_input.lua']=(function()\nlocal function Err(text) error('[E] '..(text or '')) return false end\nlocal ERR_INV_POS = 'Invalid ::pos'\nlocal ERR_INV_DIST = 'No vertical distance provided'\n\nlocal function setConfigValue(action, numVal, isPct, defaultNum, minValue, maxValue, configKey, apKey, successMessage)\n\tlocal uround = utils.round\n\tif numVal == nil then\n\t\tErr(string.format('%s value (%d-%d) missing', action or '', uround(minValue or 0), uround(maxValue or 0)))\n\t\treturn nil\n\tend\n\tnumVal = clamp(uround(numVal or defaultNum), minValue, maxValue)\n\tif configKey ~= nil then\n\t\tConfig:setValue(configKey, ternary(isPct, numVal / 100, numVal))\n\tend\n\tif apKey ~= nil then\n\t\tAutoPilot.userConfig[apKey] = numVal\n\t\tAutoPilot:applyConfig()\n\tend\n\tif successMessage then\n\t\tP(string.format(successMessage, numVal))\n\t\treturn numVal\n\tend\nend\n\nfunction onInput(text)\n\tif text == nil or text == \"\" then return end\n\tlocal gC, cD, ap, _hud, cfMap = globals, cData, AutoPilot, HUD, configDatabankMap\n\tlocal inputParts = split(text, ' ')\n\tlocal action = inputParts[1]:lower()\n\tlocal num2 = ternary(#inputParts > 1, tonumber(inputParts[2]), nil)\n\n\tif action:sub(1, 1) ~= '/' then\n\t\tif _hud and _hud.Config and _hud.Config.mainMenuVisible then\n\t\t\tlocal hovered = Widgets.mainMenu.optionMenu:getHoveredEntry()\n\t\t\tif not hovered or not hovered.actions or not hovered.actions.input then return end\n\t\t\tif hovered.actions.input.filter ~= nil then text = hovered.actions.input.filter(text) end\n\t\t\thovered.actions.input.func(text, hovered.actions.input.arg)\n\t\t\treturn\n\t\tend\n\tend\n\tif action == '/menu' and _hud then _hud.toggleMainMenu() end\n\tif action == '/core' and _hud then _hud.toggleCoreWidget() end\n\tif action == '/dock' and _hud then _hud.toggleDockWidget() end\n\tif action == '/dockingmode' then\n\t\tlocal num = setConfigValue(action, num2, false, 1, 1, 3, cfMap.dockMode, nil, \"Docking mode %d\")\n\t\tif num ~= nil then\n\t\t\tconstruct.setDockingMode(num)\n\t\tend\n\tend\n\tif action == '/debug' then gC.debug = not gC.debug end\n\n\tif action == '/scale' then\n\t\tsetConfigValue(action, num2, true, 100, 40, 250, cfMap.hudScale, nil, \"Scale set to %d\")\n\tend\n\n\tif action == '/landspeedhigh' then\n\t\tsetConfigValue(action, num2, false, 100, 20, 500, cfMap.landSpeedHigh, \"landSpeedHigh\", \"High-alt landing speed set to %d\")\n\tend\n\n\tif action == '/landspeedlow' then\n\t\tsetConfigValue(action, num2, false, 100, 20, 200, cfMap.landSpeedLow, \"landSpeedLow\", \"Low-alt landing speed set to %d\")\n\tend\n\n\tif action == '/travelalt' then\n\t\tsetConfigValue(action, num2, false, 1500, 100, 20000, cfMap.travelAlt, \"travelAlt\", \"Travel altitude set to %.2f\")\n\tend\n\n\t\tif action == '/addpos' then\n\t\tif RouteDatabase.currentEditId == nil then\n\t\t\tErr'First open a route in menu'\n\t\telseif #inputParts == 2 then\n\t\t\taddCustomPos(inputParts[2])\n\t\tend\n\t\treturn Err(ERR_INV_POS)\n\tend\n\n\tif gC.maneuverMode then\n\t\tif action == '/setbase' then\n\t\t\tsetApTarget(cD.position)\n\t\t\tConfig:setValue(cfMap.base, cD.position)\n\t\t\treturn\n\t\telseif action == '/clearbase' then\n\t\t\tConfig:setValue(cfMap.base, nil)\n\t\t\tP('[I] Base cleared.')\n\t\t\treturn\n\t\telseif action == '/go' then\n\t\t\tif vec3.isvector(ap.target) then\n\t\t\t\tP('Moving to '..Vec3ToPosString(ap.target))\n\t\t\t\t\t\t\t\tship.travel = gotoTarget(ap.target, true, cD.altitude)\n\t\t\tend\n\t\telseif action == '/goalt' then\n\t\t\tif num2 == nil then return Err(ERR_INV_DIST) end\n\t\t\tnum2 = clamp(num2,0,200000)\n\t\t\tif num2 > cD.altitude then\n\t\t\t\tlocal alt = ternary(num2 - cD.altitude > 0, num2 - cD.altitude, cD.altitude - num2)\n\t\t\t\tP('[I] Moving to '..round2(num2,2)..'m altitude.')\n\t\t\t\tship.vertical = moveVert(alt)\n\t\t\tend\n\t\telseif action == '/rtb' then\n\t\t\tlocal tmp = Config:getValue(cfMap.base, nil)\n\t\t\tif not tmp then return Err('No base set!') end\n\t\t\tP('[I] Back to base '..tostring(vec3(tmp)))\n\t\t\tship.travel = gotoTarget(tmp)\n\t\telseif action == '/down' then\n\t\t\tif num2 == nil then return Err(ERR_INV_DIST) end\n\t\t\tship.vertical = moveVert(-clamp(abs(num2),-200000,2000000))\n\t\telseif action == '/up' then\n\t\t\tif num2 == nil then return Err(ERR_INV_DIST) end\n\t\t\tship.vertical = moveVert(clamp(num2,0,200000))\n\t\tend\n\tend\n\n\tif action == '/goto' then\n\t\tif #inputParts < 2 or #inputParts > 3 then\n\t\t\treturn Err(ERR_INV_POS)\n\t\tend\n\t\tlocal target = convertToWorldCoordinates(inputParts[2])\n\t\tif target == nil then\n\t\t\treturn Err(ERR_INV_POS)\n\t\tend\n\t\tap:setTarget(target)\n\t\tresetAP()\n\t\tlocal b, tA = ap.targetBody, ap.targetAltitude\n\t\tif (b ~= nil) and (tA == nil or tA == 0 or (ap.target == b.center)) then\n\t\t\ttA = math.max(b.maxStaticAltitude or 1000, b.surfaceMaxAltitude or 1000)\n\t\t\tif cD.inAtmo and cD.altitude > tA then\n\t\t\t\ttA = cD.altitude\n\t\t\tend\n\t\tend\n\t\tif #inputParts == 3 then\n\t\t\tlocal num3 = tonumber(inputParts[3])\n\t\t\tif num3 ~= nil and num3 >= 100 and num3 > tA then\n\t\t\t\ttA = num3\n\t\t\tend\n\t\tend\n\t\tap.targetAltitude = round2(tA,0)\n\t\tif gC.maneuverMode then\n\t\t\tgotoTarget(target, true, cD.inAtmo and ap.userConfig.travelAlt or cD.altitude)\n\t\t\tship.travel = true\n\t\telseif not ap.enabled then\n\t\t\tonAlt1()\n\t\tend\n\t\treturn P('Target set to '..inputParts[2]..' near '..ap.targetBody.name..\n\t\t\t' '..ap.targetLoc..' at '..ap.targetAltitude..' m ')\n\tend\n\n\tif action == '/alt' or action == '/altitude' then\n\t\tif gC.altitudeHold then\n\t\t\tif num2 == nil then return end\n\t\t\tnum2 = clamp(num2,-1000,100000)\n\t\t\tgC.holdAltitude = round2(num2,0)\n\t\t\treturn P('Holding altitude set to '..gC.holdAltitude..'m')\n\t\tend\n\t\tErr\"Engage 'Altitude hold' mode first\"\n\tend\n\n\tif action == '/convert' then\n\t\tif #inputParts < 2 then\n\t\t\treturn Err(ERR_INV_POS)\n\t\tend\n\t\tlocal wPos = convertToWorldCoordinates(inputParts[2])\n\t\tif wPos == nil then return Err(ERR_INV_POS) end\n\t\tP(Vec3ToPosString(wPos))\n\t\tP(worldToMapStr(wPos) or ERR_INV_POS)\n\tend\n\n\tif action == '/current' then\n\t\tP(Vec3ToPosString(cD.position))\n\t\tP(worldToMapStr(cD.position) or ERR_INV_POS)\n\tend\n\n\tif action == '/setmaxspacespeed' or action == '/setmsp' then\n\t\tsetConfigValue(action, num2, false, 20000, 100, 50000, cfMap.maxSpaceSpeed, nil, 'Max Space Speed set to %d')\n\tend\n\n\tif action == '/setmaxpitch' or action == '/setmp' then\n\t\tsetConfigValue(action, num2, false, 30, 0, 80, cfMap.maxPitch, \"maxPitch\", 'Max Pitch set to %d')\n\tend\n\n\tif action == '/setmaxroll' or action == '/setmr' then\n\t\tsetConfigValue(action, num2, false, 35, -89, 89, cfMap.maxRoll, \"maxRoll\", 'Max Roll set to %d')\n\tend\n\n\tif action == '/shield' then\n\t\tap.userConfig.shieldManage = not ap.userConfig.shieldManage\n\t\tP('Shield management '..ternary(ap.userConfig.shieldManage,'enabled','disabled'))\n\t\tConfig:setValue(cfMap.shieldManage, ap.userConfig.shieldManage)\n\tend\n\n\tif action == '/space' then\n\t\tap.userConfig.spaceCapableOverride = not ap.userConfig.spaceCapableOverride \t\tP('Space function '..ternary(ap.userConfig.spaceCapableOverride,'enabled','disabled'))\n\t\tConfig:setValue(cfMap.spaceCapableOverride, ap.userConfig.spaceCapableOverride)\n\tend\n\n\tif action == '/agl' then\n\t\tif num2 == nil then return Err('Missing input') end\n\t\tnum2 = clamp(num2,0,20)\n\t\tap:setAgl(num2)\n\t\tP('AGL set to '..ap.userConfig.agl)\n\tend\n\n\tif action == '/hover' then\n\t\tif num2 == nil then return end\n\t\tnum2 = clamp(num2,0.5,60)\n\t\tap:setHoverHeight(num2)\n\t\tP('Hover height set to '..ap.userConfig.hoverHeight)\n\tend\n\n\tif action == '/atp' then\n\t\tap:toggleThrottleBurnProtection()\n\t\tP('Auto throttle burn protection '..ternary(ap.userConfig.throttleBurnProtection,'enabled','disabled'))\n\tend\n\n\tif action == '/orbitalt' then\n\t\tif gC.oribtalHold then\n\t\t\tif num2 == nil then\n\t\t\t\treturn Err'No valid number provided'\n\t\t\tend\n\t\t\tgC.manualOrbitAlt = round(num2,0)\n\t\t\tP('Orbit Alt set to '..gC.manualOrbitAlt)\n\t\t\tsetTargetOrbitAlt()\n\t\telse\n\t\t\tErr\"Engage 'Orbital hold' mode first!\"\n\t\tend\n\tend\n\n\tif Radar ~= nil then\n\t\tif action == '/radar' then\n\t\t\tRadar:toggleWidget()\n\t\telseif action == '/radarbox' then\n\t\t\tRadar:toggleBoxes()\n\t\tend\n\tend\n\n\tif action == '/freeze' and not player.isSeated() then\n\t\tplayer.freeze(not player.isFrozen())\n\t\tP('Frozen = ' ..tostring(player.isFrozen()))\n\tend\n\n\tif action == '/aggalt' and links.antigrav ~= nil then\n\t\tif num2 == nil then\n\t\t\treturn Err'Enter valid altitude number >= 1000!'\n\t\tend\n\t\tnum2 = math.max(1000,round(num2,0))\n\t\tlinks.antigrav.setTargetAltitude(num2)\n\t\tP('AGG target altitude: '..num2)\n\tend\n\n\t\t\t\n\tif action == '/unit' and _hud then\n\t\t_hud.toggleUnitWidget()\n\tend\nend\nend)\npackage.preload['Saga:events/system_update.lua']=(function()\nfunction onSystemUpdate()\n\tif links.core == nil or construct == nil then return end\n\tcData = getConstructData(construct, links.core)\n\tplayerData = getPlayerData()\n\taggData = getAggData()\n\twarpData = getWarpData()\n\tscrnData = {}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif AutoPilot.enabled or globals.followMode or globals.orbitalHold then\n\t\tAxis = {\n\t\t\trollAxis = 0,\n\t\t\tpitchAxis = 0,\n\t\t\tyawAxis = 0,\n\t\t\tupdownAxis = 0,\n\t\t\tleftrightAxis = 0,\n\t\t\tforwardbackAxis = 0,\n\t\t\tbrakeAxis = 0,\n\t\t\tthrottle1Axis = 0,\n\t\t\tthrottle2Axis = 0,\n\t\t\tthrottle3Axis = 0 }\n\telse\n\t\tAxis = {\n\t\t\trollAxis = -system.getAxisValue(0),\n\t\t\tpitchAxis = -system.getAxisValue(1),\n\t\t\tyawAxis = system.getAxisValue(2),\n\t\t\tthrottle1Axis = system.getAxisValue(3),\n\t\t\tbrakeAxis = -system.getAxisValue(4),\n\t\t\tleftrightAxis = system.getAxisValue(5),\n\t\t\tupdownAxis = system.getAxisValue(6),\n\t\t\tforwardbackAxis = system.getAxisValue(7),\n\t\t\tthrottle2Axis = system.getAxisValue(8),\n\t\t\tthrottle3Axis = system.getAxisValue(9) }\n\tend\n\tNav:update()\n\tHUD:update()\n\tElectronics:update()\nend\nend)\npackage.preload['Saga:events/timer_apu.lua']=(function()\nfunction onTimerAPU()\n\tlocal gCache = globals\n\tlocal axisLong = axisCommandId.longitudinal\n\tlocal axisVert = axisCommandId.vertical\n\tlocal ap = AutoPilot\n\tlocal aggData = aggData\n\tlocal cData = cData\n\n\tgCache.collision, gCache.farSide, gCache.nearSide = castIntersections()\n\t\tlocal curAltitude = cData.altitude\n\tlocal curTargAlt = ap.targetAltitude\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tif gCache.followMode then\n\t\tlocal shipDist = vector.dist(cData.position,playerData.playerPosition)\n\t\tlocal playerSpeed = playerData.playerVelocity:len()*3.6\n\t\tlocal shipSpd = 20 + playerSpeed - (20 - math.min(shipDist-50,20))\n\t\tif playerSpeed == 0 then\n\t\t\tshipSpd = 20\n\t\tend\n\t\tif shipDist > 200 then\n\t\t\tgCache.followReposition = true\n\t\t\tnavCom:setTargetGroundAltitude(ap.userConfig.hoverHeight)\n\t\t\tif ap.landingMode then\n\t\t\t\tap:toggleLandingMode(false)\n\t\t\tend\n\t\tend\n\n\t\tif gCache.followReposition then\n\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(shipSpd))\n\t\t\tif cData.speedKph > shipSpd+10 then\n\t\t\t\tinputs.brake = 1\n\t\t\telse\n\t\t\t\tinputs.brake = 0\n\t\t\tend\n\t\tend\n\n\t\tif gCache.followReposition and shipDist < 50 and playerSpeed < 30 then\n\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(0))\n\t\t\tif not ap.landingMode then\n\t\t\t\tap:toggleLandingMode(true)\n\t\t\tend\n\t\t\tgCache.followReposition = false\n\t\tend\n\tend\n\n\tif gCache.safetyThrottle and (system.getMouseWheel() ~= 0 or gCache.orbitalHold) then\n\t\tif not inputs.manualBrake then\n\t\t\tinputs.brake = 0\n\t\tend\n\t\tgCache.safetyThrottle = false\n\tend\n\n\tif ap.enabled then\n\t\tinputs.brake = 0\n\t\tnavCom:setTargetGroundAltitude(ap.userConfig.hoverHeight)\n\telse\n\t\tgCache.apMode = 'Off'\n\tend\n\n\tif ap.userConfig.throttleBurnProtection then \t\tif not ap.enabled and not ap.landingMode and not gCache.orbitalHold and not inputs.manualBrake then\n\t\t\tlocal cPitch = utils.round(cData.rpy.pitch)\n\t\t\tif cData.atmoDensity >= 0.05 or (cData.inAtmo and cData.zSpeedKPH < -100) then\n\t\t\t\tif cData.speedKph > cData.burnSpeedKph or gCache.safetyThrottle then\n\t\t\t\t\tgCache.safetyThrottle = true\n\t\t\t\t\tif controlMode() == 'cruise' then\n\t\t\t\t\t\tswapControl()\n\t\t\t\t\tend\n\t\t\t\t\tif cData.atmoDensity < 0.05 and cPitch > 5 then\n\t\t\t\t\telse navCom:setThrottleCommand(axisLong, getThrottle(cData.burnSpeedKph-100)) end\n\t\t\t\tend\n\t\t\t\tif gCache.safetyThrottle then\n\t\t\t\t\tif cData.speedKph > (cData.burnSpeedKph-50) then\n\t\t\t\t\t\tbrakeCtrl = 32\n\t\t\t\t\t\tinputs.brake = 1\n\t\t\t\t\telse\n\t\t\t\t\t\tbrakeCtrl = 33\n\t\t\t\t\t\tinputs.brake = 0\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tgCache.safetyThrottle = false\n\t\tend\n\tend\n\n\tif links.shield ~= nil and ap.userConfig.shieldManage == true then\n        local shld = links.shield \t\tlocal srp = shld.getResistancesPool()\n\t\tlocal csr = shld.getResistances() \t\tlocal rcd = shld.getResistancesCooldown() \t\tlocal shp = shld.getShieldHitpoints() \t\t\t\t\n\t\tif shld.getStressHitpointsRaw() == 0 then\n\t\t\tsrp = srp / 4\n\t\t\t\t\t\t\t\t\tif (csr[1] == srp and csr[2] == srp and csr[3] == srp and csr[4] == srp) or rcd ~= 0 then \t\t\t\t\t\telse\n\t\t\t\tshld.setResistances(srp,srp,srp,srp) \t\t\tend\n\t\telse\n\t\t\t\t\t\tlocal srr = shld.getStressRatioRaw()\n\t\t\t\t\t\tif (csr[1] == (srp*srr[1]) and csr[2] == (srp*srr[2]) and csr[3] == (srp*srr[3]) and csr[4] == (srp*srr[4])) or rcd ~= 0 then \t\t\t\t\t\t\telse \t\t\t\tshld.setResistances(srp*srr[1],srp*srr[2],srp*srr[3],srp*srr[4])\n\t\t\tend\n\t\tend\n\n\t\tif shp == 0 and shld.getVentingCooldown() == 0 then \t\t\tshld.startVenting()\n\t\tend\n\n\t\tif cData.pvpZone and not shld.isActive() then\n\t\t\tshld.activate()\n\t\telseif not cData.pvpZone and shld.isActive() then\n\t\t\tshld.deactivate()\n\t\tend\n\tend\n\n\tif inputs.pitch ~= 0 and not ap.enabled then\n\t\tgCache.holdAltitude = curAltitude\n\tend\n\n\tgCache.aggAP = false\n\t\t\t\t\t\t\n\t\tif ap.enabled or gCache.altitudeHold then\n\t\taltHold()\n\tend\n\n\tif not gCache.orbitalHold or gCache.apMode ~= 'Orbit' then\n\t\tgCache.inOrbit = false\n\tend\n\n\tif gCache.orbitalHold or gCache.apMode == 'Orbit' then\n\t\t\t\tlocal surfaceAlt = cData.body.surfaceMaxAltitude\n\t\tlocal orbitAltT = cData.orbitFocus.orbitAltTarget\n\t\tlocal orbitSpd = cData.orbitFocus.orbitSpeed * 3.6\n\t\tlocal apo = cData.orbitalParameters.apoapsis.altitude\n\t\tlocal peri = cData.orbitalParameters.periapsis.altitude\n\t\tlocal tApo = cData.orbitalParameters.timeToApoapsis\n\t\tlocal tPer = cData.orbitalParameters.timeToPeriapsis\n\t\tbrakeCtrl = 0\n\t\tinputs.brake = 0\n\n\t\tif gCache.apMode == 'Orbit' then\n\t\t\tif math.abs(getVelocityTargetAngle()) > 2 then\n\t\t\t\tbrakeCtrl = 0.1\n\t\t\t\tinputs.brake = 1\n\t\t\tend\n\t\tend\n\n\t\tif not cData.inAtmo and curAltitude >= gCache.targetOrbitAlt and not gCache.inOrbit then\n\t\t\tif cData.speedKph >= orbitSpd then\n\t\t\t\tbrakeCtrl = 1\n\t\t\t\tinputs.brake = 1\n\t\t\tend\n\t\tend\n\t\tif not gCache.inOrbit and cData.zSpeedKPH < -400 then\n\t\t\tbrakeCtrl = 2\n\t\t\tinputs.brake = 1\n\t\tend\n\n\t\tgCache.inOrbit = (apo > surfaceAlt and peri > surfaceAlt)\n\n\t\tif controlMode() == 'cruise' then\n\t\t\tswapControl()\n\t\tend\n\n\t\tif gCache.inOrbit then\n\t\t\tif apo < gCache.targetOrbitAlt-100 then\n\t\t\t\tif tPer < 5 then\n\t\t\t\t\tapoUp = true\n\t\t\t\tend\n\t\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tif (apo < gCache.targetOrbitAlt-100 and apoUp == true) or (peri < gCache.targetOrbitAlt-100 and periUp == true) then\n\t\t\t\tSpdControl = '2'\n\t\t\t\tnavCom:setThrottleCommand(axisLong, 0.1)\n\t\t\telse\n\t\t\t\tperiUp = false\n\t\t\t\tapoUp = false\n\t\t\t\tSpdControl = '3'\n\t\t\t\tnavCom:setThrottleCommand(axisLong, 0)\n\t\t\tend\n\t\t\tif apo > gCache.targetOrbitAlt+100 then\n\t\t\t\tif tPer < 5 then\n\t\t\t\t\tlastPeri = peri\n\t\t\t\t\tapoDown = true\n\t\t\t\tend\n\t\t\tend\n\t\t\tif apoDown then\n\t\t\t\tif lastPeri > peri + 50 then\n\t\t\t\t\tapoDown = false\n\t\t\t\tend\n\t\t\tend\n\t\t\tif apo > gCache.targetOrbitAlt+100 and apoDown == true then\n\t\t\t\tbrakeCtrl = 'apoDwn'\n\t\t\t\tinputs.brake = 1\n\t\t\telse\n\t\t\t\tlastPeri = peri+1000\n\t\t\t\tapoDown = false\n\t\t\tend\n\n\t\t\tif peri < gCache.targetOrbitAlt-100 then\n\t\t\t\tif tApo < 5 then\n\t\t\t\t\tperiUp = true\n\t\t\t\tend\n\t\t\tend\n\t\t\tif peri > gCache.targetOrbitAlt+100 then\n\t\t\t\tif tApo < 5 then\n\t\t\t\t   lastApo = apo\n\t\t\t\t\tperiDown = true\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif periDown then\n\t\t\t\tif lastApo > apo + 50 then\n\t\t\t\t\tperiDown = false\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif peri > gCache.targetOrbitAlt+100 and periDown == true then\n\t\t\t\tbrakeCtrl = 3\n\t\t\t\tinputs.brake = 1\n\t\t\telse\n\t\t\t\tlastApo = apo+1000\n\t\t\t\tperiDown = false\n\t\t\tend\n\t\t\treturn\n\t\tend\n\t\t\t\tlocal tavCheck = {x = math.abs(targetAngularVelocity.x), y = math.abs(targetAngularVelocity.y), z = math.abs(targetAngularVelocity.z)}\n\t\tlocal aligned = false\n\t\tif (tavCheck.x < 0.008 and  tavCheck.y < 0.008 and tavCheck.z < 0.008) then\n\t\t\taligned = true\n\t\tend\n\t\tif unit.getAtmosphereDensity() > 0.05 then\n\t\t\tSpdControl = '4'\n\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle())\n\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif orbitAltT > gCache.targetOrbitAlt-100 and curAltitude < gCache.targetOrbitAlt-5 then\n\t\t\t\tSpdControl = '5'\n\t\t\t\tnavCom:setThrottleCommand(axisLong, 0)\n\t\t\telseif orbitAltT < (gCache.targetOrbitAlt-100)  then\n\t\t\t\tSpdControl = '6'\n\t\t\t\tif aligned or cData.zSpeedKPH < 0 then\n\t\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(orbitSpd))\n\t\t\t\telse\n\t\t\t\t\tnavCom:setThrottleCommand(axisLong, 0.1)\n\t\t\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tSpdControl = '7'\n\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(orbitSpd))\n\t\t\tend\n\t\tend\n\tend\n\n\tif (ap.enabled or gCache.altitudeHold or gCache.orbitalHold)\n\t\tand cData.inAtmo and getVelocityAngle() > ap.userConfig.wingStallAngle then\n\t\tgCache.stallProtect = true\n\telse\n\t\tgCache.stallProtect = false\n\tend\n\n\tif ap.enabled and not ap.target then\n\t\tap:toggleState(false)\n\t\tP('No AP target set!')\n\telseif ap.enabled and ap.target then\n\t\tinputs.brakeLock = false\n\t\tlocal body = cData.body\n\t\tlocal targetBody = ap.targetBody\n\t\tlocal projDist = projectedDistance(ap.target)\n\t\tgCache.safetyThrottle = false\n\t\tsetTargetOrbitAlt()\n\t\t\t\tlocal behindPlanet = false\n\t\tif not ap.targetIsLastPoint then\n\t\t\tif ap.targetLoc == 'space' then\n\t\t\t\tif vector.dist(ap.target,cData.position) < 10000 then\n\t\t\t\t\tap:onPointReached()\n\t\t\t\tend\n\t\t\telseif ap.targetLoc == 'surface' then\n\t\t\t\tif sameBody and projDist < 1000 then\n\t\t\t\t\tap:onPointReached()\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tif gCache.apMode ~= 'Orbit' then\n\t\t\tbrakeCtrl = 4\n\t\t\tinputs.brake = 0\n\t\tend\n\n\t\tif gCache.aggAP then\n\t\t\tgCache.holdAltitude = aggData.aggAltitude\n\t\telseif body then\n\t\t\tif body.hasAtmosphere then\n\t\t\t\tgCache.holdAltitude = math.max(math.max(body.surfaceMaxAltitude+1500,curTargAlt+1000), body.atmoAltitude*0.5)\n\t\t\telse\n\t\t\t\tgCache.holdAltitude = math.max(body.surfaceMaxAltitude+3000,curTargAlt+1000)\n\t\t\tend\n\t\tend\n\n\t\tsameBody = false\n\t\tif targetBody and body then\n\t\t\tif targetBody.bodyId ~= body.bodyId and not gCache.spaceCapable then\n\t\t\t\tP('Ship not space capable, shutting down AP')\n\t\t\t\tap:toggleState(false)\n\t\t\tend\n\t\t\tsameBody = body.bodyId == targetBody.bodyId\n\t\tend\n\t\t\t\t\t\t\n\t\tif not gCache.spaceCapable then\n\t\t\tif not sameBody or curTargAlt > (targetBody.atmoRadius - targetBody.radius) then\n\t\t\t\tP('point on other planet, ship currently set to not space capable.')\n\t\t\t\tap:toggleState(false)\n\t\t\tend\n\t\tend\n\n\t\tlocal reEntryTrigger = false\n\t\tif gCache.apMode == 'reEntry' then\n\t\t\treEntryTrigger = true\n\t\tend\n\n\t\tif sameBody and ap.targetLoc == 'surface' then\n\t\t\tif getTargetWorldAngle() > 18 then\n\t\t\t\tbehindPlanet = true\n\t\t\tend\n\t\telse\n\t\t\tif getTargetWorldAngle() > 80 and vector.dist(body.center,cData.position) < body.radius*2 then\n\t\t\t\tbehindPlanet = true\n\t\t\tend\n\t\tend\n\n\t\tif (math.abs(cData.forwardSpeed) + math.abs(cData.lateralSpeed)) < 3 then\n\t\t\tgCache.horizontalStopped = true\n\t\telse\n\t\t\tgCache.horizontalStopped = false\n\t\tend\n\t\tif not gCache.brakeTrigger then\n\t\t\tif sameBody and cData.inAtmo and not behindPlanet and not gCache.aggAP and ap.targetLoc == 'surface' or not gCache.spaceCapable then\n\t\t\t\tgCache.apMode = 'Atmo Travel'\n\t\t\telseif (not sameBody or ap.targetLoc == 'space') and cData.inAtmo and gCache.smoothClimb then\n\t\t\t\tgCache.apMode = 'Transition'\n\t\t\telseif (((not sameBody or ap.targetLoc == 'space') and not behindPlanet and not gCache.spaceBrakeTrigger) or (sameBody and curAltitude > gCache.targetOrbitAlt+1000 and not gCache.spaceBrakeTrigger) and not aggData.aggBubble) or gCache.apMode == 'standby' then\n\t\t\t\tgCache.apMode = 'Transfer'\n\t\t\t\tgCache.orbitLock = false\n\t\t\telseif gCache.aggAP and aggData.aggBubble then\n\t\t\t\tgCache.spaceBrakeTrigger = false\n\t\t\t\tgCache.apMode = 'agg'\n\t\t\telseif (not cData.inAtmo and (cData.brakes.distance*1.5 >= projDist) and ((curAltitude < gCache.targetOrbitAlt+5000 and sameBody) or reEntryTrigger or (sameBody and gCache.inOrbit))) and not gCache.aggAP and body.hasAtmosphere and ap.targetLoc == 'surface' then \t\t\t\tgCache.orbitLock = false\n\t\t\t\tgCache.apMode = 'reEntry'\n\t\t\telseif ((behindPlanet and sameBody and curAltitude < gCache.targetOrbitAlt+2000) or (behindPlanet and not sameBody) or gCache.orbitLock) or (sameBody and curAltitude < gCache.targetOrbitAlt+2000 and not targetBody.hasAtmosphere)and not gCache.aggAP and gCache.spaceCapable then\n\t\t\t\tgCache.orbitLock = true\n\t\t\t\tgCache.apMode = 'Orbit'\n\t\t\telseif gCache.spaceBrakeTrigger and not cData.inAtmo then\n\t\t\t\tgCache.apMode = 'Space Braking'\n\t\t\tend\n\t\tend\n\n\t\tif links.antigrav ~= nil and ap.userConfig.autoAGGAdjust then\n\t\t\tif aggData.aggState and ap.targetLoc == 'surface' then\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif targetBody ~= nil then\n\t\t\t\t\tif targetBody.hasAtmosphere and not aggData.aggBubble or not sameBody then\n\t\t\t\t\t\tif aggData.aggTarget ~= targetBody.atmoAltitude then\n\t\t\t\t\t\t\tlinks.antigrav.setTargetAltitude(targetBody.atmoAltitude)\n\t\t\t\t\t\tend\n\t\t\t\t\telseif sameBody and aggData.aggBubble then\n\t\t\t\t\t\tif curTargAlt == 0 then\n\t\t\t\t\t\t\tif aggData.aggTarget ~= math.max(math.max(curTargAlt+500,1000), targetBody.surfaceMaxAltitude) then\n\t\t\t\t\t\t\t\tlinks.antigrav.setTargetAltitude(math.max(math.max(curTargAlt+500, 1000), targetBody.surfaceMaxAltitude))\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif aggData.aggTarget ~= math.max(curTargAlt+500,1000) then\n\t\t\t\t\t\t\t\tlinks.antigrav.setTargetAltitude(math.max(curTargAlt+500, 1000))\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tif links.antigrav ~= nil and gCache.apMode == 'agg' then\n\t\t\tlocal tavCheck = {x = math.abs(targetAngularVelocity.x), y = math.abs(targetAngularVelocity.y), z = math.abs(targetAngularVelocity.z)}\n\t\t\tlocal aligned = false\n\t\t\tif (tavCheck.x < 0.005 and  tavCheck.y < 0.005 and tavCheck.z < 0.005) or cData.speedKph < 4000 or (cData.G > 0.5 and not sameBody) then\n\t\t\t\taligned = true\n\t\t\tend\n\t\t\tlocal wTargetAngle = getTargetWorldAngle()\n\t\t\tlocal orbitSpd = cData.orbitFocus.orbitSpeed*3.6\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif wTargetAngle >= 0.5 and wTargetAngle < 5 and aligned then\n\t\t\t\t\t\t\t\tSpdControl = 'agg 1'\n\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(300))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tend\n\t\t\tif wTargetAngle >= 5 and aligned then\n\t\t\t\t\t\t\t\tSpdControl = 'agg 2'\n\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(orbitSpd))\n\t\t\tend\n\t\tend\n\n\t\tlocal planetDist = vector.dist(cData.position, targetBody.center)\n\t\tif targetBody.hasAtmosphere then\n\t\t\tplanetDist = utils.round(planetDist - (targetBody.atmoRadius*1.05))\n\t\telse\n\t\t\tplanetDist = planetDist - (targetBody.radius*1.5)\n\t\tend\n\n\t\tif gCache.apMode == 'Transfer' or gCache.apMode == 'Space Braking' then\n\t\t\tlocal tavCheck = {x = math.abs(targetAngularVelocity.x), y = math.abs(targetAngularVelocity.y), z = math.abs(targetAngularVelocity.z)}\n\t\t\tlocal aligned = false\n\t\t\tif ap.targetLoc == 'surface' then\n\t\t\t\tif (tavCheck.x < 0.008 and  tavCheck.y < 0.008 and tavCheck.z < 0.008) or cData.speedKph < 4000 or\n\t\t\t\t\t(cData.G > 0.5 and not sameBody and cData.speedKph < ap.maxSpaceSpeed) then\n\t\t\t\t\taligned = true\n\t\t\t\tend\n\t\t\tend\n\t\t\tif ap.targetLoc == 'space' then\n\t\t\t\tif (tavCheck.x < 0.008 and  tavCheck.y < 0.008 and tavCheck.z < 0.008) or cData.speedKph < 500\n\t\t\t\t\tor (cData.G > 0.5 and not sameBody and cData.speedKph < ap.maxSpaceSpeed) then\n\t\t\t\t\taligned = true\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif gCache.aggAP and ap.targetLoc ~= 'space' then\n\t\t\t\tlocal aggDist = ((vector.dist(targetBody.center,cData.position) - targetBody.radius) - aggData.aggTarget)\n\t\t\t\tif gCache.aggAP and cData.brakes.distance*1.5 >= aggDist then\n\t\t\t\t\tgCache.spaceBrakeTrigger = true\n\t\t\t\t\tbrakeCtrl = 9\n\t\t\t\t\tinputs.brake = 1\n\t\t\t\tend\n\t\t\t\tif gCache.aggAP and sameBody and curAltitude <= aggData.aggTarget+100 and not aggData.aggBubble then\n\t\t\t\t\tgCache.waitForBubble = true\n\t\t\t\t\tSpdControl = 'agg 5'\n\t\t\t\t\tnavCom:setThrottleCommand(axisLong, 0)\n\t\t\t\t\tbrakeCtrl = 10\n\t\t\t\t\tinputs.brake = 1\n\t\t\t\telse\n\t\t\t\t\tgCache.waitForBubble = false\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif (ap.targetLoc == 'surface' and cData.brakes.distance*1.4 >= curAltitude - gCache.targetOrbitAlt and sameBody\n\t\t\t\tand gCache.apMode ~= 'Landing' and cData.speedKph > 1000)\n\t\t\t\tor (ap.targetLoc == 'surface' and cData.brakes.distance*1.4 >= planetDist and not sameBody) then \t\t\t\tgCache.spaceBrakeTrigger = true\n\t\t\t\tbrakeCtrl = 11\n\t\t\t\tinputs.brake = 1\n\t\t\tend\n\n\t\t\tif ap.targetLoc == 'space' and cData.brakes.distance*1.4 >= vector.dist(ap.target,cData.position)-1000 then\n\t\t\t\tgCache.spaceBrakeTrigger = true\n\t\t\t\tif vector.dist(ap.target,cData.position) < 1000 then\n\t\t\t\t\tif cData.speedKph > 110 then\n\t\t\t\t\tbrakeCtrl = 11.1\n\t\t\t\t\tinputs.brake = 1\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tbrakeCtrl = 11.2\n\t\t\t\t\tinputs.brake = 1\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif getSpaceVelocityTargetAngle() > 50 and gCache.apMode ~= 'Space Braking' and not cData.inAtmo then\n\t\t\t\tbrakeCtrl = 12\n\t\t\t\tinputs.brake = 1\n\t\t\tend\n\n\t\t\tif not gCache.spaceBrakeTrigger then\n\n\t\t\t\tif cData.speedKph < ap.maxSpaceSpeed and aligned or cData.speedKph < 3000 then\n\t\t\t\t\tSpdControl = '8'\n\t\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(ap.maxSpaceSpeed))\n\t\t\t\telseif cData.speedKph < ap.maxSpaceSpeed then\n\t\t\t\t\tSpdControl = '8.1'\n\t\t\t\t\tnavCom:setThrottleCommand(axisLong, 0.3)\n\t\t\t\telse\n\t\t\t\t\tSpdControl = '8.1.1'\n\t\t\t\t\tnavCom:setThrottleCommand(axisLong, 0)\n\t\t\t\tend\n\t\t\t\tif getSpaceVelocityTargetAngle() > 0.05 and aligned and cData.speedKph >= ap.maxSpaceSpeed then\n\t\t\t\t\tSpdControl = '8.2'\n\t\t\t\t\tnavCom:setThrottleCommand(axisLong, clamp((getSpaceVelocityTargetAngle()*0.1)-0.01,0,1))\n\t\t\t\tend\n\t\t\t\tif cData.atmoDensity > 0.05 then\n\t\t\t\t\tSpdControl = '8.3'\n\t\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle())\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif ap.targetLoc == 'surface' then\n\t\t\t\t\tif not gCache.aggAP then\n\t\t\t\t\t\tif getTargetWorldAngle() > 0.5 and cData.ySpeedKPH < 500 and aligned then\n\t\t\t\t\t\t\tSpdControl = '9'\n\t\t\t\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(500,cData.forwardSpeed))\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tSpdControl = '9.1'\n\t\t\t\t\t\t\tnavCom:setThrottleCommand(axisLong, 0)\n\t\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tif getTargetWorldAngle() > 0.5 and cData.ySpeedKPH < 500 and aligned and curAltitude > aggData.aggTarget+200 then\n\t\t\t\t\t\t\tSpdControl = '9.2'\n\t\t\t\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(500,cData.forwardSpeed))\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tSpdControl = '9.3'\n\t\t\t\t\t\t\tnavCom:setThrottleCommand(axisLong, 0)\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tif not gCache.spaceBrakeTrigger then\n\t\t\t\t\t\tSpdControl = '9.4'\n\t\t\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(ap.maxSpaceSpeed))\n\t\t\t\t\telse\n\t\t\t\t\t\tSpdControl = '9.5'\n\t\t\t\t\t\tif getSpaceVelocityTargetAngle() > 10 then\n\t\t\t\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(ap.maxSpaceSpeed))\n\t\t\t\t\t\t\tbrakeCtrl = 12.1\n\t\t\t\t\t\t\tinputs.brake = 1\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(100,cData.forwardSpeed))\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tif (ap.targetLoc == 'surface' and cData.brakes.distance*1.4 >= planetDist and not sameBody)\n\t\t\tand cData.speedKph * 1000 then \t\t\tgCache.spaceBrakeTrigger = true\n\t\t\tbrakeCtrl = 11.5\n\t\t\tinputs.brake = 1\n\t\tend\n\n\t\t\t\tif (sameBody and cData.inAtmo and gCache.apMode ~= 'Orbit' and gCache.apMode ~= 'Landing' and ap.targetLoc ~= 'space' ) or gCache.apMode == 'reEntry' then\n\t\t\tif (projDist < 5000 and not gCache.brakeTrigger) then\n\t\t\t\tSpdControl = '10'\n\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(math.min(utils.round(projDist/2),500),cData.forwardSpeed))\n\t\t\t\tif cData.ySpeedKPH > math.min(utils.round(projDist/2),500)+100 and gCache.apMode == 'reEntry' then\n\t\t\t\t\tbrakeCtrl = 13\n\t\t\t\t\tinputs.brake = 1\n\t\t\t\tend\n\t\t\tend\n\t\t\tif gCache.apMode == 'reEntry' then\n\t\t\t\tif projDist < 300 then\n\t\t\t\tgCache.brakeTrigger = true\n\t\t\t\tend\n\t\t\tend\n\t\t\tif cData.inAtmo and not ap.waitForBubble then\n\t\t\t\tSpdControl = '11'\n\t\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(cData.burnSpeedKph-150))\n\t\t\t\t\tif math.abs(getVelocityTargetAngle()) > 5 then\n\t\t\t\t\t\tbrakeCtrl = 13.1\n\t\t\t\t\t\tinputs.brake = 1\n\t\t\t\t\tend\n\n\t\t\t\t\tif cData.speedKph > cData.burnSpeedKph-100 then\n\t\t\t\t\t\tbrakeCtrl = 14\n\t\t\t\t\t\tinputs.brake = 1\n\t\t\t\t\tend\n\t\t\t\t\tif cData.brakes.distance*1.5 >= projDist or projDist < 300 then\n\t\t\t\t\t\tgCache.brakeTrigger = true\n\t\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tif gCache.apMode == 'reEntry' then\n\t\t\tif getTargetWorldAngle() > 1 then\n\t\t\t\tif cData.zSpeedKPH < -200 then\n\t\t\t\t\tSpdControl = '12'\n\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle(1000,cData.forwardSpeed))\n\t\t\t\telse\n\t\t\t\t\tSpdControl = '13'\n\t\t\t\tnavCom:setThrottleCommand(axisLong, getThrottle())\n\t\t\t\tend\n\t\t\t\tif cData.speedKph >= cData.burnSpeedKph-300 then\n\t\t\t\t\tbrakeCtrl = 15\n\t\t\t\t\tinputs.brake = 1\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tgCache.brakeTrigger = true\n\t\t\tend\n\t\tend\n\n\t\tif gCache.apMode == 'Orbit' and (sameBody and not targetBody.hasAtmosphere or gCache.aggAP) then\n\n\t\t\tif math.abs(getVelocityTargetAngle()) > 5 then\n\t\t\t\tbrakeCtrl = 15.1\n\t\t\t\tinputs.brake = 1\n\t\t\tend\n\n\t\t\tif (cData.brakes.distance*1.4 >= (projDist)) then\n\t\t\t\tgCache.brakeTrigger = true\n\t\t\tend\n\t\tend\n\n\t\tif (gCache.apMode == 'reEntry' or (sameBody and curAltitude < gCache.targetOrbitAlt + 2000)) and ap.targetLoc ~= 'space' then\n\t\t\tif gCache.brakeTrigger then\n\t\t\t\tgCache.orbitLock = false\n\t\t\t\tif projDist > 1000 then\n\t\t\t\t\tgCache.brakeTrigger = false\n\t\t\t\tend\n\t\t\t\tgCache.apMode = 'Landing'\n\t\t\t\tif gCache.lastProjectedDistance > projDist then\n\t\t\t\t\tgCache.lastProjectedDistance = projDist\n\t\t\t\tend\n\t\t\t\tSpdControl = '14'\n\t\t\t\tnavCom:setThrottleCommand(axisLong, 0)\n\n\t\t\t\tif  ((not gCache.horizontalStopped) and (cData.brakes.distance*1.4 >= (gCache.lastProjectedDistance - 150))) or (cData.zSpeedKPH < -1000) then\n\t\t\t\t\tbrakeCtrl = 16\n\t\t\t\t\tinputs.brake = 1\n\t\t\t\tend\n\t\t\t\tif curTargAlt == 0 or ap.target == targetBody.center then\n\t\t\t\t\tcurTargAlt = targetBody.surfaceMaxAltitude\n\t\t\t\tend\n\t\t\t\tif links.antigrav ~= nil then\n\t\t\t\t\tif aggData.aggState and ap.targetLoc == 'surface' then\n\t\t\t\t\t\tcurTargAlt = aggData.aggAltitude\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif gCache.horizontalStopped then\n\t\t\t\t\tif (cData.brakes.distance*3 >= (curAltitude - curTargAlt)+300)\n\t\t\t\t\t\tor (cData.zSpeedKPH < -100 and (curAltitude - curTargAlt) < 400)\n\t\t\t\t\t\tor cData.speedKph > 1000 then\n\t\t\t\t\t\tbrakeCtrl = 17\n\t\t\t\t\t\tinputs.brake = 1\n\t\t\t\t\tend\n\t\t\t\t\tif curAltitude < curTargAlt+500 and cData.zSpeedKPH < -75 then\n\t\t\t\t\t\tbrakeCtrl = 18\n\t\t\t\t\t\tinputs.brake = 1\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif curAltitude <= curTargAlt and cData.vertSpeed >= 0 then\n\t\t\t\t\tap:onPointReached()\n\t\t\t\tend\n\n\t\t\t\tif gCache.horizontalStopped and projDist > 300 then \t\t\t\t\tgCache.missedTarget = true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif ap.targetLoc == 'space' then\n\t\t\tif vector.dist(ap.target,cData.position) <= 1500 then\n\t\t\t\tap:onPointReached()\n\t\t\tend\n\t\tend\n\n\t\tif gCache.initTurn then\n\t\t\tSpdControl = 'turn'\n\t\t\tif math.abs(getTargetAngle()) > 90 and cData.constructSpeed < 30 then\n\t\t\t\tnavCom:setThrottleCommand(axisLong, 0)\n\t\t\telse\n\t\t\t\tgCache.initTurn = false\n\t\t\tend\n\t\tend\n\tend\n\n\tgCache.waterMode = cData.inAtmo and curAltitude < 0\n\tif gCache.waterMode then\n\t\tif inputs.pitch ~= 0 or gCache.verticalState then\n\t\t\tgCache.waterAlt = curAltitude\n\t\tend\n\t\tif not gCache.verticalState and not ap.landingMode then\n\t\t\tif (cData.zSpeedKPH < -5) or (curAltitude < gCache.waterAlt and cData.zSpeedKPH < 5) then\n\t\t\t\tgCache.waterState = true\n\t\t\t\tnavCom:deactivateGroundEngineAltitudeStabilization()\n\t\t\t\tnavCom:resetCommand(axisVert)\n\t\t\t\tnavCom:updateCommandFromActionStart(axisVert, 1.0)\n\t\t\telse\n\t\t\t\tgCache.waterState = false\n\t\t\t\tnavCom:resetCommand(axisVert)\n\t\t\t\tnavCom:activateGroundEngineAltitudeStabilization()\n\t\t\t\tnavCom:setTargetGroundAltitude(-1)\n\t\t\tend\n\t\telse\n\t\t\tnavCom:deactivateGroundEngineAltitudeStabilization()\n\t\tend\n\tend\n\n\t\n\tif inputs.brakeLock then\n\t\tinputs.brake = 1\n\tend\nend\nend)\npackage.preload['Saga:events/timer_fuel.lua']=(function()\nfunction onTimerFuelUpdate()\n    local curTime = system.getArkTime()\n    for _, list in pairs(fuels) do\n        for _, tank in ipairs(list) do\n            tank.lastMass = tank.mass\n            tank.mass = links.core.getElementMassById(tank.uid) - tank.uMass\n            if tank.mass ~= tank.lastMass then\n                tank.percent = round2((tank.mass / tank.maxMass)*100,2)\n                tank.lastTimeLeft = tank.timeLeft\n                tank.timeLeft = math.floor(tank.mass / ((tank.lastMass - tank.mass) / (curTime - tank.lastTime)))\n                tank.lastTime = curTime;\n            end\n        end\n    end\nend\nend)\npackage.preload['Saga:events/unit_start.lua']=(function()\nfunction init()\n\tcData = {}\n\taggData = {}\n\twarpData = {}\n\tplayerData = {}\n\n\t\n\tvector = vec3()\n\ttargetAngularVelocity = vec3()\n\tlocal s, latlas = pcall(require, \"autoconf/custom/\" .. customAtlas)\n\tif not s then\n\t\tlatlas = require(\"atlas\")\n\tend\n\tatlas = latlas\n\tinitialiseAtlas()\n\tsystemId = 0\nend\n\nfunction onUnitStart()\n\tsystem.showHelper(false)\n\n\tscanLinks()\n\tif links.core == nil then\n\t\tP\"[E] Core not found, did you link it to this control unit?\"\n\t\tunit.exit()\n\t\treturn false\n\tend\n\tinit()\n\t\tfinaliseLinks()\n\tvalidateParms()\n\n\tcData = getConstructData(construct, links.core)\n\tplayerData = getPlayerData()\n\taggData = getAggData()\n\twarpData = getWarpData()\n\n\tConfig:init(links.databanks, 'SagaConf', 'SagaActiveConf')\n\tRouteDatabase:init(links.databanks, 'SagaRoutes', 'SagaActiveRoutes')\n\tRadar:init(links.radars)\n\tAutoPilot:init()\n\n\tinitializeTanks()\n\tinitEngines()\n\tresetAP()\n\n\tdynamicSVG()\n\tHUD:init()\n\tlinks.electronics:SwitchesOn()\n\n\t\t\tship = STEC()\n\n\tif unit.isRemoteControlled() then\n\t\tplayer.freeze(true)\n\tend\n\n\tNav.targetSpeedRanges = {1000, 5000, 10000, 20000, 30000}\n\tnavCom.axisCommands[axisCommandId.longitudinal].throttleMouseStepScale = 1\n\tnavCom:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, Nav.targetSpeedRanges)\n\n\tlocal cD, gC = cData, globals\n\tif not cD.vtolCapable then\n\t\tP\"[W] Low lift for Maneuver mode.\"\n\tend\n\tgC.maneuverMode = Config:getValue(configDatabankMap.maneuverMode)\n\tif gC.maneuverMode then\n\t\tsetThrottle(1,1,1)\n\t\tship.apply(cD)\n\telse\n\t\tsetThrottle()\n\t\tNav.axisCommandManager:setTargetGroundAltitude(0)\n\t\tNav:update()\n\tend\n\tif cD.isLanded then\n\t\tinputs.brake = 1\n\t\tinputs.brakeLock = true\n\tend\n\tgC.startup = false\nend\n\nfunction printHello()\n\tP'HUD/Autopilot by Sagacious, Mayumi and CodeInfused'\n\tP('v4.1.6')\n\tP'Customized by tobitege (2024-05-26)'\nend\n\nfunction initEngines()\n\tlocal gC, ap = globals, AutoPilot\n\tlocal primaryTags = 'primary'\n\tlocal secondaryTags = 'secondary'\n\tlocal tertiaryTags = 'tertiary'\n\tlocal defaultTags = 'thrust analog longitudinal'\n\tlocal getMaxT = construct.getMaxThrustAlongAxis\n\tlocal fwd = {vec3(construct.getForward()):unpack()}\n\tgC.maxPrimaryKP = getMaxT(primaryTags, fwd)\n\tgC.maxSecondaryKP = getMaxT(secondaryTags, fwd)\n\tgC.maxTertiaryKP = getMaxT(tertiaryTags, fwd)\n\tgC.maxDefaultKP = getMaxT(defaultTags, fwd)\n\n\tif not ap.userConfig.spaceCapableOverride then\n\t\tgC.spaceCapable = gC.maxDefaultKP[3] > 0\n\t\tif not gC.spaceCapable then\n\t\t\tP'[E] Longitudinal Space Thrust not detected - space transfers/orbit disabled'\n\t\tend\n\telse\n\t\tgC.spaceCapable = ap.userConfig.spaceCapableOverride\n\tend\n\n\tif boostModeOverride == 'off' then\n\t\tif (gC.maxPrimaryKP[1] > 0 and gC.maxSecondaryKP[1] > 0) then\n\t\t\tgC.advAtmoEngines = true\n\t\t\tgC.boostMode = 'hybrid'\n\t\t\tP'Atmo Engine tags detected, advanced Atmo engine control enabled'\n\t\telse\n\t\t\tgC.advAtmoEngines = false\n\t\t\tP'Atmo Engine tags not detected, advanced Atmo engine control disabled'\n\t\tend\n\t\tgC.advSpaceEngines = gC.maxPrimaryKP[3] > 0 and gC.maxSecondaryKP[3] > 0\n\t\tif gC.advSpaceEngines then\n\t\t\tgC.boostMode = 'hybrid'\n\t\t\tP'Space Engine tags detected, advanced Space engine control enabled'\n\t\telse\n\t\t\tP'Space Engine tags not detected, advanced Space engine control disabled'\n\t\tend\n\telse\n\t\tgC.boostMode = boostModeOverride\n\tend\n\tlocal cD = cData\n\tif not (cD.hasvBoosters or cD.hasHovers) then\n\t\tP'[I] No ground engines detected!'\n\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tend\nend)\npackage.preload['Saga:behaviour/kinematics.lua']=(function()\nfunction Kinematics()\n\nlocal Kinematic = {} \n\nfunction Kinematic.computeAccelerationTime(initial, acceleration, final)\n\t\treturn (final - initial) / acceleration\nend\n\nfunction Kinematic.computeBrakingDistance(initialSpeed, distance, brakes, axis)\n\tlocal cD = cData\n\tlocal mass, G, airFriction = cD.mass, cD.G, axis:dot(cD.worldAirFriction)\n\n\t\tlocal direction, absDist = sign(distance), abs(distance)\n\n\t\t\tlocal maxThrust = cData.MaxKinematics.Up\n\tif axis == cData.wFwd or axis == cData.worldBack then\n\t\tmaxThrust = ternary(direction > 0, cData.MaxKinematics.Forward, cData.MaxKinematics.Backward)\n\tend\n\n\t\tlocal grav = 0\n\tif axis == cData.worldUp or axis == cData.worldDown then\n\t\tgrav = direction * mass * G * system.getActionUpdateDeltaTime() * 2\n\tend\n\tlocal totalDecel = (brakes or 0) + grav - airFriction\n\n\t\tlocal accel = (maxThrust - direction * grav) / mass\n\n\t\tlocal maxSpeed = math.sqrt(2 * abs(accel * absDist) + initialSpeed ^ 2)\n\n\t\tinitialSpeed = math.min(initialSpeed, maxSpeed)\n\n\t\tlocal brakingDistance = (maxSpeed ^ 2 - initialSpeed ^ 2) / (2 * (totalDecel or 0.000001))\n\n\t\tlocal remainingDistance = absDist - brakingDistance\n\n\t\tif remainingDistance < 0 then\n\t\tmaxSpeed = math.sqrt(initialSpeed ^ 2 + 2 * totalDecel * absDist)\n\t\tremainingDistance = 0\n\tend\n\treturn maxSpeed * direction, remainingDistance * direction\nend\n\nfunction Kinematic.computeDistanceAndTime(initial, final, mass, thrust, t50, brakeThrust)\n\t\t\t\t\t\t\tt50 = t50 or 0\n\tbrakeThrust\t= brakeThrust or 0 \n\tlocal speedUp  = initial < final\n\tlocal a0\t   = thrust / (speedUp and mass or -mass)\n\tlocal b0\t   = -brakeThrust/mass\n\tlocal totA\t = a0+b0\n\n\tif initial == final then\n\t\treturn 0, 0   \telseif speedUp and totA <= 0 or not speedUp and totA >= 0 then\n\t\treturn -1, -1 \tend\n\n\tlocal distanceToMax, timeToMax = 0, 0\n\n\t\t\t\t\t\n\tif a0 ~= 0 and t50 > 0 then\n\t\t\t\t\t\t\n\t\tlocal c1  = math.pi/t50/2\n\n\t\tlocal v = function(t)\n\t\t\treturn a0*(t/2 - t50*math.sin(c1*t)/math.pi) + b0*t + initial\n\t\tend\n\n\t\tlocal speedchk = speedUp and function(s) return s >= final end or\n\t\t\t\t\t\t\t\t\t function(s) return s <= final end\n\t\ttimeToMax = 2*t50\n\n\t\tif speedchk(v(timeToMax)) then\n\t\t\tlocal lastTime = 0\n\t\t\twhile math.abs(timeToMax - lastTime) > 0.25 do\n\t\t\t\tlocal t = (timeToMax + lastTime)/2\n\t\t\t\tif speedchk(v(t)) then\n\t\t\t\t\ttimeToMax = t\n\t\t\t\telse\n\t\t\t\t\tlastTime = t\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\t\t\tlocal K = 2*a0*t50^2/math.pi^2\n\t\tdistanceToMax = K*(math.cos(c1*timeToMax) - 1) +\n\t\t\t\t\t\t(a0+2*b0)*timeToMax^2/4 + initial*timeToMax\n\n\t\tif timeToMax < 2*t50 then\n\t\t\treturn distanceToMax, timeToMax\n\t\tend\n\t\tinitial = v(timeToMax)\n\tend\n\t\tlocal a = a0+b0\n\tlocal t = Kinematic.computeAccelerationTime(initial, a, final)\n\tlocal d = initial*t + a*t*t/2\n\treturn distanceToMax+d, timeToMax+t\nend\n\n\n\nreturn Kinematic\n\nend\nend)\npackage.preload['Saga:behaviour/autopilot.lua']=(function()\nAutoPilot = (\nfunction()\n\tlocal this = {}\n\n\tthis.enabled = false\n\tthis.userConfig = {\n\t\tagl = agl,\n\t\tapState = false,\n\t\tautoAGGAdjust = autoAGGAdjust,\n\t\tdockMode = dockMode,\n\t\tdockWidget = dockWidget,\n\t\thoverHeight = hoverHeight,\n\t\tlandingMode = false,\n\t\tmaxPitch = maxPitch,\n\t\tmaxRoll = maxRoll,\n\t\tmaxSpaceSpeed = maxSpaceSpeed,\n\t\tshieldManage = shieldManage,\n\t\tslowFlat = true,\n\t\tspaceCapableOverride = spaceCapableOverride,\n\t\tthrottleBurnProtection = throttleBurnProtection,\n\t\twingStallAngle = wingStallAngle,\n\t\tlandSpeedHigh = maxLandingSpeedHigh,\n\t\tlandSpeedLow = maxLandingSpeedLow,\n\t\ttravelAlt = travelAlt,\n\t\tbase = nil\n\t}\n\n\tfunction this:init()\n\t\tthis:setTargetData(cData.position)\n\t\tConfig.defaults[configDatabankMap.agl] = this.userConfig.agl\n\t\tConfig.defaults[configDatabankMap.apState] = this.enabled\n\t\tConfig.defaults[configDatabankMap.autoAGGAdjust] = this.userConfig.autoAGGAdjust\n\t\tConfig.defaults[configDatabankMap.base] = nil\n\t\tConfig.defaults[configDatabankMap.dockMode] = clamp(this.userConfig.dockMode or 1,1,3)\n\t\tConfig.defaults[configDatabankMap.dockWidget] = this.userConfig.dockWidget\n\t\tConfig.defaults[configDatabankMap.hoverHeight] = this.userConfig.hoverHeight\n\t\tConfig.defaults[configDatabankMap.landingMode] = this.userConfig.landingMode\n\t\tConfig.defaults[configDatabankMap.maxPitch] = this.userConfig.maxPitch\n\t\tConfig.defaults[configDatabankMap.maxRoll] = this.userConfig.maxRoll\n\t\tConfig.defaults[configDatabankMap.maxSpaceSpeed] = this.userConfig.maxSpaceSpeed\n\t\tConfig.defaults[configDatabankMap.shieldManage] = this.userConfig.shieldManage\n\t\tConfig.defaults[configDatabankMap.slowFlat] = this.userConfig.slowFlat\n\t\tConfig.defaults[configDatabankMap.spaceCapableOverride] = this.userConfig.spaceCapableOverride\n\t\tConfig.defaults[configDatabankMap.throttleBurnProtection] = this.userConfig.throttleBurnProtection\n\t\tConfig.defaults[configDatabankMap.wingStallAngle] = this.userConfig.wingStallAngle\n\t\tConfig.defaults[configDatabankMap.landSpeedHigh] = this.userConfig.landSpeedHigh\n\t\tConfig.defaults[configDatabankMap.landSpeedLow] = this.userConfig.landSpeedLow\n\t\tConfig.defaults[configDatabankMap.travelAlt] = this.userConfig.travelAlt\n\n\t\tEventSystem:register('ConfigDBChanged', this.applyConfig, this)\n\t\tthis:applyConfig()\n\n\t\tconstruct.setDockingMode(this.userConfig.dockMode)\n\n\t\tthis:resumeFromDatabank()\n\t\tif not globals.maneuverMode then\n\t\t\tthis:toggleLandingMode(this.userConfig.landingMode)\n\t\tend\n\tend\n\n\tfunction this:applyConfig()\n\t\tthis.userConfig.agl = Config:getValue(configDatabankMap.agl)\n\t\tthis.userConfig.autoAGGAdjust = Config:getValue(configDatabankMap.autoAGGAdjust)\n\t\tthis.userConfig.base = Config:getValue(configDatabankMap.base)\n\t\tthis.userConfig.dockMode = Config:getValue(configDatabankMap.dockMode)\n\t\tthis.userConfig.dockWidget = Config:getValue(configDatabankMap.dockWidget)\n\t\tthis.userConfig.hoverHeight = Config:getValue(configDatabankMap.hoverHeight)\n\t\tthis.userConfig.landingMode = Config:getValue(configDatabankMap.landingMode)\n\t\tthis.userConfig.maxPitch = Config:getValue(configDatabankMap.maxPitch)\n\t\tthis.userConfig.maxRoll = Config:getValue(configDatabankMap.maxRoll)\n\t\tthis.userConfig.maxSpaceSpeed = Config:getValue(configDatabankMap.maxSpaceSpeed)\n\t\tthis.userConfig.shieldManage = Config:getValue(configDatabankMap.shieldManage)\n\t\tthis.userConfig.slowFlat = Config:getValue(configDatabankMap.slowFlat)\n\t\tthis.userConfig.spaceCapableOverride = Config:getValue(configDatabankMap.spaceCapableOverride)\n\t\tthis.userConfig.throttleBurnProtection = Config:getValue(configDatabankMap.throttleBurnProtection)\n\t\tthis.userConfig.landSpeedHigh = Config:getValue(configDatabankMap.landSpeedHigh)\n\t\tthis.userConfig.landSpeedLow = Config:getValue(configDatabankMap.landSpeedLow)\n\t\tthis.userConfig.travelAlt = Config:getValue(configDatabankMap.travelAlt)\n\t\tthis:setHoverHeight(this.userConfig.hoverHeight)\n\t\tthis:updateMaxSpaceSpeed()\n\tend\n\n\tfunction this:resumeFromDatabank()\n\t\tlocal lastState = Config:getDynamicValue(configDatabankMap.apState)\n\t\tif lastState then this:toggleState(lastState) end\n\n\t\tlocal target = Config:getDynamicValue(configDatabankMap.currentTarget)\n\t\tif type(target) ~= 'table' then\n\t\t\ttarget = Config:getValue(configDatabankMap.base)\n\t\tend\n\t\tif type(target) == 'table' then\n\t\t\tif target.x ~= nil then\n\t\t\t\tthis:setTarget(target)\n\t\t\telseif #target == 3 and target[3] and RouteDatabase:getDatabankName() == target[3] then\n\t\t\t\tthis:setActiveRoute(target[1], target[2])\n\t\t\tend\n\t\tend\n\tend\n\n\t\tfunction this:toggleState(state)\n\t\tif state == nil then state = not this.enabled end\n\t\t\t\tif (cData.warpOn or globals.maneuverMode) and state then return end\n\t\tthis.enabled = state\n\t\tif this.enabled then\n\t\t\tthis:toggleLandingMode(false)\n\t\t\tthis:updateMaxSpaceSpeed()\n\t\telse\n\t\t\tresetModes()\n\t\tend\n\t\tConfig:setDynamicValue(configDatabankMap.apState, this.enabled)\n\tend\n\n\tfunction this:toggleShieldManage(state)\n\t\tif state == nil then state = not this.userConfig.shieldManage end\n\t\tthis.userConfig.shieldManage = state\n\t\tConfig:setValue(configDatabankMap.shieldManage, state)\n\tend\n\n\tfunction this:toggleThrottleBurnProtection(state)\n\t\tif state == nil then state = not this.userConfig.throttleBurnProtection end\n\t\tthis.userConfig.throttleBurnProtection = state\n\t\tConfig:setValue(configDatabankMap.throttleBurnProtection, state)\n\tend\n\n\tfunction this:toggleSpaceCapableOverride(state)\n\t\tif state == nil then state = not this.userConfig.spaceCapableOverride end\n\t\tthis.userConfig.spaceCapableOverride = state\n\t\tConfig:setValue(configDatabankMap.spaceCapableOverride, state)\n\t\tinitEngines()\n\tend\n\n\tfunction this:toggleSlowFlat(state)\n\t\tif state == nil then state = not this.userConfig.slowFlat end\n\t\tthis.userConfig.slowFlat = state\n\t\tConfig:setValue(configDatabankMap.slowFlat, state)\n\tend\n\n\tfunction this:setActiveRoute(routeIndex, pointIndex)\n\t\trouteIndex = tonumber(routeIndex)\n\t\tif not routeIndex then return end\n\t\tif tonumber(pointIndex) == nil then pointIndex = 1 end\n\t\tlocal rdb = RouteDatabase\n\t\tlocal targetPos = rdb:getPointCoordinates(routeIndex, pointIndex)\n\t\tif not targetPos then return end\n\t\tthis.currentRouteIndex = routeIndex\n\t\tthis.currentPointIndex = pointIndex\n\t\tthis:setTargetData(targetPos)\n\t\tConfig:setDynamicValue(configDatabankMap.currentTarget, {this.currentRouteIndex,this.currentPointIndex,rdb.databank.name})\n\t\tlocal cnt = rdb:getRoutePointCount(routeIndex)\n\t\tthis.targetIsLastPoint = cnt == 0 or this.currentPointIndex == cnt\n\tend\n\n\tfunction this:setTarget(pos)\n\t\tthis:setTargetData(pos)\n\t\tthis.targetIsLastPoint = true\n\t\tConfig:setDynamicValue(configDatabankMap.currentTarget, pos)\n\tend\n\n\tfunction this:updateMaxSpaceSpeed()\n\t\tlocal maxUserSpeed = this.userConfig.maxSpaceSpeed\n\t\tlocal maxConstructSpeed = cData.maxSpeed*3.6 - 1\n\t\tif maxUserSpeed == 0 then\n\t\t\tthis.maxSpaceSpeed = maxConstructSpeed\n\t\telse\n\t\t\tthis.maxSpaceSpeed = maxUserSpeed\n\t\tend\n\tend\n\n\tfunction this:onPointReached()\n\t\tif not this.targetIsLastPoint then\n\t\t\tif this.currentPointIndex ~= nil then\n\t\t\t\tthis.currentPointIndex = this.currentPointIndex + 1\n\t\t\t\tthis:setActiveRoute(this.currentRouteIndex, this.currentPointIndex)\n\t\t\tend\n\t\t\tresetAP()\n\t\t\treturn\n\t\tend \t\tthis:toggleState(false)\n\t\tthis:toggleLandingMode(true)\n\tend\n\n\t\tfunction this:onRouteUnloaded()\n\t\tthis.currentRouteIndex = nil\n\t\tthis.currentPointIndex = nil\n\t\tthis:toggleState(false)\n\tend\n\n\tfunction this:setTargetData(pos)\n\t\tthis.target = vec3(pos)\n\t\tthis.targetBody = findClosestBody(this.target)\n\t\tthis.targetAltitude = getAltitude(this.target)\n\t\tthis.targetLoc = getLoc(this.targetBody, this.targetAltitude)\n\t\tthis.targetIsLastPoint = false\n\tend\n\n\tfunction this:addHoverHeight(delta, loop)\n\t\tif tonumber(delta) == nil then return P'E' end\n\t\tif loop then\n\t\t\tnavCom:updateTargetGroundAltitudeFromActionLoop(delta)\n\t\telse\n\t\t\tnavCom:updateTargetGroundAltitudeFromActionStart(delta)\n\t\tend\n\t\tthis:setHoverHeight(this.userConfig.hoverHeight + delta)\n\tend\n\n\tfunction this:setHoverHeight(height)\n\t\tif height and tonumber(height) ~= nil then\n\t\t\tthis.userConfig.hoverHeight = tonumber(height)\n\t\tend\n\t\tthis.userConfig.hoverHeight = round2(clamp(this.userConfig.hoverHeight or 20,0,50),1)\n\t\tif not (this.landingMode or ship.landingMode) then\n\t\t\tnavCom:setTargetGroundAltitude(this.userConfig.hoverHeight+this.userConfig.agl)\n\t\tend\n\t\tConfig:setValue(configDatabankMap.hoverHeight, this.userConfig.hoverHeight)\n\tend\n\n\tfunction this:setAgl(height)\n\t\tif tonumber(height) == nil then return end\n\t\tthis.userConfig.agl = tonumber(height)\n\t\tConfig:setValue(configDatabankMap.agl, height)\n\tend\n\n\tfunction this:resetNavCom(stab)\n\t\tif stab == true then\n\t\t\tnavCom:deactivateGroundEngineAltitudeStabilization()\n\t\telseif stab == false then\n\t\t\tnavCom:deactivateGroundEngineAltitudeStabilization()\n\t\tend\n\t\tnavCom:resetCommand(axisCommandId.longitudinal)\n\t\tnavCom:setThrottleCommand(axisCommandId.longitudinal, 0)\n\t\tnavCom:setTargetSpeedCommand(axisCommandId.longitudinal,0)\n\t\tnavCom:resetCommand(axisCommandId.vertical)\n\t\tnavCom:setTargetSpeedCommand(axisCommandId.vertical,0)\n\t\tNav:update()\n\tend\n\n\tfunction this:toggleLandingMode(state)\n\t\tif state == nil then state = not this.landingMode end\n\t\tthis.landingMode = state == true\n\t\tlocal gC = globals\n\t\tConfig:setValue(configDatabankMap.landingMode, this.landingMode)\n\t\tif gC.maneuverMode then return end\n\t\tif this.landingMode then\n\t\t\tgC.altitudeHold = false\n\t\t\tgC.orbitalHold = false\n\t\t\tgC.rotationDampening = true\n\t\t\tinputs.brake = 1\n\t\t\tinputs.brakeLock = false\n\t\t\tunit.deployLandingGears()\n\t\t\tif not gC.maneuverMode then\n\t\t\t\tif unit.getControlMode() == 1 then\n\t\t\t\t\tswapControl()\n\t\t\t\tend\n\t\t\t\tnavCom:setThrottleCommand(axisCommandId.longitudinal, 0)\n\t\t\t\tnavCom:setTargetSpeedCommand(axisCommandId.longitudinal,0)\n\t\t\t\tnavCom:setTargetGroundAltitude(-1)\n\t\t\tend\n\t\t\tlinks.electronics:OpenDoors()\n\t\telseif not gC.maneuverMode then\n\t\t\tnavCom:resetCommand(axisCommandId.vertical)\n\t\t\tnavCom:setTargetGroundAltitude(AutoPilot.userConfig.hoverHeight)\n\t\t\tnavCom:activateGroundEngineAltitudeStabilization()\n\t\t\tNav:update()\n\t\t\tunit.retractLandingGears()\n\t\t\tlinks.electronics:CloseDoors()\n\t\t\tinputs.brake = 0\n\t\tend\n\tend\n\treturn this\nend\n)()\n\nfunction getLoc(body, altitude)\n\tif body ~= nil and body.hasAtmosphere and altitude < body.atmoRadius - body.radius then\n\t\treturn 'surface'\n\telseif body ~= nil and not body.hasAtmosphere and altitude < body.surfaceMaxAltitude + 5000 then\n\t\treturn 'surface'\n\tend\n\treturn 'space'\nend\n\nfunction orbitHold()\n\tsetTargetOrbitAlt()\n\tlocal gCache, ap = globals, AutoPilot\n\tlocal apoDiff = (gCache.targetOrbitAlt - cData.orbitFocus.orbitAltTarget)\n\tlocal minmax = 20000 + cData.constructSpeed\n\tlocal orbPitch = (utils.smoothstep(apoDiff, -minmax, minmax) - 0.5) * 2 * ap.userConfig.maxPitch\n\tif cData.inAtmo then\n\t\torbPitch = ap.userConfig.maxPitch\n\tend\n\treturn orbPitch\nend\n\nfunction altHold()\n\tlocal gCache, ap, cD = globals, AutoPilot, cData\n\tif ap.enabled or gCache.altitudeHold or gCache.orbitalHold or gCache.apMode == 'Orbit' then\n\t\tlocal altitude = cD.altitude\n\t\tlocal altDiff = (gCache.holdAltitude - altitude)\n\t\tlocal minmax = 500 + cD.constructSpeed\n\t\tgCache.targetPitch = (utils.smoothstep(altDiff, -minmax, minmax) - 0.5) * 2 * ap.userConfig.maxPitch\n\t\tif altDiff < 0 and cData.inAtmo then\n\t\t\tgCache.targetPitch = gCache.targetPitch/6\n\t\tend\n\t\tlocal pitch = cD.rpy.pitch\n\t\tlocal autoPitchThreshold = 0.1\n\t\tif math.abs(gCache.targetPitch - pitch) > autoPitchThreshold then\n\t\t\tif (pitchPID3 == nil) then\n\t\t\t\tpitchPID3 = pid.new(0.02, 0, 0.1)\n\t\t\tend\n\t\t\tpitchPID3:inject(gCache.targetPitch - pitch)\n\t\t\tlocal autoPitchInput2 = pitchPID3:get()\n\t\t\tpitchInput2 = autoPitchInput2\n\t\tend\n\tend\nend\n\nfunction controlMode()\n\treturn ternary(unit.getControlMode() == 0, 'travel', 'cruise')\nend\n\nfunction swapControl()\n\tif unit.getControlMode() > 0 then\n\t\tunit.cancelCurrentControlMasterMode()\n\tend\n\tNav:update()\nend\n\nfunction resetAP()\n\tlocal gC = globals\n\tgC.aimTarget = \"none\"\n\tgC.orbitLock = false\n\tgC.brakeTrigger = false\n\tgC.spaceBrakeTrigger = false\n\tgC.stallProtect = false\n\tgC.lastProjectedDistance = 10000000\n\tgC.missedTarget = false\n\tgC.horizontalStopped = false\n\tgC.apMode = 'standby'\n\tgC.initTurn = true\n\tinputs.brakeLock = false\nend\n\nfunction resetModes()\n\tlocal gC, ap = globals, AutoPilot\n\tap.enabled = false\n\tap.landingMode = false\n\tresetAP()\n\tgC.altitudeHold = false\n\tgC.orbitalHold = false\n\tgC.followMode = false\n\tgC.radialIn = false\n\tgC.radialOut = false\n\tgC.cameraAim = false\n\tradialMode = 'none'\nend\n\nfunction setTargetOrbitAlt()\n\tlocal gCache = globals\n\tgCache.targetOrbitAlt = 100000 \tlocal body = cData.body\n\tif body == nil then return end\n\tlocal targetBody = AutoPilot.targetBody\n\tif targetBody == nil then return end\n\tlocal altBuff = cData.mass/2500\n\tif gCache.apMode == 'Orbit' then\n\t\tif sameBody and targetBody.hasAtmosphere then\n\t\t\tgCache.targetOrbitAlt = (targetBody.atmoRadius - targetBody.radius)+1500+altBuff\n\t\telseif not sameBody and body.hasAtmosphere then\n\t\t\tgCache.targetOrbitAlt = (body.atmoRadius - body.radius)+5000+altBuff\n\t\telseif (not sameBody and not body.hasAtmosphere) or (sameBody and not targetBody.hasAtmosphere) then\n\t\t\tgCache.targetOrbitAlt = body.surfaceMaxAltitude + 3000+altBuff\n\t\tend\n\telseif gCache.manualOrbitAlt ~= 0 then\n\t\tgCache.targetOrbitAlt = gCache.manualOrbitAlt\n\telse\n\t\tif body.hasAtmosphere and gCache.manualOrbitAlt == 0 then\n\t\t\tgCache.targetOrbitAlt = (body.atmoRadius - body.radius)+3000+altBuff \t\telse\n\t\t\tgCache.targetOrbitAlt = body.surfaceMaxAltitude + 3000+altBuff\n\t\tend\n\tend\nend\nend)\npackage.preload['Saga:behaviour/electronics.lua']=(function()\nElectronics = (\nfunction()\n    local this = {}\n\n    this.doors = {}\n    this.forcefields = {}\n    this.switches = {}\n    this.queue = {}\n\n    function this:update(state, elements)\n        while #this.queue > 0 do\n            table.remove(this.queue)()\n        end\n    end\n\n    function this:SetElement(state, elements)\n        if state == nil then state = true end\n        for _,element in pairs(elements) do\n            if state then\n                element.deactivate()\n                table.insert(this.queue, element.activate)\n            else\n                element.activate()\n                table.insert(this.queue, element.deactivate)\n            end\n        end\n    end\n\n    function this:OpenDoors() this:SetElement(true, this.doors) end\n    function this:CloseDoors() this:SetElement(false, this.doors) end\n\n    function this:ForcefieldsOn() this:SetElement(true, this.forcefields) end\n    function this:ForcefieldsOff() this:SetElement(false, this.forcefields) end\n\n    function this:SwitchesOn() this:SetElement(true, this.switches) end\n    function this:SwitchesOff() this:SetElement(false, this.switches) end\n\n    return this\nend\n)()\nend)\npackage.preload['Saga:behaviour/ship_maneuver.lua']=(function()\nlocal abs, clamp, max, min, atan, rad, sign, uround, mceil, sqrt = math.abs, utils.clamp, math.max, math.min, math.atan, math.rad, utils.sign, utils.round, math.ceil, math.sqrt\n\nfunction STEC()\n\tlocal self = {}\n\t\tself.rotationSpeed = 0.25\n\t\tself.rotationSpeedMin = 0.25\n\t\tself.rotationSpeedMax = 15\n\t\tself.rotationStep = 0.025\n\t\tself.thrust = vec3()\n\tself.angularThrust = vec3()\n\tself.inertialDampening = true \tself.IDIntensity = 9\n\t\tself.brakingFactor = 10\n\t\tself.followGravity = true\n\t\tself.controlMode = nil \t\tself.alternateCM = false\n\t\tself.throttle = 100\n\t\tself.tempThrottle = 100\n\tself.mmbThrottle = false \tself.priorityTags1 = \"brake,airfoil,torque,vertical,lateral,longitudinal\"\n\tself.priorityTags2 = \"atmospheric_engine,space_engine\"\n\t\tself.angle = 0\n\t\tself.isAbove = false\n\t\tself.gotoLock = nil\n\tself.landingMode = false\n\tself.traverse = false\n\tself.targetVector = nil\n\tself.targetVectorAutoUnlock = true\n\tself.vertical = false\n\t\t\tself.holdAltitude = cData.altitude\n\tself.targetDist = 0\n\tself.state = nil\n\tself.yawDamp = true \tself.travelAltitude = nil \tself.latPID = pid.new(5, 0, 10.0)\n\n\tfunction self.toggleMmb(state)\n\t\tif state == nil then state = not self.mmbThrottle end\n\t\tlocal gC, cD = globals, cData\n\t\tself.mmbThrottle = state == true\n\t\t\t\tif self.alternateCM then\n\t\t\tnavCom:resetCommand(axisCommandId.longitudinal)\n\t\t\tcD.curThrottle = 0\n\t\t\tself.throttle = 0\n\t\t\tself.mmbThrottle = false\n\t\t\treturn\n\t\tend\n\t\t\t\tif self.mmbThrottle and self.gotoLock ~= nil then\n\t\t\tself.mmbThrottle = false\n\t\t\treturn\n\t\tend\n\t\tgC.altitudeHold = self.mmbThrottle\n\t\tif self.mmbThrottle then\n\t\t\tself.throttle = 100\n\t\t\tcD.curThrottle = 1\n\t\t\tgC.holdAltitude = cD.altitude\n\t\t\tself.holdAltitude = cD.altitude\n\t\tend\n\tend\n\n\tfunction self.scaleRotation()\n\t\tif self.rotationSpeed < self.rotationSpeedMax then\n\t\t\tself.rotationSpeed = clamp(self.rotationSpeed + self.rotationStep,\n\t\t\t\tself.rotationSpeedMin, self.rotationSpeedMax)\n\t\tend\n\tend\n\n\tfunction self.movePosAltitude(pos, distance)\n\t\tlocal cD = cData\n\t\tif cD.gravity == nil then return pos end\n\t\treturn pos - (cD.gravityDir * (distance or 0))\n\tend\n\n\tfunction self.moveWaypointZ(cD, altitude)\n\t\treturn cD.position - (cD.gravityDir * (altitude or 0))\n\tend\n\n\tfunction self.moveWaypointY(cD, altitude, distance)\n\t\tlocal a = self.moveWaypointZ(cD, altitude - cD.altitude)\n\t\treturn a - (cD.wRight:cross(cD.gravity):normalize()) * -distance\n\tend\n\n\tfunction self.prepLanding()\n\t\tif self.landingMode then\n\t\t\tinputs.up = false\n\t\t\tinputs.down = false\n\t\t\tunit.deployLandingGears()\n\t\telse\n\t\t\tunit.retractLandingGears()\n\t\tend\n\tend\n\n\tfunction self.resetFlags()\n\t\tlocal gC = globals\n\t\tif gC.maneuverMode then\n\t\t\tgC.altitudeHold = false\n\t\tend\n\t\tself.dt = nil\n\t\tself.followGravity = true\n\t\tself.gotoLock = nil\n\t\tself.landingMode = false\n\t\tself.mmbThrottle = false\n\t\tself.state = nil\n\t\tself.takeoff = false\n\t\tself.targetVector = nil\n\t\tself.travel = false\n\t\tself.traverse = false\n\t\tself.vertical = false\n\tend\n\n\tfunction self.resetMoving()\n\t\tif AutoPilot.landingMode then\n\t\t\t\t\t\tAutoPilot.landingMode = false\n\t\tend\n\t\tlocal gC = globals\n\t\tgC.altitudeHold = false\n\t\tif gC.maneuverMode then\n\t\t\tself.toggleMmb(false)\n\t\t\tself.resetFlags()\n\t\tend\n\tend\n\n\tfunction self.resetManeuver()\n\t\tlocal gC = globals\n\t\tgC.maneuverMode = true\n\t\tgC.rotationDampening = true\n\t\tresetModes()\n\t\tif unit.getControlMode() == 1 then\n\t\t\tunit.cancelCurrentControlMasterMode()\n\t\t\tNav:update()\n\t\t\tself.controlMode = 0\n\t\t\tself.throttle = 100\n\t\t\tself.alternateCM = false\n\t\tend\n\t\tAutoPilot:resetNavCom(false)\n\t\tinputs.direction = vec3()\n\t\tinputs.rotation = vec3()\n\t\tself.resetFlags()\n\t\tself.alternateCM = false\n\t\tself.controlMode = 0\n\t\tself.throttle = 100\n\t\tsetThrottle(1,1,1)\n\t\tdynamicSVG()\n\tend\n\n\tfunction self.stopLanding()\n\t\tlocal gC = globals\n\t\tself.resetMoving()\n\t\tself.targetVector = nil\n\t\tself.landingMode = false\n\t\tif not gC.startup then\n\t\t\tif gC.prevStdMode then\n\t\t\t\tgC.maneuverMode = true \t\t\t\tonAlt9()\n\t\t\tend\n\t\t\tif not player.isSeated() or unit.isRemoteControlled() then unit.exit() end\n\t\tend\n\t\tinputs.brake = 1\n\t\tinputs.brakeLock = true\n\tend\n\n\tfunction self.trimAngle(cD)\n\t\tif not ((abs(self.angle) <= 0.0008) or self.isAbove) then\n\t\t\tlocal dmpVal, wUp = self.angle, cD.worldUp\n\t\t\t\t\t\tlocal yAAcc = cD.worldAngularAcceleration:dot(wUp)\n\t\t\t\t\t\tlocal yAVel = cD.worldAngularVelocity:dot(wUp)\n\t\t\tlocal pYVel = yAVel + yAAcc * self.dt\n\n\t\t\t\t\t\tif abs(dmpVal) > 0.01 and abs(yAVel) < 0.01 and abs(yAAcc) < 0.01 then\n\t\t\t\tdmpVal = dmpVal + sign(dmpVal) * self.rotationSpeedMin\n\t\t\tend\n\t\t\tdmpVal = getDampener('P', dmpVal, 2*math.pi)\n\t\t\tpYVel = pYVel * dmpVal\n\t\t\tlocal dAVel = (self.angle - pYVel) * dmpVal\n\t\t\tdmpVal = (dAVel - yAVel) * dmpVal\n\t\t\tself.yawDamp = abs(pYVel) >= 0.15 \t\t\treturn wUp * dmpVal\n\t\tend\n\t\treturn vec3()\n\tend\n\n\tfunction self.applyAltitudeHold(cD, doHoldAlt, tmp, atmp)\n\t\t\t\t\t\t\t\tif doHoldAlt then\n\t\t\t\t\t\tlocal deltaAltitude = clamp((self.holdAltitude or cD.altitude) - cD.altitude, -10, 10)\n\t\t\tlocal wp = self.moveWaypointY(cD, self.holdAltitude - deltaAltitude, cD.forwardSpeed + 100)\n\t\t\tself.targetVector = (wp - cD.position):normalize()\n\t\t\ttmp = tmp - (cD.gravity * cD.mass * deltaAltitude)\n\t\t\t\t\t  - (cD.mass * (cD.vertSpeed + vec3(0,0,cD.axisAccel.z * 1)))\n\t\telseif not (cD.isLanded or self.landingMode or self.takeoff or self.vertical)\n\t\t\t\tand not (inputs.up or inputs.down)\n\t\t\t\tand (self.mmbThrottle or inputs.pitch ~= 0) then\n\t\t\t\t\t\ttmp = tmp - (cD.mass * (cD.vertSpeed + vec3(0,0,cD.axisAccel.z * 1)))\n\t\tend\n\t\t\t\tatmp = atmp - (cD.wRight:cross(cD.wFwd:cross(cD.gravity:normalize())) *\n\t\t\t\t\t   ((cD.worldAngularVelocity * 3) - (cD.angularAirFriction * 3)))\n\t\treturn tmp, atmp\n\tend\n\n\tfunction self.switchState(state)\n\t\tif self.state == state then return end\n\t\tself.state = state\n\t\tif state then P('[I] ' .. state) end\n\tend\n\n\tfunction self.miniPilot(cD, tmpOrg, atmpOrg)\n\t\tif self.gotoLock == nil then return tmpOrg, atmpOrg end\n\n\t\tlocal tmp, atmp = tmpOrg:clone(), atmpOrg:clone()\n\t\tlocal gC, ap, cPos = globals, AutoPilot, cD.position\n\t\tlocal targetRadius, b, mass = 0.02, cD.body, cD.mass\n\t\tself.yawDamp = true\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tif self.landingMode then\n\t\t\tself.state = 'LANDING'\n\t\telseif (self.travel and not self.state) or self.takeoff or self.vertical then\n\t\t\tself.state = 'ALTITUDE'\n\t\telseif self.travel and self.traverse then\n\t\t\tself.state = 'TRAVERSING'\n\t\telseif (cD.isLanded or self.state == 'LANDED') and not (self.takeoff or self.vertical) then\n\t\t\tself.resetMoving()\n\t\t\treturn tmp,atmp\n\t\tend\n\t\tif not self.state then\n\t\t\tP'[E] State not set!'\n\t\t\treturn tmp, atmp\n\t\tend\n\n\t\t\t\tlocal target = vec3(self.gotoLock):clone()\n\t\tlocal tmpAltOrg = getAltitude(target)\n\t\tlocal tmpAlt = tmpAltOrg \n\t\t\t\t\t\t\t\tif self.state == 'ALTITUDE' and (self.travel or self.traverse) then\n\t\t\t\t\t\tlocal altCeil = tmpAlt + ternary(self.travel, 50, 0)\n\t\t\t\t\t\tlocal trvA = 0\n\t\t\tif cD.inAtmo and self.travel and self.travelAltitude then\n\t\t\t\ttrvA = self.travelAltitude\n\t\t\tend\n\t\t\tif trvA > altCeil and trvA > cD.altitude then\n\t\t\t\taltCeil = trvA\n\t\t\telseif cD.altitude > altCeil then\n\t\t\t\taltCeil = cD.altitude\n\t\t\tend\n\t\t\t\t\t\ttarget = self.movePosAltitude(cPos, altCeil - cD.altitude )\n\t\t\t\t\t\ttmpAlt = getAltitude(target)\n\t\t\tself.travelAltitude = tmpAlt \t\tend\n\n\t\t\t\tlocal altDiff = round2(tmpAlt - cD.altitude, 2)\n\t\tlocal targetDirection = (target - cPos)\n\t\tself.targetDist = abs(targetDirection:len())\n\t\tself.angle = -math.rad(getTargetAngle(target))\n\t\tself.isAbove = isDirectlyAbove(cPos, target, 0.3)\n\n\n\t\t\t\tself.dt = clamp(system.getActionUpdateDeltaTime(),0.0015,0.5)\n\n\t\t\t\tlocal speed = ap.userConfig.landSpeedLow\n\t\tif self.state == \"TRAVERSING\" then\n\t\t\tspeed = ternary(cD.inAtmo, min(1080, cD.burnSpeedKph - 100), 200)\n\t\telseif self.vertical and (altDiff > 0) then\n\t\t\tspeed = ap.userConfig.landSpeedHigh\n\t\tend\n\n\t\t\t\tlocal delta = vec3()\n\t\tif self.state == \"ALTITUDE\" or self.state == \"LANDING\" then\n\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif altDiff < 0 and cD.GrndDist and (cD.GrndDist <= abs(altDiff)) then\n\t\t\t\taltDiff = cD.GrndDist\n\t\t\t\tself.gotoLock = self.movePosAltitude(cPos, -altDiff)\n\t\t\t\t\t\t\t\ttarget = self.gotoLock:clone()\n\t\t\t\ttmpAlt = getAltitude(target)\n\t\t\t\ttmpAltOrg = tmpAlt\n\t\t\tend\n\t\t\ttargetDirection = target - cPos\n\t\t\tself.targetDist = abs(targetDirection:len() - targetRadius)\n\n\t\t\t\t\t\tif (self.targetDist <= targetRadius) or (abs(altDiff) <= 0.1) or\n\t\t\t\t((self.takeoff or self.vertical) and self.targetDist <= 0.1) or\n\t\t\t\t(self.landingMode and self.GrndDist and self.GrndDist <= 0.2)\n\t\t\t then\n\t\t\t\tif self.vertical or self.takeoff then\n\t\t\t\t\tself.resetMoving()\n\t\t\t\t\tself.switchState()\n\t\t\t\telseif self.state == 'LANDING' then\n\t\t\t\t\tself.switchState('LANDED')\n\t\t\t\t\tself.landingMode = false\n\t\t\t\t\tif gC.prevStdMode then\n\t\t\t\t\t\t\t\t\t\t\t\tgC.maneuverMode = false\n\t\t\t\t\t\tsetThrottle()\n\t\t\t\t\telse\n\t\t\t\t\t\tself.stopLanding()\n\t\t\t\t\tend\n\t\t\t\telseif self.landingMode then\n\t\t\t\t\tself.switchState('LANDING')\n\t\t\t\telse\n\t\t\t\t\tself.switchState('ALIGNING')\n\t\t\t\tend\n\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\tlocal atmoLimit = 1000 \t\t\t\tif cD.inAtmo and b and tonumber(b.surfaceAverageAltitude) ~= nil then\n\t\t\t\t\t\t\t\t\t\tatmoLimit = atmoLimit + b.surfaceAverageAltitude\n\t\t\t\tend\n\n\t\t\t\t\t\t\t\tlocal axis = (self.landingMode or altDiff < 0) and 'worldDown' or 'worldUp'\n\t\t\t\tlocal res = AxisLimiter(cD, axis, atmoLimit, altDiff)\n\t\t\t\tif res and vec3.isvector(res) then\n\t\t\t\t\tdelta.z = res.z\n\t\t\t\t\t\t\t\t\t\tdelta = localToWorld(delta, cD.worldUp, cD.wRight, cD.wFwd)\n\t\t\t\t\ttmp = tmp + (delta * mass * cD.gravVert)\n\t\t\t\telse self.resetMoving() end\n\t\t\tend\n\t\telseif self.state == \"ALIGNING\" then\n\t\t\tif abs(self.angle) <= 0.0008 then\n\t\t\t\tself.travelAltitude = cD.altitude\n\t\t\t\tif cD.inAtmo then\n\t\t\t\t\tself.travelAltitude = max(cD.altitude, ap.userConfig.travelAlt)\n\t\t\t\tend\n\t\t\t\tself.holdAltitude = self.travelAltitude\n\t\t\t\tself.switchState('TRAVERSING')\n\t\t\telse\n\t\t\t\t\t\t\t\tif self.angle > 1 then\n\t\t\t\t\tself.switchState('ALIGNING')\n\t\t\t\telse\n\t\t\t\t\tatmp = atmp + self.trimAngle(cD)\n\t\t\t\tend\n\t\t\tend\n\t\telseif self.state == \"TRAVERSING\" then\n\t\t\t\t\t\t\t\t\tgC.altitudeHold = self.targetDist >= 50\n\t\t\tif gC.altitudeHold and not self.holdAltitude then\n\t\t\t\tself.holdAltitude = gC.holdAltitude\n\t\t\tend\n\n\t\t\t\t\t\tatmp = atmp + self.trimAngle(cD)\n\n\t\t\t\t\t\t\t\t\ttarget = self.movePosAltitude(self.gotoLock, cD.altitude - self.holdAltitude)\n\t\t\tself.targetVector = (target - cPos):normalize()\n\t\t\tself.isAbove = isDirectlyAbove(cPos, target, 0.3)\n\n\t\t\t\t\t\tlocal angleSign = (self.angle >= (-math.pi / 2)) and (self.angle <= (math.pi / 2)) and 1 or -1\n\t\t\tlocal locPos = worldToLocal(cPos)\n\t\t\tlocal locTrg = worldToLocal(target)\n\t\t\tself.targetDist = angleSign * getTravelDistance(locTrg, locPos, cD.body)\n\n\t\t\t\t\t\tself.latPID:reset()\n\t\t\tself.latPID:inject(cD.lateralSpeed * self.dt)\n\t\t\tlocal latCorr = self.latPID:get()\n\t\t\tdelta = delta + cD.wRight * latCorr\n\n\t\t\tif self.targetDist > 0 then\n\t\t\t\t\t\t\t\tlocal res = AxisLimiter(cD, 'cFwd', speed, self.targetDist)\n\t\t\t\tif res and vec3.isvector(res) then\n\t\t\t\t\tdelta.y = res.y\n\t\t\t\t\t\t\t\t\t\tdelta = localToWorld(delta, cD.worldUp, cD.wRight, cD.wFwd)\n\t\t\t\t\ttmp = tmp + (delta * mass * cD.gravVert)\n\t\t\t\telse self.resetMoving() end\n\t\t\tend\n\n\t\t\t\t\t\tif ((self.isAbove or self.targetDist <= 0.2) and math.abs(cD.forwardSpeed) < 1) then\n\t\t\t\t\t\t\t\t\t\t\t\tself.resetFlags()\n\t\t\t\tself.prepLanding()\n\t\t\t\tself.landingMode = true\n\t\t\t\tself.switchState('LANDING')\n\t\t\tend\n\t\tend\n\t\treturn tmp, atmp\n\n\tend \n\tfunction self.apply(cD)\n\t\tlocal tmp = self.thrust\n\t\tlocal atmp = self.angularThrust\n\t\tself.throttle = ternary(self.alternateCM, cD.curThrottle / 100, cD.curThrottle)\n\n\t\t\t\tlocal gC, ap, landed = globals, AutoPilot, cD.isLanded\n\t\tlocal isStartup, mass, cSpeed = gC.startup, cD.mass, cD.constructSpeed\n\n\t\t\t\tif inputs.direction.x ~= 0 then\n\t\t\t\t\t\ttmp = tmp + (sign(inputs.direction.x) * cD.wRight * ternary(inputs.direction.x, cD.MaxKinematics.Right, cD.MaxKinematics.Left))\n\t\tend\n\n\t\t\t\tif not self.alternateCM then\n\t\t\tif (self.mmbThrottle ) or inputs.pitch < 0 then\n\t\t\t\tlocal t = ternary(self.mmbThrottle, 100, self.throttle)\n\t\t\t\ttmp = tmp + (t * cD.wFwd * cD.MaxKinematics.Forward)\n\t\t\telseif inputs.pitch > 0 then\n\t\t\t\ttmp = tmp - (self.throttle * cD.wFwd * cD.MaxKinematics.Backward)\n\t\t\tend\n\t\tend\n\n\t\t\t\tif inputs.yaw ~= 0 then\n\t\t\tself.scaleRotation()\n\t\t\tatmp = atmp - ((cD.wFwd:cross(cD.wRight) * inputs.yaw) * self.rotationSpeed)\n\t\tend\n\n\t\t\t\tif inputs.up or inputs.down then\n\t\t\t\t\t\tif inputs.up then\n\t\t\t\ttmp = tmp + (cD.worldUp * cD.MaxKinematics.Up * self.IDIntensity)\n\t\t\tend\n\t\t\tif inputs.down then\n\t\t\t\ttmp = tmp - (cD.worldUp * cD.MaxKinematics.Down * self.IDIntensity)\n\t\t\tend\n\t\tend\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tlocal braking = inputs.brakeLock or (inputs.brake ~= 0)\n\t\tif braking then\n\t\t\tgC.altitudeHold = false\n\t\t\tif self.mmbThrottle then\n\t\t\t\tself.toggleMmb()\n\t\t\tend\n\t\t\tself.resetFlags()\n\t\t\tlocal a1 = self.brakingFactor * max(1, cSpeed / cD.atmoD * 1)\n\t\t\tif inputs.brakeLock then\n\t\t\t\ttmp = -cD.wVel * mass * max(brakeFlatFactor,0.01)\n\t\t\telse\n\t\t\t\ttmp = -cD.wVel * mass * max(a1, cSpeed * cSpeed)\n\t\t\tend\n\t\tend\n\n\t\t\t\t\t\tif self.holdAltitude < 100 then\n\t\t\tself.holdAltitude = cD.altitude\n\t\tend\n\n\t\t\t\tif not landed then\n\t\t\tlocal doHoldAlt = gC.altitudeHold and self.holdAltitude >= 100\n\t\t\t\t\t\t\tand not (self.landingMode or self.takeoff or self.vertical)\n\t\t\ttmp, atmp = self.applyAltitudeHold(cD, doHoldAlt, tmp, atmp)\n\t\tend\n\n\t\t\t\tif self.followGravity then\n\t\t\tatmp = atmp - (cD.worldUp:cross(cD.gravity:normalize()) * cD.gravity:len())\n\t\tend\n\n\t\t\t\tif not self.alternateCM and (self.landingMode or self.takeoff or self.vertical)\n\t\t\t\tand (inputs.up or inputs.down) then\n\t\t\tself.resetMoving()\n\t\tend\n\n\t\t\t\tif self.targetVector == nil then\n\t\t\tself.gotoLock = nil\n\t\tend\n\n\t\tself.angle, self.isAbove = 0, false\n\t\tif ap.target ~= nil and self.gotoLock == nil then\n\t\t\t\t\t\tself.angle = -math.rad(getTargetAngle())\n\t\tend\n\n\t\t\t\t\t\tif not braking then\n\t\t\ttmp, atmp = self.miniPilot(cD, tmp, atmp)\n\t\tend\n\n\t\tif self.landingMode and landed and not gC.startup then\n\t\t\tself.state = 'LANDED'\n\t\t\treturn\n\t\tend\n\n\t\t\t\tif (self.yawDamp or self.gotoLock == nil) then\n\t\t\tatmp = atmp - ((cD.worldAngularVelocity * 3) - (cD.angularAirFriction * 3))\n\t\tend\n\n\t\t\t\tif self.alternateCM and not (braking or self.landingMode) then\n\t\t\tlocal speed = self.throttle / 3.6 \t\t\tlocal dot = cD.wFwd:dot(cD.angularAirFriction)\n\t\t\tlocal modifiedVelocity = (speed - dot)\n\t\t\tlocal desired = cD.wFwd * modifiedVelocity\n\t\t\ttmp = tmp + ((desired - cD.wVel) * mass * cD.gravVert)\n\t\tend\n\n\t\t\t\tif self.inertialDampening and not isStartup and not landed then\n\t\t\t\t\t\tlocal delta, locV = vec3(), cD.velocity\n\t\t\tlocal chg = false\n\t\t\t\t\t\tif not (inputs.left or inputs.right) then\n\t\t\t\tdelta.x = locV.x\n\t\t\t\tchg = true\n\t\t\tend\n\n\t\t\t\t\t\tif not (braking or inputs.forward or inputs.backward) then\n\t\t\t\t\t\t\t\t\t\t\t\tif (cD.inAtmo and cD.ySpeedKPH > (cD.burnSpeedKph - 50)) then\n\t\t\t\t\tdelta.y = locV.y * 2\n\t\t\t\telseif (gC.rotationDampening and inputs.pitch == 0\n\t\t\t\t\t\tand not (self.mmbThrottle or self.alternateCM or self.state == \"TRAVERSING\")) then\n\t\t\t\t\tdelta.y = locV.y\n\t\t\t\tend\n\t\t\t\tchg = true\n\t\t\tend\n\n\t\t\t\t\t\t\t\t\tif not (self.gotoLock or inputs.up or inputs.down) then\n\t\t\t\t\t\t\t\tif not cD.inAtmo and not self.vertical and cD.gravVert > 9.9\n\t\t\t\t\tand cD.GrndDist and cD.GrndDist >= 0 and cD.GrndDist < 10 then\n\t\t\t\t\tdelta.z = (locV.z * 1.5)\n\t\t\t\telse\n\t\t\t\t\tdelta.z = locV.z * ternary(self.alternateCM, 1, cD.atmoD)\n\t\t\t\tend\n\t\t\t\tchg = true\n\t\t\tend\n\n\t\t\t\t\t\tif chg then\n\t\t\t\tdelta = localToWorld(delta, cD.worldUp, cD.wRight, cD.wFwd)\n\t\t\t\ttmp = tmp - (delta * cD.gravVert * mass)\n\t\t\tend\n\t\tend\n\t\tif not (isStartup or landed or self.landingMode or inputs.down) then\n\t\t\ttmp = tmp - (cD.gravity * mass)\n\t\tend\n\t\ttmp = tmp / mass\n\n\t\t\t\tif self.controlMode ~= unit.getControlMode() then\n\t\t\tself.controlMode = unit.getControlMode()\n\t\t\tif self.controlMode == 0 then\n\t\t\t\tself.resetManeuver()\n\t\t\t\tself.alternateCM = false\n\t\t\t\tself.throttle = self.tempThrottle\n\t\t\telse\n\t\t\t\tself.alternateCM = true\n\t\t\t\tself.tempThrottle = self.throttle\n\t\t\t\tself.throttle = round2(cD.speedKph,0)\n\t\t\tend\n\t\tend\n\t\t\t\t\t\tlocal p1tag = self.priorityTags1\n\t\tlocal p2tag = self.priorityTags2\n\t\tif not self.landingMode and cD.GrndDist and (cD.hasvBoosters or cD.hasHovers)\n\t\t\tand (gC.boostMode == 'all' or gC.boostMode == 'hybrid')\n\t\t\tand cD.GrndDist > 0 and cD.GrndDist < cD.maxHoverDist then\n\t\t\tp1tag = \"brake,airfoil,torque,ground,lateral,longitudinal\"\n\t\t\tp2tag = \"\"\n\t\tend\n\t\tunit.setEngineCommand(\n\t\t\t\"all\",\n\t\t\t{ tmp:unpack() },\n\t\t\t{ atmp:unpack() },\n\t\t\tfalse, \t\t\tfalse, \t\t\tp1tag,\n\t\t\tp2tag,\n\t\t\t\"\"\n\t\t)\n\t\tif isStartup and landed then\n\t\t\tinputs.brakeLock = true\n\t\t\tinputs.brake = 1\n\t\telseif not inputs.brakeLock and abs(cD.zSpeedKPH) < 0.1 then\n\t\t\tinputs.brake = 0\n\t\tend\n\tend\n\n\treturn self\nend\n\nfunction setApTarget(vec)\n\tAutoPilot:setTarget(vec)\nend\n\nfunction gotoTarget(vec, apIsSet, travelAltitude)\n\tif type(vec) ~= 'table' or not vec3.isvector(vec) then return false end\n\tship.resetManeuver() \tif not apIsSet then setApTarget(vec) end\n\tlocal gC, s = globals, ship\n\tgC.altitudeHold = false\n\tgC.rotationDampening = true\n\tinputs.brakeLock = false\n\tinputs.brake = 0\n\ts.travelAltitude = nil\n\tlocal trvAlt = tonumber(travelAltitude)\n\tif trvAlt and trvAlt > 100 and trvAlt <= 10000 then\n\t\ts.travelAltitude = trvAlt\n\t\ts.holdAltitude = trvAlt\n\tend\n\ts.targetVector = (vec - cData.position):normalize()\n\ts.gotoLock = vec\n\treturn true\nend\n\nfunction moveVert(dist)\n\tdist = clamp(dist or 0,-200000,200000)\n\tlocal a = ship.moveWaypointZ(cData, dist)\n\tif gotoTarget(a) then\n\t\tlocal aPos = Vec3ToPosString(a)\n\t\tP(\"Moving to: \" .. tostring(aPos))\n\t\treturn true\n\tend\n\treturn false\nend\n\nfunction shipLandingTask(cD)\n\tif not ship.landingMode then return end\n\tlocal dist = cD.altitude\n\t\tif cD.body then\n\t\tlocal surfAvg = tonumber(cD.body.surfaceAverageAltitude)\n\t\t\t\tif cD.body.name == 'Thades' then\n\t\t\tdist = dist - 13700\n\t\t\t\t\t\tend\n\tend\n\t\tlocal agg = links.antigrav\n\tif agg and agg.isActive() then\n\t\tlocal a = agg.getBaseAltitude()\n\t\tif a < cD.altitude then\n\t\t\tdist = cD.altitude - a\n\t\tend\n\tend\n\n\t\t\tif dist < 0 and cD.altitude == 0 then dist = 1000 end\n\t\tif cD.GrndDist and cD.GrndDist > 0 then\n\t\tdist = cD.GrndDist\n\tend\n\tlocal a = ship.moveWaypointZ(cD, -dist + 0.1)\n\tgotoTarget(a)\n\tship.landingMode = true end\nend)\npackage.preload['Saga:behaviour/ship.lua']=(function()\nfunction getTargetAngularVelocity(finalPitchInput, finalRollInput, finalYawInput)\n\tlocal gC, ap = globals, AutoPilot\n\tlocal cData = cData\n\tlocal finalInput = finalPitchInput * pitchSpeedFactor * cData.wRight\n\t\t+ finalRollInput * rollSpeedFactor * cData.wFwd\n\t\t+ finalYawInput * yawSpeedFactor * cData.worldUp\n\ttargetRoll = 0\n\tlocal horizontalRight = cData.wVert:cross(cData.wFwd):normalize()\n\tlocal horizontalForward = cData.wVert:cross(-cData.wRight):normalize()\n\tif (pitchPID2 == nil) then\n\t\tpitchPID2 = pid.new(0.02, 0, 0.2)\n\t\trollPID2 = pid.new(0.1, 0, 0.1)\n\t\tyawPID2 = pid.new(0.1, 0, 0.1)\n\tend\n\tlocal tav = vec3()\n\tif  cData.speedKph < 100 and (cData.inAtmo or (not cData.body.hasAtmosphere and cData.altitude < cData.body.surfaceMaxAltitude+1000)) and not ap.enabled and ap.userConfig.slowFlat then\n\t\tgC.aimTarget = 'Flat'\n\t\ttav = cData.wVert:cross(cData.worldUp) + finalInput\n\telse\n\t\ttav = finalInput\n\tend\n\n\t\tif cData.wVert:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\n\t\tlocal autoRollRollThreshold = 1.0\n\t\t\t\tif autoRoll == true and cData.currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n\t\t\tlocal targetRollDeg = clamp(0,cData.currentRollDegAbs-30, cData.currentRollDegAbs+30);  \t\t\tif (rollPID == nil) then\n\t\t\t\trollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) \t\t\tend\n\t\t\trollPID:inject(targetRollDeg - cData.currentRollDeg)\n\t\t\tlocal autoRollInput = rollPID:get()\n\n\t\t\ttav = tav + autoRollInput * cData.wFwd\n\t\tend\n\t\tlocal turnAssistRollThreshold = 20.0\n\t\t\t\tif turnAssist and cData.currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n\t\t\tlocal rollToPitchFactor = turnAssistFactor * 0.1 \t\t\tlocal rollToYawFactor = turnAssistFactor * 0.025 \n\t\t\t\t\t\tlocal rescaleRollDegAbs = ((cData.currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n\t\t\tlocal rollVerticalRatio = 0\n\t\t\tif rescaleRollDegAbs < 90 then\n\t\t\t\trollVerticalRatio = rescaleRollDegAbs / 90\n\t\t\telseif rescaleRollDegAbs < 180 then\n\t\t\t\trollVerticalRatio = (180 - rescaleRollDegAbs) / 90\n\t\t\tend\n\n\t\t\trollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n\n\t\t\tlocal turnAssistYawInput = - cData.currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n\t\t\tlocal turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio\n\n\t\t\ttav = tav + turnAssistPitchInput * cData.wRight + turnAssistYawInput * cData.worldUp\n\t\tend\n\tend\n\n\tif ap.enabled or gC.altitudeHold or gC.orbitalHold then\n\t\tlocal speedCheck = utils.map(clamp(cData.constructSpeed,80,150), 80, 150, 0, 1)\n\t\tif ap.enabled and cData.constructSpeed > 80 then\n\t\t\tif not cData.inAtmo or gC.altitudeHold then\n\t\t\t\ttargetRoll = 0\n\t\t\t\t\t\telseif math.abs(getVelocityTargetAngle()) < 2 or math.abs(getVelocityTargetAngle()) > 170 then\n\t\t\t\ttargetRoll = 0\n\t\t\telse\n\t\t\t\ttargetRoll = clamp(getVelocityTargetAngle()*2,-ap.userConfig.maxRoll,ap.userConfig.maxRoll)*speedCheck\n\t\t\tend\n\t\tend\n\t\t\t\t\tend\n\n\tif gC.orbitalHold or gC.apMode == 'Orbit' then\n\t\taimStrength = clamp(aimStrength-0.1, 0.2,0.4)\n\t\tgC.aimTarget = 'Orbit Hold'\n\n\t\tif not gC.inOrbit then\n\t\t\t\t\t\t\t\t\tif cData.altitude < gC.holdAltitude and cData.vertSpeed < 0 and cData.inAtmo then\n\t\t\t\tgC.aimTarget = 'Orbit Atmo Pitch'\n\t\t\t\t\t\t\t\ttav = -horizontalForward:rotate((gC.targetPitch)*constants.deg2rad, horizontalRight):cross(cData.wFwd)\n\t\t\t\tif gC.apMode == 'Orbit' then\n\t\t\t\t\ttargetAntavgularVelocity = ((circleNormal(ap.target)):rotate((gC.targetPitch)*constants.deg2rad, horizontalRight)):cross(cData.wFwd)\n\t\t\t\tend\n\t\t\telseif cData.orbitFocus.orbitAltTarget < (gC.targetOrbitAlt-100) or cData.orbitFocus.orbitAltTarget > (gC.targetOrbitAlt+100) then\n\t\t\t\tgC.aimTarget = 'Orbit Pitch'\n\t\t\t\ttav = -horizontalForward:rotate((orbitHold())*constants.deg2rad, horizontalRight):cross(cData.wFwd)\n\t\t\t\t\t\t\t\tif gC.apMode == 'Orbit' then\n\t\t\t\t\ttav = (circleNormal(ap.target)):rotate((orbitHold())*constants.deg2rad, horizontalRight):cross(cData.wFwd)\n\t\t\t\t\tif  math.abs(getVelocityTargetAngle()) < 30 and math.abs(getVelocityTargetAngle()) > 1 and cData.constructSpeed > 50 then \t\t\t\t\t\tgC.aimTarget = 'Orbit T2'\n\t\t\t\t\t\ttav = ((variousVectors((circleNormal(ap.target))).vecMain)):rotate(((orbitHold())*constants.deg2rad)*1.5, horizontalRight):cross(cData.wFwd)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tgC.aimTarget = 'Orbit Flat'\n\t\t\t\ttav = cData.wVert:cross(cData.worldUp) + cData.wVelDir:cross(-cData.wFwd)\n\t\t\t\tif gC.apMode == 'Orbit' then\n\t\t\t\t\ttav = (circleNormal(ap.target)):cross(cData.wFwd)\n\t\t\t\t\tif  math.abs(getVelocityTargetAngle()) < 30 and math.abs(getVelocityTargetAngle()) > 1 then\n\t\t\t\t\ttav = ((variousVectors((circleNormal(ap.target))).vecMain)):cross(cData.wFwd) + pitchInput2 * cData.wRight\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tif (math.abs(getVelocityTargetAngle()) > 80 or cData.constructSpeed < 10) and gC.apMode == 'Orbit' then\n\t\t\t\ttav = ((circleNormal(ap.target)):project_on_plane(cData.wFwd)):cross(cData.wFwd) + finalInput\n\t\t\t\ttav = tav + cData.wVert:cross(cData.worldUp)\n\t\t\tend\n\t\telse\n\t\t\ttav =  cData.wVelDir:cross(-cData.wFwd) + finalInput\n\t\t\tif gC.apMode == 'Orbit' then\n\t\t\t\ttav = (circleNormal(ap.target)):cross(cData.wFwd)\n\t\t\tend\n\t\tend\n\t\ttav = tav + -horizontalRight:rotate(targetRoll*constants.deg2rad, cData.wFwd):cross(cData.wRight) + finalInput\n\t\ttav = vec3{clamp(tav.x,-aimStrength,aimStrength),clamp(tav.y,-aimStrength,aimStrength),clamp(tav.z,-aimStrength,aimStrength)}\n\tend\n\n\tif gC.altitudeHold then\n\t\tgC.aimTarget = 'Alt Hold'\n\t\ttav = -horizontalForward:rotate((gC.targetPitch)*constants.deg2rad, horizontalRight):cross(cData.wFwd) + finalInput\n\t\ttav = tav + -horizontalRight:rotate(targetRoll*constants.deg2rad, cData.wFwd):cross(cData.wRight)\n\tend\n\n\tif ap.enabled then\n\t\tif gC.apMode == 'agg' then\n\t\t\ttav = (circleNormal(ap.target)):cross(cData.wFwd) + cData.wVert:cross(cData.worldUp)\n\t\tend\n\n\t\tif gC.apMode == 'reEntry' or gC.apMode == 'Space Braking' then\n\t\t\tgC.aimTarget = 'Target'\n\t\t\ttav = ((circleNormal(ap.target))):cross(cData.wFwd) + cData.wVert:cross(cData.worldUp)\n\t\tend\n\n\t\tif gC.apMode == 'Atmo Travel' then\n\t\t\tif math.abs(getTargetAngle()) > 90 then\n\t\t\t\tpitchRotate = 0\n\t\t\telse\n\t\t\t\tpitchRotate = (gC.targetPitch)*constants.deg2rad\n\t\t\tend\n\n\t\t\tif (math.abs(getVelocityTargetAngle()) > 90 and cData.constructSpeed > 50) or cData.constructSpeed < 20 then \t\t\t\tgC.aimTarget = 'TargetFlat'\n\t\t\t\ttav = ((circleNormal(ap.target)):project_on_plane(cData.wFwd)):cross(cData.wFwd)\n\t\t\t\ttav = tav + cData.wVert:cross(cData.worldUp)\n\t\t\telseif  math.abs(getVelocityTargetAngle()) < 30 and math.abs(getVelocityTargetAngle()) > 1 and cData.constructSpeed > 50 then \t\t\t\tgC.aimTarget = 'T2'\n\t\t\t\ttav = ((variousVectors((circleNormal(ap.target))).vecMain)):rotate(math.min(pitchRotate*1.5,90), horizontalRight):cross(cData.wFwd) + pitchInput2 * cData.wRight\n\t\t\telse\n\t\t\t\tgC.aimTarget = 'Pitch Target'\n\t\t\t\ttav = ((circleNormal(ap.target)):rotate(pitchRotate, horizontalRight)):cross(cData.wFwd)\n\t\t\tend\n\n\t\t\ttav = tav + -horizontalRight:rotate(targetRoll*constants.deg2rad, cData.wFwd):cross(cData.wRight)\n\t\tend\n\n\t\tif sameBody and ap.targetLoc == 'surface' then\n\t\t\tif gC.brakeTrigger and gC.lastProjectedDistance < 600 then\n\t\t\t\tgC.aimTarget = 'Brake Landing'\n\t\t\t\ttav = (circleNormal(ap.target)):cross(cData.wFwd)\n\t\t\t\ttav = (tav/3) + vectorToPoint(ap.target):cross(-cData.worldUp)\n\t\t\t\tif (cData.altitude - getAltitude(ap.target)) < 200 or math.abs(getTargetAngle()) > 90 then \t\t\t\t\tgC.aimTarget = 'Flat'\n\t\t\t\t\ttav = (circleNormal(ap.target)):cross(cData.wFwd) + cData.wVert:cross(cData.worldUp)\n\t\t\t\tend\n\t\t\t\tif (cData.altitude - getAltitude(ap.target)) < 100 then\n\t\t\t\t\tap:toggleState(false)\n\t\t\t\t\tap:toggleLandingMode(true)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tif gC.apMode == 'Transfer' or (ap.targetLoc == 'space' and not cData.inAtmo) or (gC.apMode == 'Space Braking' and (cData.body.bodyId ~= ap.targetBody.bodyId or vector.dist(cData.position,ap.targetBody.center) > 200000 )) then\n\t\t\tif math.abs(getSpaceVelocityTargetAngle()) > 60 or (cData.speedKph <= 3000 and ap.targetLoc == 'surface') or (cData.speedKph < 500 and ap.targetLoc == 'space') then\n\t\t\t\tgC.aimTarget = 'Target'\n\t\t\t\ttav = vectorToPoint(ap.target):cross(cData.wFwd)\n\t\t\telse\n\t\t\t\tgC.aimTarget = 'TCross'\n\t\t\t\ttav = variousVectors(vectorToPoint(ap.target)).vecMain:cross(cData.wFwd)\n\t\t\tend\n\t\t\tif cData.inAtmo then\n\t\t\t\ttav = tav + -horizontalRight:rotate(targetRoll*constants.deg2rad, cData.wFwd):cross(cData.wRight)\n\t\t\tend\n\t\tend\n\t  if spcVector ~= 'ninety' then\n\t\ttav = vec3{clamp(tav.x,-aimStrength,aimStrength),clamp(tav.y,-aimStrength,aimStrength),clamp(tav.z,-aimStrength,aimStrength)} + finalInput\n\t  else\n\t\ttav = tav + finalInput\n\t  end\n\tend\n\n\tif gC.stallProtect and cData.constructSpeed > 55 and not gC.brakeTrigger then \t\tgC.aimTarget = 'Stall Protect'\n\t\ttav = -cData.wVelDir:cross(cData.wFwd) + finalInput\n\t\ttav = tav + -horizontalRight:rotate(targetRoll*constants.deg2rad, cData.wFwd):cross(cData.wRight)\n\tend\n\n\tif gC.radialOut then\n\t\ttav = cData.wVert:cross(cData.wFwd)\n\t\ttav = vec3{clamp(tav.x,-aimStrength,aimStrength),clamp(tav.y,-aimStrength,aimStrength),clamp(tav.z,-aimStrength,aimStrength)} + finalInput\n\telseif gC.radialIn then\n\t\ttav = cData.wVert:cross(-cData.wFwd)\n\t\ttav = vec3{clamp(tav.x,-aimStrength,aimStrength),clamp(tav.y,-aimStrength,aimStrength),clamp(tav.z,-aimStrength,aimStrength)} + finalInput\n\telseif gC.cameraAim then\n\t\tif cData.inAtmo then\n\t\t\ttav = vec3(system.getCameraWorldForward()):cross(-cData.wFwd)\n\t\t\ttav = tav + -horizontalRight:rotate(targetRoll*constants.deg2rad, cData.wFwd):cross(cData.wRight)\n\t\t\ttav = vec3{clamp(tav.x,-aimStrength,aimStrength),clamp(tav.y,-aimStrength,aimStrength),clamp(tav.z,-aimStrength,aimStrength)}\n\t\telse\n\t\t\ttav = vec3(system.getCameraWorldForward()):cross(-cData.wFwd)\n\t\t\ttav = vec3{clamp(tav.x,-aimStrength,aimStrength),clamp(tav.y,-aimStrength,aimStrength),clamp(tav.z,-aimStrength,aimStrength)}\n\t\tend\n\tend\n\n\tif gC.followMode then\n\t\ttav = (circleNormal(playerData.playerPosition)):cross(cData.wFwd)\n\t\ttav = tav + -horizontalRight:rotate(targetRoll*constants.deg2rad, cData.wFwd):cross(cData.wRight)\n\tend\n\ttargetAngularVelocity = tav\n\treturn targetAngularVelocity\nend\n\nfunction applyEngineCommands(targetAngularVelocity, angularAcceleration, brkAccel)\n\tlocal gC, aCache, ap = globals, Axis, AutoPilot\n\tlocal keepCollinearity = true \tlocal dontKeepCollinearity = false \tlocal tolerancePercentToSkipOtherPriorities = 1 \n\tNav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\tNav:setEngineForceCommand('brake', brkAccel)\n\n\t\tlocal autoNavigationEngineTags = ''\n\tlocal autoNavigationAcceleration = vec3()\n\tlocal autoNavigationUseBrake = false\n\n\t\tlocal longitudinalSecondaryTags = 'secondary'\n\tlocal longitudinalTertiaryTags = 'tertiary'\n\tlocal longitudinalEngineTags = 'thrust analog longitudinal'\n\tlocal lateralStrafeEngineTags = 'thrust analog lateral'\n\tlocal verticalStrafeEngineTags = 'thrust analog vertical'\n\tlocal verticalAirfoilTags = 'vertical airfoil'\n\tlocal lateralAirfoilTags = 'lateral airfoil'\n\tlocal longitudinalCruiseIsOn = navCom:getAxisCommandType(axisCommandId.longitudinal) == axisCommandType.byTargetSpeed\n\tlocal lateralCruiseIsOn = navCom:getAxisCommandType(axisCommandId.lateral) == axisCommandType.byTargetSpeed\n\tlocal verticalCruiseIsOn = navCom:getAxisCommandType(axisCommandId.vertical) == axisCommandType.byTargetSpeed\n\n\tif longitudinalCruiseIsOn then\n\t\tautoNavigationEngineTags = longitudinalEngineTags\n\t\tautoNavigationAcceleration = autoNavigationAcceleration + navCom:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n\telse\n\t\tif aCache.throttle1Axis ~= 0 then\n\t\t\tnavCom:setThrottleCommand(axisCommandId.longitudinal, aCache.throttle1Axis)\n\t\tend\n\t\tlocal acceleration = navCom:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n\t\tif ((cData.atmoDensity >= 0.1 and gC.advAtmoEngines) or (not cData.inAtmo and gC.advSpaceEngines) or (gC.advSpaceEngines and gC.advAtmoEngines)) and cData.curThrottle > 0 then\n\t\t\tlocal idx = ternary(cData.inAtmo,1,3)\n\t\t\tif gC.boostMode == 'primary' then\n\t\t\t\tNav:setEngineForceCommand(longitudinalSecondaryTags.. ' , ' .. longitudinalTertiaryTags, vec3(), keepCollinearity)\n\t\t\t\tunit.setEngineThrust('primary', gC.maxPrimaryKP[idx]*cData.curThrottle)\n\t\t\telseif gC.boostMode == 'all' then\n\t\t\t\tNav:setEngineForceCommand(longitudinalEngineTags, acceleration, keepCollinearity)\n\t\t\telseif gC.boostMode == 'locked' then\n\t\t\t\tNav:setEngineForceCommand(longitudinalSecondaryTags.. ' , ' .. longitudinalTertiaryTags, acceleration, keepCollinearity)\n\t\t\t\tunit.setEngineThrust('primary', gC.maxPrimaryKP[idx])\n\t\t\telseif gC.boostMode == 'hybrid' then\n\t\t\t\tlocal primThrottle = 0\n\t\t\t\tlocal secThrottle = 0\n\t\t\t\tlocal tertThrottle = 0\n\t\t\t\tlocal targetThrottle2 = 0\n\t\t\t\tlocal modifierThrottleOne = 0\n\t\t\t\tlocal modifierThrottleTwo = 0\n\t\t\t\tlocal modifierThrottleThree = 0\n\n\t\t\t\tif (cData.inAtmo and gC.maxTertiaryKP[1] > 0) or (not cData.inAtmo and gC.maxTertiaryKP[3] > 0) then\n\t\t\t\t\tlocal umap = utils.map\n\t\t\t\t\ttargetThrottle2 = cData.curThrottle*3.9\n\t\t\t\t\tmodifierThrottleOne = (umap(clamp(targetThrottle2,300,330),300,330,0,30))/100\n\t\t\t\t\tmodifierThrottleTwo = (umap(clamp(targetThrottle2,330,360),330,360,0,30))/100\n\t\t\t\t\tmodifierThrottleThree = (umap(clamp(targetThrottle2,360,390),360,390,0,30))/100\n\t\t\t\t\tprimThrottle = ((umap(clamp(targetThrottle2,0,100),0,100,0,70))/100)+modifierThrottleOne\n\t\t\t\t\tsecThrottle  = ((umap(clamp(targetThrottle2,100,200),100,200,0,70))/100)+modifierThrottleTwo\n\t\t\t\t\ttertThrottle = ((umap(clamp(targetThrottle2,200,300),200,300,0,100))/100)+modifierThrottleThree\n\t\t\t\t\telse\n\t\t\t\t\ttargetThrottle2 = cData.curThrottle*2.6\n\t\t\t\t\tmodifierThrottleOne = (umap(clamp(targetThrottle2,200,230),200,230,0,30))/100\n\t\t\t\t\tmodifierThrottleTwo = (umap(clamp(targetThrottle2,230,260),230,260,0,30))/100\n\t\t\t\t\tprimThrottle = ((umap(clamp(targetThrottle2,0,100),0,100,0,70))/100)+modifierThrottleOne\n\t\t\t\t\tsecThrottle = ((umap(clamp(targetThrottle2,100,200),100,200,0,70))/100)+modifierThrottleTwo\n\t\t\t\t\tend\n\t\t\t\t\tunit.setEngineThrust('primary', gC.maxPrimaryKP[idx]*primThrottle)\n\t\t\t\t\tunit.setEngineThrust('secondary', gC.maxSecondaryKP[idx]*secThrottle)\n\t\t\t\t\tunit.setEngineThrust('tertiary', gC.maxTertiaryKP[idx]*tertThrottle)\n\t\t\tend\n\t\telse\n\t\t\tNav:setEngineForceCommand(longitudinalEngineTags, acceleration, keepCollinearity)\n\t\tend\n\tend\n\n\tif lateralCruiseIsOn then\n\t\tif gC.lateralState then\n\t\t\tautoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\n\t\telse\n\t\t\tNav:setEngineForceCommand(lateralStrafeEngineTags, vec3(), dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\n\t\t\tautoNavigationAcceleration = autoNavigationAcceleration + navCom:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n\t\tend\n\telse\n\t\tlocal acceleration = navCom:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n\t\tif not gC.lateralState then\n\t\t\tacceleration = vec3()\n\t\tend\n\t\tNav:setEngineForceCommand(lateralStrafeEngineTags, acceleration, keepCollinearity)\n\t\tif ap.enabled and cData.inAtmo then\n\t\t\tlocal horizontalRight = cData.wVert:cross(cData.wFwd):normalize()\n\t\t\tlocal horizontalAcceleration = vec3()\n\t\t\tlocal vta = getVelocityTargetAngle()\n\t\t\tif vta < 0 then\n\t\t\t\thorizontalAcceleration = -horizontalRight*20\n\t\t\telseif vta > 0 then\n\t\t\t\thorizontalAcceleration = horizontalRight*20\n\t\t\tend\n\t\t\tNav:setEngineForceCommand(lateralAirfoilTags, horizontalAcceleration, keepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\n\t\tend\n\tend\n\n\tif verticalCruiseIsOn then\n\t\tif gC.verticalState or gC.waterState then\n\t\t\tautoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\n\t\telse\n\t\t\tNav:setEngineForceCommand(verticalStrafeEngineTags, vec3(), dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\n\t\tend\n\t\tautoNavigationAcceleration = autoNavigationAcceleration + navCom:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n\telse\n\t\tlocal acceleration = navCom:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n\t\tif not gC.verticalState and not gC.waterState then\n\t\tacceleration = vec3()\n\t\tend\n\t\tNav:setEngineForceCommand(verticalStrafeEngineTags, acceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\n\t\tif (ap.enabled and cData.inAtmo) or (gC.altitudeHold) or (gC.orbitalHold and cData.inAtmo) then\n\t\t\tlocal wVert20 = cData.wVert*20\n\t\t\tif gC.apMode == 'Landing' then\n\t\t\t\tNav:setEngineForceCommand(verticalAirfoilTags, wVert20, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\t\t\telseif (cData.altitude < gC.holdAltitude or cData.vertSpeed < -10) then\n\t\t\t\tNav:setEngineForceCommand(verticalAirfoilTags, -wVert20, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\t\t\telseif (gC.orbitalHold and cData.inAtmo) then\n\t\t\t\tNav:setEngineForceCommand(verticalAirfoilTags, -wVert20, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\t\t\telse\n\t\t\t\tNav:setEngineForceCommand(verticalAirfoilTags, -cData.wVert*5, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\t\t\tend\n\t\tend\n\tend\n\n\t\tif (navCom:getTargetSpeed(axisCommandId.longitudinal) == 0 or \t\t\t\tnavCom:getTargetSpeed(axisCommandId.longitudinal) < (cData.speedKph - 10))\n\tthen\n\t\tautoNavigationUseBrake = true\n\tend\n\n\t\tif (autoNavigationAcceleration:len() > constants.epsilon) then\n\t\tif (inputs.brake ~= 0 or autoNavigationUseBrake or math.abs(cData.wVelDir:dot(cData.wFwd)) < 0.95)  \t\tthen\n\t\t\tautoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n\t\tend\n\t\tnavCom:updateCommandFromActionLoop(axisCommandId.longitudinal, 0)\n\t\tNav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\n\tend\n\n\t\tNav:setBoosterCommand('rocket_engine')\nend\n\nfunction validateParms()\n\tlocal max = math.max\n\tpitchSpeedFactor = max(pitchSpeedFactor, 0.01)\n\tyawSpeedFactor = max(yawSpeedFactor, 0.01)\n\trollSpeedFactor = max(rollSpeedFactor, 0.01)\n\ttorqueFactor = max(torqueFactor, 0.01)\n\tbrakeSpeedFactor = max(brakeSpeedFactor, 0.01)\n\tbrakeFlatFactor = max(brakeFlatFactor, 0.01)\n\tautoRollFactor = max(autoRollFactor, 0.01)\n\tturnAssistFactor = max(turnAssistFactor, 0.01)\nend\n\nfunction applyShipInputs()\n\tlocal ap, aCache, gC = AutoPilot, Axis, globals\n\n\t\tlocal finalPitchInput = inputs.pitch + aCache.pitchAxis + system.getControlDeviceForwardInput()\n\tlocal finalRollInput = inputs.roll + aCache.rollAxis + system.getControlDeviceYawInput()\n\tlocal finalYawInput = inputs.yaw + aCache.yawAxis - system.getControlDeviceLeftRightInput()\n\tlocal finalBrakeInput = inputs.brake + aCache.brakeAxis\n\n\tlocal targetAngularVelocity = getTargetAngularVelocity(finalPitchInput, finalRollInput, finalYawInput)\n\n\tlocal angularAcceleration = torqueFactor * (targetAngularVelocity - cData.worldAngularVelocity)\n\tangularAcceleration = angularAcceleration - cData.angularAirFriction \tlocal brkAccel = -finalBrakeInput * (brakeSpeedFactor * cData.wVel + brakeFlatFactor * cData.wVelDir)\n\tif not gC.rotationDampening then\n\t\tif inputs.pitch == 0 and inputs.yaw == 0 and inputs.roll == 0 then\n\t\t\tangularAcceleration = vec3()\n\t\tend\n\tend\n\tif gC.inOrbit and gC.orbitalHold and not gC.brakeTrigger then\n\t\tlocal brakeSensitivity = clamp(((orbitFocus().orbitAltTarget-gC.targetOrbitAlt)*0.0001)*4,0.01,5)\n\t\tbrkAccel = vec3(clamp(brkAccel.x,-brakeSensitivity,brakeSensitivity), clamp(brkAccel.y,-brakeSensitivity,brakeSensitivity), clamp(brkAccel.z,-brakeSensitivity,brakeSensitivity))\n\tend\n\tif ap.enabled and (brakeCtrl == 12.1 or brakeCtrl == 13.1\n\t\tor ((brakeCtrl == 0.1) and cData.zSpeedKPH > -100))\n\t\tand cData.speedKph < cData.burnSpeedKph-50 then\n\t\t\tlocal brkSens2 = 2\n\t\t\tbrkAccel = vec3(clamp(brkAccel.x,-brkSens2,brkSens2),\n\t\t\t\tclamp(brkAccel.y,-brkSens2,brkSens2),\n\t\t\t\tclamp(brkAccel.z,-brkSens2,brkSens2))\n\tend\n\tif ap.landingMode then\n\t\tbrkAccel = brkAccel * 9\n\telseif gC.altitudeHold then\n\t\tbrkAccel = -inputs.brake * cData.wFwd * ((cData.forwardSpeed + cData.lateralSpeed)*3.6)\n\tend\n\tapplyEngineCommands(targetAngularVelocity, angularAcceleration, brkAccel)\nend\nend)\npackage.preload['Saga:data/aggData.lua']=(function()\nfunction getAggData()\n\tlocal agg = links.antigrav\n\tif agg == nil then\n\t\treturn { aggState = false, aggStrength = 0, aggRate = 0, aggPower = 0,\n\t\t\taggPulsor = 6, aggTarget = 1000, aggAltitude = 1000, aggBubble = false }\n\tend\n\tlocal inBubble = false\n\tlocal curAltitude = cData.altitude\n\tlocal aggAlt = agg.getBaseAltitude()\n\tinBubble = agg.isActive() and curAltitude > aggAlt - 100 and curAltitude < (aggAlt + 100)\n\treturn {\n\t\taggState = agg.isActive(),\n\t\taggStrength = agg.getFieldStrength(),\n\t\taggRate = agg.getCompensationRate(),\n\t\taggPower = agg.getFieldPower(),\n\t\taggPulsor = agg.getPulsorCount(),\n\t\taggTarget = round2(agg.getTargetAltitude(),2),\n\t\taggAltitude = round2(aggAlt,2),\n\t\taggBubble = inBubble\n\t}\nend\nend)\npackage.preload['Saga:data/config.lua']=(function()\nConfig = (\nfunction()\n\tlocal this = {}\n\n\tthis.config = {}\n\tthis.dynamicIndicator = '_' \tthis.defaults = {}\n\tthis.dbDataKey = nil\n\tthis.databank = nil\n\tthis.databanks = nil\n\n\tfunction this:init(databanks, dbDataKey, dbActiveKey)\n\t\tthis.dbDataKey = dbDataKey\n\t\tthis.dbActiveKey = dbActiveKey\n\t\tthis.databanks = databanks\n\t\tlocal selectedDbPriority = 0\n\t\tfor _, databank in ipairs(databanks) do\n\t\t\t\t\t\tif this.databank == nil then this.databank = databank end\n\n\t\t\t\t\t\tlocal keysOnDb = databank.getKeyList()\n\t\t\tif table.contains(this.dbActiveKey, keysOnDb) then\n\t\t\t\tthis.databank = databank\n\t\t\t\tselectedDbPriority = 2\n\t\t\telseif table.contains(this.dbDataKey, keysOnDb) and selectedDbPriority < 2 then\n\t\t\t\tthis.databank = databank\n\t\t\t\tselectedDbPriority = 1\n\t\t\tend\n\t\tend\n\n\t\tthis:cleanNonActives()\n\t\tthis:load()\n\tend\n\n\tfunction this:selectDb(databank)\n\t\tthis:prepareForMigration() \t\tif this.databank ~= nil then\n\t\t\tthis.databank.clearValue(this.dbActiveKey)\n\t\t\tthis:save(false) \t\tend\n\t\tthis.databank = databank\n\t\tthis.databank.setIntValue(this.dbActiveKey, 1)\n\t\tthis:load()\n\t\tthis:migrate() \t\tthis:save() \t\tEventSystem:trigger('ConfigDBChanged')\n\tend\n\n\tfunction this:getValue(key, defaultValue)\n\t\tif key == nil then P('Config:getValue(nil) error') return end\n\t\tif this.config[key] ~= nil then\n\t\t\treturn this.config[key]\n\t\tend\n\t\tif this.defaults[key] ~= nil then\n\t\t\treturn this.defaults[key]\n\t\tend\n\t\treturn defaultValue\n\tend\n\n\tfunction this:getDynamicValue(key, defaultValue)\n\t\treturn this:getValue(this.dynamicIndicator .. key, defaultValue)\n\tend\n\n\tfunction this:setValue(key, value, save)\n\t\tthis:set(key, value, save)\n\tend\n\n\tfunction this:setDynamicValue(key, value, save)\n\t\tthis:set(this.dynamicIndicator .. key, value, save)\n\tend\n\n\tfunction this:set(key, value, save)\n\t\tif save == nil then save = true end \t\tthis.config[key] = value\n\t\tif save then this:save() end\n\t\tEventSystem:trigger('ConfigChange')\n\t\tEventSystem:trigger('ConfigChange' .. key)\n\tend\n\n\tfunction this:save(includeDynamic)\n\t\tif this.databank == nil then return end\n\t\tif includeDynamic == nil then includeDynamic = true end\n\n\t\tlocal configToSave = {}\n\t\tfor key,value in pairs(this.config) do\n\t\t\tif includeDynamic or (key:find(this.dynamicIndicator) == nil) then\n\t\t\t\tconfigToSave[key] = value\n\t\t\tend\n\t\tend\n\t\tlocal serialized = serialize(configToSave)\n\t\tthis.databank.setStringValue(this.dbDataKey, serialized)\n\tend\n\n\tfunction this:load()\n\t\tif this.databank == nil then return end\n\t\tlocal dbStringValue = this.databank.getStringValue(this.dbDataKey)\n\t\tif dbStringValue == '' then return end\n\t\tlocal dbLoad, err = load('return ' .. dbStringValue)\n\t\tif dbLoad == nil then\n\t\t\tP('Error loading config from databank, resetting to default!')\n\t\t\tP(dbStringValue)\n\t\t\tP(err)\n\t\t\tthis.databank.clearValue(this.dbDataKey)\n\t\telse\n\t\t\tthis.config = dbLoad()\n\t\tend\n\tend\n\n\tfunction this:prepareForMigration()\n\t\tlocal migrationArk = {}\n\t\tfor key,value in pairs(this.config) do\n\t\t\tlocal isDynamic = key:find(this.dynamicIndicator) ~= nil\n\t\t\tif isDynamic then\n\t\t\t\tmigrationArk[key] = value\n\t\t\tend\n\t\tend\n\t\tthis.migrationArk = migrationArk\n\tend\n\n\tfunction this:migrate()\n\t\tfor key,value in pairs(this.migrationArk) do\n\t\t\tthis.config[key] = value\n\t\tend\n\tend\n\n\tfunction this:cleanNonActives()\n\t\tfor i, databank in pairs(this.databanks) do\n\t\t\tif databank ~= this.databank then\n\t\t\t\tdatabank.clearValue(this.dbActiveKey)\n\t\t\tend\n\t\tend\n\tend\n\n\t\tfunction this:cleanDb(databank)\n\t\tlocal keysOnDb = databank.getKeyList()\n\t\tfor i, keyOnDb in ipairs(keysOnDb) do\n\t\t\tif keyOnDb ~= this.dbDataKey and keyOnDb ~= this.dbActiveKey then\n\t\t\t\tdatabank.clearValue(keyOnDb)\n\t\t\tend\n\t\tend\n\tend\n\n\treturn this\nend\n)()\nend)\npackage.preload['Saga:data/configDatabankMap.lua']=(function()\nconfigDatabankMap = {\n\tapState = 'ap',\n\tautoAGGAdjust = 'ag',\n\tcurrentTarget = 'cd', \thoverHeight = 'hh',\n\thudScale = 'hs',\n\tlandingMode = 'lm',\n\tmainMenuVisible = 'mv',\n\tmaneuverMode = 'mm',\n\tmaxPitch = 'mp',\n\tmaxRoll = 'mr',\n\tmaxSpaceSpeed = 'ms',\n\tmenuKeyLegend = 'mk',\n\tradarBoxes = 'rb',\n\tradarWidget = 'rw',\n\trouteDatabankName = 'rd',\n\tshieldManage = 'sm',\n\tslowFlat = 'sf',\n\tsoundEnabled = 'se',\n\tspaceCapableOverride = 'sc',\n\tthrottleBurnProtection = 'bp',\n\tunitWidgetVisible = 'uv',\n\tusbDatabankName = 'ud',\n\twingStallAngle = 'ws',\n\tagl = 'al',\n\tcoreWidget = 'cw',\n\tdockMode = 'dm',\n\tdockWidget = 'dw',\n\t\tlandSpeedHigh = 'mls',\n\t\tlandSpeedLow = 'mll',\n\t\ttravelAlt = 'tra',\n\t\tbase = 'bas'\n}\nend)\npackage.preload['Saga:data/coroutine.lua']=(function()\nCoroutine = {\n    func = nil,\n    coroutine = nil\n}\n\nfunction Coroutine:new(func)\n    local o = {}\n    setmetatable(o, self)\n    self.__index = self\n    o.func = func\n    return o\nend\n\nfunction Coroutine:resume()\n    local status = 'dead'\n    if self.coroutine ~= nil then status = coroutine.status(self.coroutine) end\n    if status == 'suspended' then\n        coroutine.resume(self.coroutine)\n    elseif status == 'dead' then\n        self.coroutine = coroutine.create(self.func)\n        coroutine.resume(self.coroutine)\n    end\nend\nend)\npackage.preload['Saga:data/constructData.lua']=(function()\nfunction getConstructData(construct, core)\n\tlocal gC, ap, r2d, abs, atan, sign = globals, AutoPilot, constants.rad2deg, math.abs, math.atan, utils.sign\n\n\tlocal wVel = vec3(construct.getWorldVelocity())\n\tlocal worldForward = vec3(construct.getWorldOrientationForward())\n\tlocal worldUp = vec3(construct.getWorldOrientationUp())\n\tlocal worldRight = vec3(construct.getWorldOrientationRight())\n\tlocal worldVertical = vec3(core.getWorldVertical())\n\tlocal cWP = vec3(construct.getWorldPosition())\n\tlocal currentRollDeg = getRoll(worldVertical, worldForward, worldRight)\n\tlocal wFu, wVu = {worldForward:unpack()}, {worldVertical:unpack()}\n\tlocal localGrav = vec3(library.systemResolution3({worldRight:unpack()}, wFu, {worldUp:unpack()}, wVu))\n\tlocal localVert = vec3(library.systemResolution3({(worldVertical:cross(worldForward)):unpack()}, wFu, wVu, {vec3(0,0,1):unpack()}))\n\t\tif localGrav:len() == 0 then\n\t\tlocalGrav = vec3(0, 0, 1) \tend\n\tif localVert:len() == 0 then\n\t\tlocalVert = vec3(0, 0, 1) \tend\n\n\tlocal _cD = {\n\t\tlocGrav = localGrav,\n\t\tlocVert = localVert,\n\t\tyaw = (atan(-localVert.x, localVert.y) * r2d) % 360,\n\t\tpitch = 180 - (atan(localGrav.y, localGrav.z) * r2d),\n\t\twVert = worldVertical, \t\tworldUp = worldUp, \t\tworldDown = -worldUp, \t\twRight = worldRight, \t\tworldLeft = -worldRight, \t\twFwd = worldForward,\n\t\tworldBack = -worldForward,\n\t\twVel = wVel, \t\twVelDir = wVel:normalize(), \t\twVelAbs = vec3(construct.getWorldAbsoluteVelocity()),\n\t\tworldAcceleration = vec3(construct.getWorldAcceleration()),\n\t\tworldAngularVelocity = vec3(construct.getWorldAngularVelocity()), \t\tworldAngularAcceleration = vec3(construct.getWorldAngularAcceleration()),\n\t\tworldAirFriction = vec3(construct.getWorldAirFrictionAcceleration()),\n\t\tcurThrottle = unit.getThrottle(),\n\t\tacceleration = vec3(construct.getAcceleration()),\n\t\tangularAirFriction = vec3(construct.getWorldAirFrictionAngularAcceleration()), \t\tangularVelocity = vec3(construct.getAngularVelocity()), \t\tvelocity = vec3(construct.getVelocity()),\n\t\tvelocityDir = vec3(construct.getVelocity()):normalize(),\n\t\tvelocityAbs = vec3(construct.getAbsoluteVelocity()),\n\t\tmass = construct.getTotalMass(),\n\t\tconstructSpeed = wVel:len(), \t\tcurrentRollDeg = currentRollDeg, \t\tcurrentRollDegAbs = abs(currentRollDeg), \t\tcurrentRollDegSign = sign(currentRollDeg), \t\tforwardSpeed = wVel:dot(worldForward),\n\t\tlateralSpeed = wVel:dot(-worldRight),\n\t\tvertSpeed = wVel:dot(-worldVertical), \t\tposition = cWP,\n\t\tatmoDensity = round2(unit.getAtmosphereDensity() or 0,2),\n\t\tburnSpeed = construct.getFrictionBurnSpeed(), \t\tmaxSpeed = construct.getMaxSpeed(), \t\tG = core.getGravityIntensity(), \t\tgravity = vec3(core.getWorldGravity()), \t\tgravityDir = vec3(core.getWorldGravity()):normalize(),\n\t\tcurrentBrake = construct.getCurrentBrake(),\n\t\tpvpTimer = construct.getPvPTimer(),\n\t\tpvpZone = construct.isInPvPZone(),\n\t\tbody = findClosestBody(cWP),\n\t\tnearPlanet = unit.getClosestPlanetInfluence() > 0,\n\t\trpy = getRPY(worldForward, worldUp, worldRight, worldVertical, wVel),\n\t\tGrndDist = nil,\n\t\thasvBoosters = links.vBoosterCount > 0,\n\t\thasHovers = links.hoverCount > 0,\n\t\ttelemeter = links.telemeter,\n\t\thasTelemeter = links.telemeter ~= nil and true,\n\t\ttelemDist = nil,\n\t\tmaxHoverDist = nil,\n\t\twarpOn = construct.isWarping(),\n\t\tcFwd = vec3(construct.getForward()),\n\t\tcBack = -vec3(construct.getForward()),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t_cD.currentRollDegAbs = abs(_cD.currentRollDeg)\n\t_cD.currentRollDegSign = sign(_cD.currentRollDeg)\n\n\t_cD.altitude = getAltitude(cWP) \t_cD.hasGndDet = _cD.hasTelemeter or _cD.hasvBoosters or _cD.hasHovers\n\tif _cD.hasGndDet then\n\t\t\t\tif _cD.hasTelemeter then\n\t\t\tlocal ray = _cD.telemeter.raycast()\n\t\t\tif ray.hit then\n\t\t\t\t_cD.telemDist = ray.distance\n\t\t\tend\n\t\tend\n\t\tif _cD.hasHovers and _cD.atmoDensity > 0.1 then\n\t\t\tfor _, hv in ipairs(links.hovers) do\n\t\t\t\tif type(hv.getMaxDistance) == 'function' then \t\t\t\t\t_cD.maxHoverDist = math.max(_cD.maxHoverDist or 0, hv.getMaxDistance())\n\t\t\t\t\tlocal dist = hv.getDistance()\n\t\t\t\t\tif dist >= 0.01 and (not _cD.GrndDist or (dist < _cD.GrndDist)) then\n\t\t\t\t\t\t_cD.GrndDist = dist\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif _cD.hasvBoosters then\n\t\t\tfor _, hv in ipairs(links.vboosters) do\n\t\t\t\tif type(hv.getMaxDistance) == 'function' then\n\t\t\t\t\t_cD.maxHoverDist = math.max(_cD.maxHoverDist or 0, hv.getMaxDistance())\n\t\t\t\t\tlocal dist = hv.getDistance()\n\t\t\t\t\tif dist >= 0.01 and (not _cD.GrndDist or (dist < _cD.GrndDist)) then\n\t\t\t\t\t\t_cD.GrndDist = dist\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t_cD.aboveWater = false\n\tif _cD.GrndDist or _cD.telemDist then\n\t\t\t\t\t\t_cD.aboveWater = (_cD.telemDist and _cD.GrndDist and _cD.telemDist > _cD.GrndDist) or false\n\t\t_cD.GrndDist = max(_cD.telemDist or 0, _cD.GrndDist or 0)\n\t\tif ap.userConfig.agl then\n\t\t\t_cD.GrndDist = _cD.GrndDist - ap.userConfig.agl\n\t\tend\n\t\t_cD.GrndDist = round2(_cD.GrndDist or 0,2)\n\tend\n\t_cD.inAtmo = _cD.atmoDensity > 0\n\n\tlocal tkForward = construct.getMaxThrustAlongAxis(\"all\", { vec3(0,1,0):unpack() })\n\tlocal tkUp = construct.getMaxThrustAlongAxis(\"all\", { vec3(0,0,1):unpack() })\n\tlocal tkUpGrndAtmo = construct.getMaxThrustAlongAxis(\"fueled thrust ground vertical\", { vec3(0,0,1):unpack() })\n\tlocal tkUpGrndSpace = construct.getMaxThrustAlongAxis(\"fueled thrust booster_engine vertical\", { vec3(0,0,1):unpack() })\n\tlocal tkDownAtmo = construct.getMaxThrustAlongAxis(\"fueled thrust atmo vertical\", { vec3(0,0,-1):unpack() })\n\tlocal tkDownSpace = construct.getMaxThrustAlongAxis(\"fueled thrust space_engine vertical\", { vec3(0,0,-1):unpack() })\n\tlocal tkRight = construct.getMaxThrustAlongAxis(\"all\", { vec3(1,0,0):unpack() })\n\tlocal tkOffset = 0\n\tif _cD.atmoDensity < 0.1 then tkOffset = 2 end\n\t_cD.gravMass = _cD.mass * _cD.G\n\t_cD.gravLong = _cD.gravity:dot(worldForward)\n\t_cD.gravLat = _cD.gravity:dot(-worldRight)\n\t_cD.gravVert = _cD.gravity:dot(-worldUp)\n\n\tlocal virtGravEngine = vec3(\n\t\tlibrary.systemResolution3(\n\t\t\t{ _cD.wRight:unpack() },\n\t\t\t{ _cD.wFwd:unpack() },\n\t\t\t{ _cD.worldUp:unpack() },\n\t\t\t{ vec3(_cD.gravity * _cD.mass):unpack() }\n\t\t))\n\t_cD.MaxKinematics = {\n\t\tForward = math.abs(tkForward[1 + tkOffset] + virtGravEngine.y),\n\t\tBackward = math.abs(tkForward[2 + tkOffset] - virtGravEngine.y),\n\t\tUp = math.abs(tkUp[1 + tkOffset] + virtGravEngine.z),\n\t\tUpGroundAtmo = math.abs(tkUpGrndAtmo[1] + virtGravEngine.z),\n\t\tUpGroundSpace = math.abs(tkUpGrndSpace[3] + virtGravEngine.z),\n\t\tDownAtmo = math.abs(tkDownAtmo[2] + virtGravEngine.z),\n\t\tDownSpace = math.abs(tkDownSpace[4] + virtGravEngine.z),\n\t\tDown = math.abs(tkUp[2 + tkOffset] - virtGravEngine.z),\n\t\tRight = math.abs(tkRight[1 + tkOffset] + virtGravEngine.x),\n\t\tLeft = math.abs(tkRight[2 + tkOffset] - virtGravEngine.x)}\n\tif _cD.atmoDensity >= 0.01 and _cD.atmoDensity < 0.1 then\n\t\t_cD.MaxKinematics.Forward = math.abs((tkForward[1] + tkForward[3]) + virtGravEngine.y)\n\tend\n\t\tif gC.maxBrake and gC.maxBrake > 1 then\n\t\t_cD.maxBrake = gC.maxBrake\n\tend\n\tlocal c = 13888.889 \tlocal v = _cD.constructSpeed\n\t_cD.velMag = _cD.wVelAbs:len()\n\t_cD.vtolCapable = _cD.MaxKinematics.Up > (_cD.mass * _cD.G)\n\t_cD.ySpeedKPH = _cD.forwardSpeed*3.6\n\t_cD.xSpeedKPH = _cD.lateralSpeed*3.6\n\t_cD.zSpeedKPH = _cD.vertSpeed*3.6\n\t_cD.burnSpeedKph = _cD.burnSpeed*3.6\n\t_cD.speedKph = v*3.6\n\t_cD.brakes = getBrakes(_cD)\n\t_cD.orbitalParameters = getOrbitalParameters(_cD)\n\t_cD.orbitFocus = getOrbitFocus(_cD)\n\n\t\t_cD.axisAccel = getAccAllAxes(_cD)\n\t_cD.isLanded = tonumber(_cD.GrndDist) ~= nil and _cD.GrndDist < 0.5 and _cD.speedKph < 1\n\t\t\t_cD.atmoD = ternary(_cD.atmoDensity > 0.1, _cD.atmoDensity, 1)\n\n\t\t\t\t\t\t\t\t\t            \n\t_cD.counterGravForce = -(_cD.mass * localGrav:dot(_cD.wFwd))\n\treturn _cD\nend\n\nfunction getAccAllAxes(cD, acc)\n        local fN = cD.wFwd:normalize()\n    local rN = cD.wRight:normalize()\n    local uN = cD.wVert:normalize()\n    \tacc = acc or cD.acceleration\n    local fA = fN * acc:dot(fN)\n    local rA = rN * acc:dot(rN)\n    local uA = uN * acc:dot(-uN)\n        return vec3(fA, rA, uA)\nend\n\n\nfunction getBrakes(cD)\n\tlocal brakeforce = cD.maxBrake or 5000000\n\tif cD.inAtmo then\n\t\tbrakeforce = brakeforce / clamp(cD.constructSpeed/100, 0.1, 1)\n\tend\n\n\tlocal c  = 50000 * 2000 / 3600\n\tlocal c2 = c * c\n\tlocal forwardV = cD.constructSpeed\n\tif forwardV < 0.2 then\n\t\treturn {distance = 0, distKM = 0, distSU = 0, time_s = \"00m:00s\"}\n\tend\n\tlocal bt = (brakeforce*-1) / cD.mass\n\tlocal dist, time = 0, 0\n\tlocal k1 = c * math.asin(forwardV / c)\n\tlocal k2 = c2 * math.cos(k1 / c) / bt\n\tlocal t = (c * math.asin(0 / c) - k1) / bt\n\tlocal d = k2 - c2 * math.cos((bt * t + k1) / c) / bt\n\tdist = dist + d\n\ttime = time + t\n\tlocal min = floor(time / 60)\n\ttime = time - 60 * min\n\tlocal sec =  floor(time + 0.5)\n\tlocal secForm = '00' .. sec\n\tlocal secT = secForm:sub(-2, -1)\n\tlocal minForm = '00' .. min\n\tlocal minT = minForm:sub(-2, -1)\n\tlocal time_s = minT .. ':' .. secT\n\n\tlocal distKM = floor(dist) / 1000 \tlocal distSU = floor(distKM) / 200  \treturn {distance = round2(dist or 0), distKM = distKM, distSU = distSU, time_s = time_s}\nend\n\nfunction getRPY(forward, up, right, vertical, velocity)\n\tlocal yaw = 0\n\t\t\tif velocity:len() >= 20 then\n\t\tyaw = -math.deg(signedRotationAngle(up, velocity, forward))\n\tend\n\treturn {\n\t\troll = getRoll(vertical, forward, right),\n\t\tpitch = getPitch(vertical, forward, right),\n\t\tyaw = yaw,}\nend\n\nfunction getPitch(gravityDirection, forward, right)\n\tlocal horFwd = gravityDirection:cross(right):normalize_inplace()\n\tlocal pitch = acos(clamp(horFwd:dot(-forward), -1, 1))\n\tif horFwd:cross(-forward):dot(right) < 0 then pitch = -pitch end\n\treturn pitch * constants.rad2deg\nend\n\nfunction getRoll(gravityDirection, forward, right)\n\tlocal horRight = gravityDirection:cross(forward):normalize_inplace()\n\tlocal roll = acos(clamp(horRight:dot(right), -1, 1))\n\tif horRight:cross(right):dot(forward) < 0 then roll = -roll end\n\treturn roll * constants.rad2deg\nend\n\nfunction getThrottle(targetSpeed, direction)\n\tlocal speed = cData.speedKph-20\n\tif targetSpeed == nil then\n\t\ttargetSpeed = cData.burnSpeedKph-100\n\tend\n\tif direction ~= nil then\n\t\tspeed = direction*3.6-20\n\tend\n\tlocal speedDiff = (targetSpeed - speed)\n\tlocal minmax = 200\n\treturn clamp((utils.smoothstep(speedDiff, -minmax, minmax) - 0.5) * 2,0,100)\nend\n\nfunction getGravity(body, worldCoordinates)\n\tif body == nil then return 0 end\n\tlocal radial = body.center - vec3(worldCoordinates) \tlocal len2 = radial:len2()\n\treturn (body.GM/len2) * radial/math.sqrt(len2)\nend\n\nfunction setThrottle(axLong, axLat, axVert)\n\tif unit.getControlMode() > 0 then\n\t\tunit.cancelCurrentControlMasterMode()\n\tend\n\tnavCom:setTargetSpeedCommand(axisCommandId.longitudinal, 0)\n\tnavCom:resetCommand(0)\n\tnavCom:resetCommand(1)\n\t\tnavCom:setThrottleCommand(0, axLong or 0)\n\tnavCom:setThrottleCommand(1, axLat or 0)\n\tnavCom:setThrottleCommand(2, axVert or 0)\n\tNav:update()\nend\nend)\npackage.preload['Saga:data/eventSystem.lua']=(function()\nEventSystem = (\nfunction()\n\tlocal this = {}\n\tthis.events = {}\n\tfunction this:register(eventName, func, arg)\n\t\tif this.events[eventName] == nil then this.events[eventName] = {} end\n\t\ttable.insert(this.events[eventName], { func = func, arg = arg })\n\tend\n\tfunction this:trigger(eventName)\n\t\tif this.events[eventName] ~= nil then\n\t\t\tfor _,event in ipairs(this.events[eventName]) do\n\t\t\t\tevent.func(event.arg)\n\t\t\tend\n\t\tend\n\tend\n\treturn this\nend\n)()\nend)\npackage.preload['Saga:data/playerData.lua']=(function()\nfunction getPlayerData()\n    return {\n        playerPosition = vec3(player.getWorldPosition()),\n        playerFrozen = player.isFrozen(),\n        playerSeated = player.isSeated(),\n        playerVelocity = vec3(player.getWorldVelocity())\n    }\nend\nend)\npackage.preload['Saga:data/radar.lua']=(function()\nRadar = (\nfunction()\n\tlocal this = {}\n\n\tthis.contacts = {}\n\tthis.contactsById = {}\n\tthis.coroutines = {}\n    this.radar = nil\n    this.radars = {}\n    this.panelId = nil\n    this.widgetId = nil\n    this.dataId = nil\n\n    function this:init(radars)\n        this.radars = radars\n                                                        this:updateActiveRadar()\n\n        Config.defaults[configDatabankMap.radarBoxes] = true\n        Config.defaults[configDatabankMap.radarWidget] = radarOn\n\n        this.contactCounts = {\n            [ContactTypeENUM.abandoned] = 0,\n            [ContactTypeENUM.dynamic] = 0,\n            [ContactTypeENUM.static] = 0,\n        }\n\n        this.nearestContacts = {\n            [ContactTypeENUM.abandoned] = {},\n            [ContactTypeENUM.dynamic] = {},\n            [ContactTypeENUM.static] = {},\n        }\n\n        this.radarTestList = {}\n        this.radarDynamic = {}\n        this.radarSpace = {}\n        this.radarStatic = {}\n        this.radarAbandoned = {}\n        this.radarFriend = {}\n        this.radarAlien = {}\n\n        EventSystem:register('ConfigDBChanged', this.applyConfig, this)\n        this:applyConfig()\n    end\n\n    function this:applyConfig()\n        this:toggleBoxes(Config:getValue(configDatabankMap.radarBoxes))\n        this:toggleWidget(Config:getValue(configDatabankMap.radarWidget))\n    end\n\n    function this:update()\n        if this.boxesVisible then\n            for i,radarCoroutine in ipairs(this.coroutines) do\n                radarCoroutine:resume()\n            end\n        end\n        this:radarConstructsTest()\n        this:updateActiveRadar()\n    end\n\n    function this:updateActiveRadar()\n        if this.radar ~= nil then\n            if this.radar.getOperationalState() == 1 then return\n            else this.radar = nil end\n        end\n        for i,radar in pairs(this.radars) do\n            if radar.getOperationalState() == 1 and radar ~= this.radar then\n                this.radar = radar\n                                if this.widgetId ~= nil then\n                    system.removeDataFromWidget(this.dataId, this.widgetId)\n                    this.dataId = this.radar.getWidgetDataId()\n                    system.addDataToWidget(this.dataId, this.widgetId)\n                end\n            end\n        end\n    end\n\n    function this:toggleBoxes(state)\n        if state == nil then state = not this.boxesVisible end\n        this.boxesVisible = state\n        Config:setValue(configDatabankMap.radarBoxes, this.boxesVisible)\n    end\n\n    function this:toggleWidget(state)\n        if this.radar == nil then return end\n        if state == nil then state = this.widgetId == nil end\n                if this.widgetId ~= nil then\n            system.destroyWidget(this.widgetId)\n            system.destroyWidgetPanel(this.panelId)\n            this.widgetId = nil\n        end\n                if state then\n            this.panelId = system.createWidgetPanel(\"RADAR\")\n            this.widgetId = system.createWidget(this.panelId, \"radar\")\n            this.dataId = this.radar.getWidgetDataId()\n            system.addDataToWidget(this.dataId, this.widgetId)\n        end\n        Config:setValue(configDatabankMap.radarWidget, state)\n    end\n\n    function this:radarConstructsTest()\n        if this.radar == nil then return end           this.radarTestList = this.radar.getConstructs(0,1,nil,nil,nil,nil,nil)\n        this.radarDynamic = this.radar.getConstructs(0,0,{['constructKind'] = 5})\n        this.radarSpace = this.radar.getConstructs(0,0,{['constructKind'] = 6})\n        this.radarStatic = this.radar.getConstructs(0,0,{['constructKind'] = 4})\n        this.radarAbandoned = this.radar.getConstructs(0,0,{['isAbandoned'] = true})\n        this.radarFriend = this.radar.getConstructs(0,0,{['isMatching'] = true})\n        this.radarAlien = this.radar.getConstructs(0,0,{['constructKind'] = 7})\n    end\n\n        function this:scanForNewContacts()\n        if this.radar == nil then return end\n\n                local contactIds = this.radar.getConstructIds()\n        local newContacts = 0\n        if #contactIds > 2500 then return end\n        for i,contactId in ipairs(contactIds) do\n            if this.contactsById[contactId] == nil then\n                local contact = {}\n                contact.id = contactId\n                contact.name = this.radar.getConstructName(contactId)\n                contact.size = this.radar.getConstructSize(contactId)\n                contact.kind = this.radar.getConstructKind(contactId)\n                contact.distance = this.radar.getConstructDistance(contactId)\n                contact.coreSize = this.radar.getConstructCoreSize(contactId)\n                contact.isAbandoned = this.radar.isConstructAbandoned(contactId) == 1\n                contact.getThreatRateFrom = this.radar.getThreatRateFrom(contactId)\n                this.contacts[#this.contacts+1] = contact\n                this.contactsById[contact.id] = contact\n                newContacts = newContacts + 1\n                if newContacts % 10 == 0 then coroutine.yield() end\n            end\n            if i % 50 == 0 then coroutine.yield() end\n        end\n    end\n    \n\treturn this\nend\n)()\n\nContactTypeENUM = {\n    static = 'static',\n    dynamic = 'dynamic',\n    abandoned = 'abandoned'\n}\nend)\npackage.preload['Saga:data/routeDatabase.lua']=(function()\nRouteDatabase = (\nfunction()\n\tlocal this = {}\n\n\tthis.dbDataKey = nil\n\tthis.databank = nil\n\tthis.databanks = nil\n\tthis.usbDatabank = nil\n\tthis.routes = {}\n\tthis.currentEditId = nil\n\n\tfunction this:init(databanks, dbDataKey)\n\t\tthis.dbDataKey = dbDataKey\n\t\tthis.databanks = databanks\n\n\t\tEventSystem:register('ConfigDBChanged', this.applyConfig, this)\n\t\tthis:applyConfig()\n\tend\n\n\tfunction this:applyConfig()\n\t\t\t\tfor _, databank in pairs(this.databanks) do\n\t\t\tdatabank.name = links.core.getElementNameById(databank.id)\n\t\tend\n\n\t\t\t\tthis.databank = nil\n\t\tlocal selectedDbPriority = 0\n\t\tlocal routeDbName = Config:getValue(configDatabankMap.routeDatabankName)\n\n\t\tif routeDbName ~= nil then \t\t\tfor _, databank in pairs(this.databanks) do\n\t\t\t\tif databank.name == routeDbName then\n\t\t\t\t\tthis.databank = databank\n\t\t\t\t\tselectedDbPriority = 3\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tif this.databank == nil then\n\t\t\tfor _, databank in pairs(this.databanks) do\n\t\t\t\t\t\t\t\tif this.databank == nil then this.databank = databank end\n\t\t\t\t\t\t\t\tlocal keysOnDb = databank.getKeyList()\n\t\t\t\tif table.contains(this.dbDataKey, keysOnDb) and selectedDbPriority <= 1 then\n\t\t\t\t\tthis.databank = databank\n\t\t\t\t\tselectedDbPriority = 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\t\t\tlocal usbDbName = Config:getValue(configDatabankMap.usbDatabankName)\n\t\tif usbDbName ~= nil then \t\t\tfor _, databank in pairs(this.databanks) do\n\t\t\t\tif databank.name == usbDbName then\n\t\t\t\t\tthis.usbDatabank = databank\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tthis:load()\n\tend\n\n\tfunction this:selectDb(databank)\n\t\tthis.databank = databank\n\t\tlocal dbName = links.core.getElementNameById(this.databank.id)\n\t\tConfig:setValue(configDatabankMap.routeDatabankName, dbName)\n\t\tthis:load()\n\tend\n\n\tfunction this:selectUsbDb(databank)\n\t\tthis.usbDatabank = databank\n\t\tlocal dbName = links.core.getElementNameById(this.usbDatabank.id)\n\t\tConfig:setValue(configDatabankMap.usbDatabankName, dbName)\n\tend\n\n\tfunction this:save()\n\t\tEventSystem:trigger('RoutesUpdated')\n\t\tif this.databank == nil then return end\n\t\tthis.databank.setStringValue(this.dbDataKey, serialize(this.routes))\n\tend\n\n\tfunction this:load()\n\t\tif this.databank == nil then return end\n\t\tthis.routes = {}\n\t\tlocal dbStringValue = this.databank.getStringValue(this.dbDataKey)\n\t\tif dbStringValue ~= '' then\n\t\t\tlocal dbLoad, err = load('return ' .. dbStringValue)\n\t\t\tif dbLoad == nil then\n\t\t\t\tP('[E] Error loading routes from databank!')\n\t\t\t\tP(dbStringValue)\n\t\t\t\tP(err)\n\t\t\telse\n\t\t\t\tlocal routesOnDatabank = dbLoad()\n\t\t\t\tif routesOnDatabank ~= nil then\n\t\t\t\t\tthis.routes = routesOnDatabank\n\t\t\t\t\ttable.sort(this.routes, function(a,b) return a.name < b.name end)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tEventSystem:trigger('RoutesUpdated')\n\tend\n\n\tfunction this:beforeRoutesChanged()\n\t\tif this.currentEditId ~= nil then\n\t\t\tthis.shouldFindEdit = true\n\t\t\tthis.routes[this.currentEditId].edit = true\n\t\tend\n\t\tif AutoPilot.currentRouteIndex ~= nil then\n\t\t\tthis.shouldFindActive = true\n\t\t\tthis.routes[AutoPilot.currentRouteIndex].active = true\n\t\tend\n\tend\n\n\tfunction this:routesChanged()\n\t\tlocal foundEdit, foundActive = false, false\n\n\t\ttable.sort(this.routes, function(a,b) return a.name < b.name end)\n\n\t\tfor i,route in ipairs(this.routes) do\n\t\t\t\t\t\tif route.fresh == true then\n\t\t\t\troute.fresh = nil\n\t\t\t\tthis.currentEditId = i\n\t\t\tend\n\t\t\t\t\t\tif route.edit == true then\n\t\t\t\troute.edit = nil\n\t\t\t\tthis.currentEditId = i\n\t\t\t\tfoundEdit = true\n\t\t\tend\n\t\t\t\t\t\tif route.active == true then\n\t\t\t\troute.active = nil\n\t\t\t\tAutoPilot.currentRouteIndex = i\n\t\t\t\tfoundActive = true\n\t\t\t\tConfig:setDynamicValue(configDatabankMap.currentTarget, {AutoPilot.currentRouteIndex,AutoPilot.currentPointIndex,this.databank.name})\n\t\t\tend\n\t\tend\n\n\t\t\t\tif this.shouldFindEdit and not foundEdit then\n\t\t\tthis.currentEditId = nil\n\t\tend\n\t\t\t\tif this.shouldFindActive and not foundActive then\n\t\t\tAutoPilot:onRouteUnloaded()\n\t\tend\n\n\t\tthis.shouldFindEdit = false\n\t\tthis.shouldFindActive = false\n\n\t\tthis:save()\n\tend\n\n\tfunction this:newRoute()\n\t\tlocal route = {\n\t\t\tname = 'Route ' .. (#this.routes + 1),\n\t\t\tpoints = {},\n\t\t\tfresh = true\n\t\t}\n\t\tthis:beforeRoutesChanged()\n\t\ttable.insert(this.routes, route)\n\t\tthis:routesChanged()\n\t\treturn route\n\tend\n\n\tfunction this:addPoint(index, point)\n\t\ttable.insert(this.routes[index].points, point)\n\t\tthis:save()\n\tend\n\n\tfunction this:deleteRoute(index)\n\t\tthis:beforeRoutesChanged()\n\t\ttable.remove(this.routes, index)\n\t\tthis:routesChanged()\n\tend\n\n\tfunction this:deletePoint(routeIndex, pointIndex)\n\t\tif this.routes[routeIndex] == nil then return end\n\t\tif this.routes[routeIndex].points == nil then return end\n\t\tif this.routes[routeIndex].points[pointIndex] == nil then return end\n\t\tif AutoPilot.currentRouteIndex == routeIndex and AutoPilot.currentPointIndex >= pointIndex then\n\t\t\tAutoPilot.currentPointIndex = AutoPilot.currentPointIndex - 1\n\t\tend\n\t\ttable.remove(this.routes[routeIndex].points, pointIndex)\n\t\tthis:save()\n\tend\n\n\tfunction this:renameRoute(index, name)\n\t\tif this.routes[index] == nil then return end\n\t\tthis:beforeRoutesChanged()\n\t\tthis.routes[index].name = name\n\t\tthis:routesChanged()\n\tend\n\n\tfunction this:renamePoint(rtIdx, ptIdx, name)\n\t\tif this.routes[rtIdx] == nil then return end\n\t\tif this.routes[rtIdx].points == nil then return end\n\t\tif this.routes[rtIdx].points[ptIdx] == nil then return end\n\t\tthis.routes[rtIdx].points[ptIdx].name = name\n\t\tthis:save()\n\tend\n\n\tfunction this:movePoint(routeIndex, oldPointIndex, newPointIndex)\n\t\tif this.routes[routeIndex] == nil or this.routes[routeIndex].points == nil then return end\n\t\tlocal pointCount = #this.routes[routeIndex].points\n\t\tlocal point = table.remove(this.routes[routeIndex].points, oldPointIndex)\n\t\tnewPointIndex = clamp(newPointIndex, 1, pointCount)\n\t\ttable.insert(this.routes[routeIndex].points, newPointIndex, point)\n\t\tlocal ap = AutoPilot\n\t\tif ap.currentRouteIndex == routeIndex then\n\t\t\tlocal idx = ap.currentPointIndex\n\t\t\tif idx == oldPointIndex then\n\t\t\t\tap.currentPointIndex = newPointIndex\n\t\t\telseif idx == newPointIndex then\n\t\t\t\tap.currentPointIndex = oldPointIndex\n\t\t\tend\n\t\tend\n\t\tthis:save()\n\t\treturn newPointIndex\n\tend\n\n\tfunction this:getRoutePointCount(rIdx)\n\t\tlocal route = this.routes[rIdx]\n\t\tif route == nil or route.points == nil then return 0 end\n\t\treturn #route.points\n\tend\n\n\tfunction this.getPoint(rIdx, pIdx)\n\t\tlocal route = this.routes[rIdx]\n\t\tif route == nil or route.points == nil then return end\n\t\tlocal pnts = route.points\n\t\tif pnts == nil or pnts[pIdx] == nil then return end\n\t\treturn pnts[pIdx]\n\tend\n\n\tfunction this:getPointCoordinates(rIdx, pIdx)\n\t\tlocal point = this.getPoint(rIdx, pIdx)\n\t\tif point == nil then return nil end\n\t\tlocal sysId, bodyId = 0, 0\n\t\tif tonumber(point.systemId) ~= nil and point.systemId > 0 then\n\t\t\tsysId = point.systemId\n\t\tend\n\t\tif tonumber(point.bodyId) ~= nil and point.bodyId > 0 then\n\t\t\tbodyId = point.bodyId\n\t\tend\n\t\tlocal worldPos = mapPosToWorldPos({\n\t\t\tlatitude\t= point.coordinates.x,\n\t\t\tlongitude\t= point.coordinates.y,\n\t\t\taltitude\t= point.coordinates.z,\n\t\t\tbodyId\t\t= bodyId,\n\t\t\tsystemId\t= sysId\n\t\t})\n\t\treturn worldPos\n\tend\n\n\tfunction this:getPointPosString(rIdx, pIdx)\n\t\tlocal point = this.getPoint(rIdx, pIdx)\n\t\tif point == nil then return nil end\n\t\tlocal sysId, bodyId = 0, 0\n\t\tif tonumber(point.systemId) ~= nil then sysId = point.systemId end\n\t\tif tonumber(point.bodyId) ~= nil then bodyId = point.bodyId end\n\t\tlocal c = point.coordinates\n\t\tlocal pointConcat = table.concat({sysId,bodyId,c.x,c.y,c.z}, ',')\n\t\treturn '::pos{' .. pointConcat .. '}'\n\tend\n\n\tfunction this:getDatabankName()\n\t\treturn ternary(this.databank == nil, nil, this.databank.name)\n\tend\n\n\treturn this\nend\n)()\nend)\npackage.preload['Saga:data/tankData.lua']=(function()\ntankData = {\n\t\t[\"34191163\"] = 130,\n\t[\"590217537\"] = 170,\n\t[\"590217536\"] = 220,\n\t[\"590217543\"] = 290,\n\n\t\t[\"3510956948\"] = 520,\n\t[\"4068567109\"] = 680,\n\t[\"4068567110\"] = 880,\n\t[\"4068567111\"] = 1140,\n\n\t\t[\"103319202\"] = 2080,\n\t[\"801882806\"] = 2700,\n\t[\"801882807\"] = 3510,\n\t[\"801882804\"] = 4560,\n\n\t\t[\"681896062\"] = 16640,\n\t[\"4181605365\"] = 21632,\n\t[\"4181605362\"] = 28120,\n\t[\"4181605363\"] = 36560,\n\n\t\t[\"1663412227\"] = 400,\n\t[\"3126840739\"] = 800,\n\t[\"2477859329\"] = 6400,\n\t[\"4180073139\"] = 50000,\n\n\t\t[\"2723679405\"] = 130,\n\t[\"4270367994\"] = 170,\n\t[\"4270367989\"] = 220,\n\t[\"4270367988\"] = 290,\n\n\t\t[\"3660622849\"] = 520,\n\t[\"3135113517\"] = 680,\n\t[\"3135113516\"] = 880,\n\t[\"3135113519\"] = 1140,\n\n\t\t[\"2717114417\"] = 2080,\n\t[\"3797917193\"] = 2700,\n\t[\"3797917192\"] = 3510,\n\t[\"3797917195\"] = 4560,\n\n\t\t[\"1567224122\"] = 16640,\n\t[\"1298642304\"] = 21632,\n\t[\"1298642305\"] = 28120,\n\t[\"1298642310\"] = 36560,\n\n\t\t[\"xs\"] = 100,\n\t[\"s\"] = 400,\n\t[\"m\"] = 1600,\n\t[\"l\"] = 12800,\n}\n\nfunction initializeTanks()\n\tlocal tankData = tankData\n\tlocal fuelWeightMod = (((100 - (5 * fuelTankOptimization)) / 100)) - 1\n\tlocal contWeightMod = (((100 - (5 * containerOptimization)) / 100)) - 1\n\tfuelWeights = {\n\t\t['atmo'] = (4 - (4 * (math.abs(fuelWeightMod) + math.abs(contWeightMod)))),\n\t\t['space'] = (6 - (6 * (math.abs(fuelWeightMod) + math.abs(contWeightMod)))),\n\t\t['rocket'] = (0.8 - (0.8 * (math.abs(fuelWeightMod) + math.abs(contWeightMod))))\n\t}\n\n\tlocal curTime = system.getArkTime()\n\tlocal isInClass = system.isItemInClass\n\tlocal function GetMaxVolume(itemId, size)\n\t\treturn tankData[itemId .. \"\"] or tankData[size .. \"\"] or 0\n\tend\n\tlocal replacements = {\n\t\t{ \"Optimized\",   \"Opt.\" },\n\t\t{ \"Uncommon\",    \"Unc.\" },\n\t\t{ \"Advanced\",    \"Adv.\" },\n\t\t{ \"Exotic\",      \"Exo.\" },\n\t\t{ \"Atmospheric\", \"Atmo.\" },\n\t}\n\n\tfuels = {\n\t\t['atmo'] = {},\n\t\t['space'] = {},\n\t\t['rocket'] = {}\n\t}\n\n\telemIDs = links.core.getElementIdList()\n\tfor i = 1, #elemIDs, 1 do\n\t\tlocal item = system.getItem(links.core.getElementItemIdById(elemIDs[i]))\n\t\tif isInClass(item.id, \"FuelContainer\") then\n\t\t\telem = {\n\t\t\t\tuid = elemIDs[i],\n\t\t\t\tuMass = item.unitMass,\n\t\t\t\tname = links.core.getElementNameById(elemIDs[i]),\n\t\t\t\tmass = links.core.getElementMassById(elemIDs[i]) - item.unitMass,\n\t\t\t\tpercent = 0,\n\t\t\t\tlastMass = 0,\n\t\t\t\ttimeLeft = 0,\n\t\t\t\tlastTimeLeft = 0,\n\t\t\t\tlastTime = curTime\n\t\t\t}\n\t\t\tif isInClass(item.id, \"AtmoFuelContainer\") then\n\t\t\t\telem.tankType = \"atmo\"\n\t\t\t\telem.maxMass = GetMaxVolume(item.id, item.size) * (1 + (0.2 * atmoTankHandling)) * fuelWeights['atmo']\n\t\t\t\ttable.insert(fuels['atmo'], elem)\n\t\t\telseif isInClass(item.id, \"RocketFuelContainer\") then\n\t\t\t\telem.tankType = \"rocket\"\n\t\t\t\telem.maxMass = GetMaxVolume(item.id, item.size) * (1 + (0.1 * rocketTankHandling)) *\n\t\t\t\tfuelWeights['rocket']\n\t\t\t\ttable.insert(fuels['rocket'], elem)\n\t\t\telseif isInClass(item.id, \"SpaceFuelContainer\") then\n\t\t\t\telem.tankType = \"space\"\n\t\t\t\telem.maxMass = GetMaxVolume(item.id, item.size) * (1 + (0.2 * spaceTankHandling)) * fuelWeights['space']\n\t\t\t\ttable.insert(fuels['space'], elem)\n\t\t\tend\n\t\t\tlocal ri = 1\n\t\t\twhile ri <= #replacements and elem.name:len() > 30 do\n\t\t\t\telem.name = elem.name:gsub(replacements[ri][1], replacements[ri][2])\n\t\t\t\tri = ri + 1\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction updateTanks()\n\tlocal tankData, curTime, ii = tankData, system.getArkTime(), 0\n\tfor key, list in pairs(fuels) do\n\t\tfor _, tank in ipairs(list) do\n\t\t\ttank.name = tank.name\n\t\t\ttank.lastMass = tank.mass\n\t\t\ttank.mass = links.core.getElementMassById(tank.uid) - tank.uMass\n\t\t\tif tank.mass ~= tank.lastMass then\n\t\t\t\ttank.percent = utils.round((tank.mass / tank.maxMass) * 100, 0.1)\n\t\t\t\ttank.lastTimeLeft = tank.timeLeft\n\t\t\t\ttank.timeLeft = math.floor(tank.mass / ((tank.lastMass - tank.mass) / (curTime - tank.lastTime)))\n\t\t\t\ttank.lastTime = curTime\n\t\t\tend\n\t\t\tii = ii + 1\n\t\t\tif ii > 5 then\n\t\t\t\tcoroutine.yield()\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction updateTanksCo()\n\tlocal cont = coroutine.status(updTankCo)\n\tif cont == \"dead\" then\n\t\tupdTankCo = coroutine.create(updateTanks)\n\tend\n\tcoroutine.resume(updTankCo)\nend\n\nupdTankCo = coroutine.create(updateTanks)\nend)\npackage.preload['Saga:data/warpData.lua']=(function()\nfunction getWarpData()\n\tif links.warpdrive == nil then\n\t\treturn { status = 'Not Ready', warpDistance = 0,warpDestination = 'No Destination', warpCells = 0, warpCellsNeeded = 0 }\n\tend\n\tlocal status = links.warpdrive.getStatus()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlocal noDest = 'No destination set'\n\tif status == 15 then\n\t\tstatus = 'Ready'\n\telseif status == 11 then\n\t\tstatus = noDest\n\telse\n\t\tstatus = 'Not ready'\n\tend\n\tlocal warpDistance = links.warpdrive.getDistance()\n\tlocal warpDestination = links.warpdrive.getDestinationName()\n\tlocal warpCellsNeeded = links.warpdrive.getRequiredWarpCells()\n\tif status == noDest then\n\t\twarpDestination = 'No destination'\n\t\twarpCellsNeeded =  0\n\tend\n\tlocal warpCells = links.warpdrive.getAvailableWarpCells()\n\treturn {\n\t\tstatus = status,\n\t\twarpDistance = warpDistance,\n\t\twarpDestination = warpDestination,\n\t\twarpCells = warpCells,\n\t\twarpCellsNeeded = warpCellsNeeded\n\t}\nend\nend)\npackage.preload['Saga:helpers/common.lua']=(function()\nfunction deserialize(s) local f=load('t='..s) if f then f() end return t end\n\nfunction isWithinTolerance(value, target, tolerance)\n\treturn math.abs(value - target) <= tolerance\nend\n\nfunction RoundAlt(altitude, distance)\n\tlocal newAltitude = altitude + distance\n\tif distance > 0 then\n\t\tnewAltitude = math.ceil(newAltitude / 10) * 10  \telse\n\t\tnewAltitude = math.floor(newAltitude / 10) * 10 \tend\n\treturn newAltitude\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getDampener(ftype, x, range)\n\t\tif tonumber(range) == nil or range < 0.01 then return 0.001 end\n\tif tonumber(x) == nil or x > range then x = range end\n\tif x < 0 then x = 0.01 end\n\n\t\tlocal res, nX = 1, x / range\n\t\tx = math.max(0, math.min(1, nX))\n\tif ftype == 'L' then \t\tres = 1 - math.log(x + 1) / math.log(range + 1)\n\telseif ftype == 'P' then \t\tres = 1 - (x * x)\n\telseif ftype == 'P2' then \t\tres = 1 - (x / range)^2\n\telseif ftype == 'Q' then \t\tres = 1 - (x / range)^2\n\telseif ftype == 'E' then \t\tres = 1 - 2^(-x / range)\n\telseif ftype == 'S' then \t\tres = 1 / (1 + math.exp(-x) * (range - x) / range)\n\tend\n\treturn res\nend\n\nfunction calculateLandingScaleOrg(gDist, ftype, range)\n\tlocal x = math.abs(tonumber(gDist) or 100)\n\tlocal scale = getDampener(ftype, x, range or 100)\n\treturn clamp(scale, 0.1, 0.99)\nend\n\n\n\nlocal function AxisLimiterEx(cD, axis, atmoLimit, distance)\n\tif not cD then inputs.brakeLock = true; return false end\n\taxis = axis or \"worldDown\"\n\tatmoLimit = tonumber(atmoLimit) or 1000\n\tdistance = tonumber(distance) or 1\n\tif not vec3.isvector(cD[axis]) then P'Invalid axis' return false end\n\n\tlocal min, abs = math.min, math.abs\n\tlocal wAxis, ap, dampener, gC = cD[axis], AutoPilot, 1, globals\n\tlocal isVertical = axis == \"worldDown\" or axis == \"worldUp\"\n\tlocal isLongitudinal = axis == \"cFwd\" or axis == \"cBack\"\n\tif not (isVertical or isLongitudinal) then return false end\n\n\t\tlocal accel = cD.acceleration:dot(wAxis)\n\tlocal currSpeed = isVertical and cD.velocity.z or cD.velocity.y\n\n\tlocal axMax = 1080\n\tif cD.inAtmo then\n\t\t\t\tif vertical and cD.altitude > atmoLimit then\n\t\t\taxMax = ap.userConfig.landSpeedHigh\n\t\telseif axis == \"worldUp\" then\n\t\t\taxMax = ap.userConfig.landSpeedLow\n\t\tend\n\telseif isVertical and cD.altitude > 90000 then\n\t\taxMax = ap.userConfig.landSpeedLow*0.5\n\tend\n\t\taxMax = axMax / 3.6\n\n\t\tlocal targetSpeed, maxSpeed, absDist = 0, 0, abs(distance)\n\n\tmaxSpeed, brkDist = kinematics.computeBrakingDistance(\n\t\t\tisVertical and cD.vertSpeed or cD.forwardSpeed,\n\t\t\tdistance, cD.maxBrake or 0, wAxis)\n\tmaxSpeed = maxSpeed or axMax \n\t\tif absDist <= 50 then\n\t\tdampener = calculateLandingScaleOrg(absDist, \"S\", 50) * (axis == 'worldUp' and 0.90 or 1) * (axis == 'cFwd' and 0.1 or 1)\n\telseif absDist <= 200 then\n\t\tdampener = calculateLandingScaleOrg(absDist, \"S\", 200) * (axis == 'cFwd' and 0.33 or 1)\n\telseif absDist <= 500 then\n\t\tdampener = calculateLandingScaleOrg(absDist, \"S\", 500) * (axis == 'cFwd' and 0.66 or 1)\n\tend\n\n\t\tif cD.isLanded and ship.takeoff then\n\t\ttargetSpeed = 20 / 3.6\n\telse\n\t\t\t\ttargetSpeed = axMax\n\t\tif isVertical then\n\t\t\ttargetSpeed = min(maxSpeed/3, axMax)\n\t\tend\n\tend\n\t\ttargetSpeed = targetSpeed * dampener\n\t\tif not cD.inAtmo and ship.landingMode then\n\t\ttargetSpeed = targetSpeed * 0.75\n\tend\n\tif brkDist >= distance then\n\t\ttargetSpeed = targetSpeed * 0.33\n\tend\n\n\t\tlocal diffAccel, diffV = 0, 0\n\tif targetSpeed < 0 and currSpeed ~= targetSpeed then\n\t\tdiffV = currSpeed - targetSpeed\n\telse\n\t\tdiffV = targetSpeed - currSpeed\n\tend\n\t\tif axis == \"worldUp\" or axis == \"worldDown\" then\n\t\tif axis == \"worldUp\" then\n\t\t\t\t\t\tdiffV = diffV + accel * system.getActionUpdateDeltaTime()\n\t\tend\n\t\twAxis = vec3(0,0, axis == \"worldUp\" and 1 or -1)\n\tend\n\tdiffAccel = diffV / cD.mass\n    local thrustVector = diffAccel * wAxis * cD.mass\n\n\treturn thrustVector\nend\n\nfunction AxisLimiter(cD, axis, atmoLimit, distance)\n\tlocal success, result = pcall(AxisLimiterEx, cD, axis, atmoLimit, distance)\n\tif not success or not result then\n\t\tP(\"[E] Error in AxisLimiter!\")\n\t\treturn false\n\tend\n\treturn result\nend\n\n\nfunction Vec3ToPosString(v3)\n\tif type(v3) ~= \"table\" then return \"\" end\n\tlocal sf = string.format\n\treturn '::pos{0,0,' ..\n\t\tsf(\"%.4f\",(v3.x or 0))..','..\n\t\tsf(\"%.4f\",(v3.y or 0))..','..\n\t\tsf(\"%.4f\",(v3.z or 0))..'}'\nend\n\nfunction ternary(cond, T, F)\n\tif cond then return T else return F end\nend\n\nfunction localToWorld(pos, up, right, forward)\n\tlocal relX = pos.x * right.x + pos.y * forward.x + pos.z * up.x\n\tlocal relY = pos.x * right.y + pos.y * forward.y + pos.z * up.y\n\tlocal relZ = pos.x * right.z + pos.y * forward.z + pos.z * up.z\n\treturn vec3(relX, relY, relZ)\nend\n\n\n\n\n\n\n\nfunction getTravelDistance(cPos, target, body)\n\tlocal msqrt, masin = math.sqrt, math.asin\n\n\t\tif not body or not body.radius then\n\t\tlocal dx = cPos.x - target.x\n\t\tlocal dy = cPos.y - target.y\n\t\treturn msqrt(dx*dx + dy*dy) \tend\n\n\tlocal r = body.radius + cPos.z \tlocal dx = cPos.x - target.x\n\tlocal dy = cPos.y - target.y\n\tlocal horDist = msqrt(dx*dx + dy*dy)\n\t\tif horDist < 0.01 then\n\t\treturn 0\n\tend\n\n\t\t\tlocal theta = 2 * masin(horDist / (2 * r))\n\n\t\treturn r * theta\nend\n\nfunction isDirectlyAbove(vec1, vec2, margin)\n\tif tonumber(margin) == nil then\n\t\tmargin = 0.1\n\tend\n\t\tlocal dx = vec1.x - vec2.x\n\tlocal dy = vec1.y - vec2.y\n\tlocal dist = dx*dx + dy*dy\n\n\t\treturn dist <= margin*margin and vec1.z > vec2.z\nend\n\nfunction addDbgVal(t, val, clear)\n\tlocal gC = globals\n\tif not gC.debug then return end\n\tif clear then gC.dbgTxt = '' end\n\tlocal out = '<br>'..(t or '')..': '..ternary(tonumber(val) == nil, tostring(val), tonumber(val))\n\tgC.dbgTxt = gC.dbgTxt..out\n\treturn val\nend\n\nfunction boldSpan(text)\n\treturn '<span style=\"font-weight:bold\">'..text..'</span>'\nend\n\nfunction colorSpan(color, text)\n\treturn '<span style=\"color:'..color..'\">'..text..'</span>'\nend\n\nfunction colIfTrue(bVal, color)\n\tlocal out = tostring(bVal)\n\treturn ternary(bVal, colorSpan(color or 'springgreen',out), out)\nend\nfunction getDiv(className, txt, color, fontSize)\n\tcolor = color or \"ivory\"\n\tfontSize = fontSize or 1.7\n\treturn \"<div class=\\\"\"..className..\"\\\" style=\\\"font-size:\"..tostring(fontSize)..\"vh;color:\"..color..\";text-align:center;text-shadow:0.2vh 0.2vh 1vh black\\\">\"..(txt or '')..\"</div>\"\nend\nfunction getAPDiv(txt, color)\n\treturn getDiv('apAlert',txt,color,1.5)\nend\nfunction getBrakeDiv(txt)\n\treturn getDiv('brakeAlert',txt,'orangered')\nend\nfunction getTDiv(className, trw, trh, inner)\n\treturn \"<div class=\\\"\"..className..\"\\\" style=\\\"transform:translate(\"..trw..\"vw,\"..trh..\"vh)\\\">\"..(inner or '')..\"</div>\"\nend\nfunction getTDivP(className, pnt, inner)\n\treturn getTDiv(className, pnt[1]*100, pnt[2]*100, inner)\nend\n\n\nfunction printDistance(meters, larger)\n\tif tonumber(meters) == nil then return 'NaN' end\n\tlocal absM = math.abs(meters)\n\tif absM < ternary(larger, 10000, 1000) then\n\t\treturn round2(meters,1)..' m'\n\telseif absM < 200000 then\n\t\tlocal km = meters / 1000\n\t\treturn round2(km, ternary(km > 10,1,2))..' km'\n\tend\n\tlocal su = meters / 200000\n\treturn round2(su, ternary(su > 10,1,2))..' su'\nend\n\nfunction thousands(a)\n\tlocal formatted = tostring(a)\n\tif a == nil then return a end\n\twhile true do\n\t\tformatted, k = string.gsub(formatted, \"^(-?%d+)(%d%d%d)\", '%1 %2')\n\t\tif (k==0) then\n\t\t\tbreak\n\t\tend\n\tend\n\treturn formatted\nend\n\nfunction split(str, pat)\n\tif str == nil then return str end\n\tlocal t = {}  \tlocal fpat = \"(.-)\" .. pat\n\tlocal last_end = 1\n\tlocal s, e, cap = str:find(fpat, 1)\n\twhile s do\n\t\tif s ~= 1 or cap ~= \"\" then\n\t\t\ttable.insert(t, cap)\n\t\tend\n\t\tlast_end = e+1\n\t\ts, e, cap = str:find(fpat, last_end)\n\tend\n\tif last_end <= #str then\n\t\tcap = str:sub(last_end)\n\t\ttable.insert(t, cap)\n\tend\n\treturn t\nend\n\n\nfunction formatTimeString(seconds)\n\tif type(seconds) ~= 'number' then return seconds end\n\tlocal days = math.floor(seconds / 86400)\n\tlocal hours = math.floor(seconds / 60 / 60 % 24)\n\tlocal minutes = math.floor(seconds / 60 % 60)\n\tlocal seconds = math.floor(seconds % 60)\n\tif seconds < 0 or hours < 0 or minutes < 0 then\n\t\treturn \"0s\"\n\tend\n\tif days > 0 then\n\t\treturn days .. \"d \" .. hours ..\"h\"\n\telseif hours > 0 then\n\t\treturn hours .. \"h \" .. minutes .. \"m\"\n\telseif minutes > 0 then\n\t\treturn minutes .. \"m \" .. seconds .. \"s\"\n\telse\n\t\treturn seconds .. \"s\"\n\tend\nend\nend)\npackage.preload['Saga:helpers/solar_system.lua']=(function()\nlocal sin, cos, acos, atan, pi, sqrt, huge, uround =\nmath.sin, math.cos, math.acos, math.atan, math.pi, math.sqrt, math.huge, utils.round\n\n\nfunction findClosestBody(coordinates)\n\tlocal minDistance = huge\n\tlocal closestBody = nil\n\tfor _,planet in pairs(atlas[systemId]) do\n\t\tlocal distance = vector.dist(coordinates, planet.center)\n\t\tif distance < minDistance then\n\t\t\tminDistance = distance\n\t\t\tclosestBody = planet\n\t\tend\n\tend\n\treturn closestBody, minDistance\nend\n\nfunction worldToLocal(vec)\n\tif not vec3.isvector(vec) then return nil end\n\tlocal cD = cData\n\treturn vec3(\n\t\t\tlibrary.systemResolution3(\n\t\t\t{cD.wRight:unpack()},\n\t\t\t{cD.wFwd:unpack()},\n\t\t\t{cD.worldUp:unpack()},\n\t\t\t{vec:unpack()}\n\t\t))\nend\n\nfunction parsePosString(posString)\n\tlocal num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n\tlocal systemId, bodyId, latitude, longitude, altitude =\n\t\tstring.match(posString, '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}')\n\tlocal tN = tonumber\n\tsystemId\t= tN(systemId)\n\tbodyId\t\t= tN(bodyId)\n\tlatitude\t= tN(latitude)\n\tlongitude\t= tN(longitude)\n\taltitude\t= tN(altitude)\n\treturn {\n\t\tlatitude\t= latitude,\n\t\tlongitude   = longitude,\n\t\taltitude\t= altitude,\n\t\tbodyId\t\t= bodyId,\n\t\tsystemId\t= systemId\n\t}\nend\n\nfunction convertToWorldCoordinates(pos)\n\tlocal mapPosition = parsePosString(pos)\n\treturn mapPosToWorldPos(mapPosition)\nend\n\nfunction mapPosToWorldPos(mapPosition)\n\tif mapPosition.altitude == nil then return nil end\n\tif mapPosition.bodyId == nil or mapPosition.bodyId == 0 then \t\treturn vec3(mapPosition.latitude,\n\t\t\t\t\tmapPosition.longitude,\n\t\t\t\t\tmapPosition.altitude)\n\tend\n\tlocal lat = constants.deg2rad*clamp(mapPosition.latitude, -90, 90)\n\tlocal lon = constants.deg2rad*(mapPosition.longitude % 360)\n\tlocal xproj = cos(lat)\n\tlocal planet = atlas[mapPosition.systemId][mapPosition.bodyId]\n\treturn vec3(planet.center) + (planet.radius + mapPosition.altitude) *\n\t\t   vec3(xproj*cos(lon), xproj*sin(lon), sin(lat))\nend\n\nfunction bodyPosFromWorldPos(body, position)\n\t\t\tlocal offset = vec3(position) - vec3(body.center)\n\tlocal oNormalized = offset:normalize()\n\treturn {\n\t\tsystemId = body.systemId,\n\t\tbodyId = body.bodyId,\n\t\tlatitude = 90 - (acos(oNormalized.z) * 180 / pi),\n\t\tlongitude = atan(oNormalized.y, oNormalized.x) / pi * 180,\n\t\taltitude = offset:len() - body.radius\n\t}\nend\n\nfunction worldToMapStr(wPos)\n\treturn mapPos2String(worldToMapPos(wPos))\nend\n\nfunction mapPosToVec3(v)\n\tif type(v) == 'table' and v.latitude then\n\t\treturn vec3(v.latitude, v.longitude, v.altitude)\n\tend\n\treturn nil\nend\n\nfunction worldToMapPos(v)\n\tlocal body = findClosestBody(v)\n\tif not body or not body.center or not body.radius then\n\t\treturn { systemId = 0, bodyId = 0, latitude = v.x, longitude = v.y, altitude = v.z }\n\tend\n\treturn bodyPosFromWorldPos(body, v)\nend\n\nfunction mapPos2String(mPos)\n\tlocal sf = string.format\n\tif type(mPos) ~= \"table\" then return \"\" end\n\treturn '::pos{' .. (mPos.systemId or 0).. ',' .. (mPos.bodyId or 0) .. ',' ..\n\t\t\tsf(\"%.4f\",(mPos.latitude or 0)) .. ',' ..\n\t\t\tsf(\"%.4f\",(mPos.longitude or 0)) ..  ',' ..\n\t\t\tsf(\"%.4f\",(mPos.altitude or 0)) .. '}'\nend\n\nfunction initialiseAtlas()\n\tfor _,systemData in pairs(atlas) do\n\t\tfor bodyId,planet in pairs(systemData) do\n\t\t\tplanet.bodyId = bodyId\n\t\t\tplanet.name = planet['name'][1]\n\t\t\tplanet.type = planet['type'][1]\n\t\t\tplanet.atmoRadius = planet['atmosphereRadius']\n\t\t\tplanet.center = vec3(planet['center'])\n\t\t\tplanet.atmoAltitude = 0\n\t\t\tif planet.hasAtmosphere then\n\t\t\t\tplanet.atmoAltitude = planet.atmoRadius - planet.radius\n\t\t\tend\n\t\tend\n\tend\n\tfor system,syData in pairs(atlas) do\n\t\tfor bodyId,p in pairs(syData) do\n\t\t\tif p.satellites ~= nil then\n\t\t\t\tfor _,satId in pairs(p.satellites) do\n\t\t\t\t\tatlas[system][satId].parentBodyId = bodyId\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction castIntersections()\n\tif cData.atmoDensity > 0.1 then return nil,nil,nil end\n\tlocal origin = cData.position\n\tlocal dir = cData.wVelDir\n\tlocal a = atlas[systemId]\n\tfor _,p in pairs(a) do\n\t\tlocal size = 0\n\t\tif p.hasAtmosphere then\n\t\t\tsize = p.atmoRadius*1.2\n\t\telse\n\t\t\tsize = p.radius*1.4\n\t\tend\n\t\tlocal c_oV3 = p.center - origin\n\t\tlocal dot = c_oV3:dot(dir)\n\t\tlocal desc = dot ^ 2 - (c_oV3:len2() - size ^ 2)\n\t\tif desc >= 0 then\n\t\t\tlocal root = sqrt(desc)\n\t\t\tlocal farSide = dot + root\n\t\t\tlocal nearSide = dot - root\n\t\t\tif nearSide > 0 then\n\t\t\t\treturn p, farSide, nearSide\n\t\t\telseif farSide > 0 then\n\t\t\t\treturn p, farSide, nil\n\t\t\tend\n\t\tend\n\tend\n\treturn nil, nil, nil\nend\n\nfunction checkLOS(vector)\n\tlocal worldPos = cData.position\n\tlocal body = findClosestBody(worldPos)\n\tlocal size = 0\n\tif body == nil then return nil, nil end\n\tif body.hasAtmosphere then\n\t\tsize = body.atmoRadius*1.05\n\telse\n\t\tsize = body.radius*1.2\n\tend\n\tlocal intersectBody, farSide, nearSide = castIntersections(worldPos, vector, size) \tlocal atmoDistance = farSide\n\tif nearSide ~= nil and farSide ~= nil then\n\t\tatmoDistance = min(nearSide,farSide)\n\tend\n\tif atmoDistance ~= nil then\n\t\treturn intersectBody, atmoDistance\n\tend\n\treturn nil, nil\nend\n\nfunction getAltitude(coords)\n\tlocal dist = 0\n\tif coords == nil then\n\t\tdist = links.core.getAltitude()\n\t\tif dist == 0 then\n            local b = cData.body\n            if b == nil then return 0 end\n\t\t\tcoords = cData.position\n            dist = vector.dist(vec3(b.center), coords) - b.radius\n\t\tend\n\telse\n\t\tcoord = vec3(coords)\n\t\tlocal body = findClosestBody(coords)\n\t\tif body == nil then return 0 end\n\t\tdist = vector.dist(vec3(body.center), coords) - body.radius\n\tend\n\treturn round2(dist,2)\nend\n\nfunction getOrbitalParameters(cData)\n\tlocal body = findClosestBody(cData.position)\n\tif body == nil then return {} end\n\tlocal pos = cData.position\n\tlocal v = cData.wVel\n\tlocal r = pos - body.center\n\tlocal v2 = v:len2()\n\tlocal d = r:len()\n\tlocal mu = body.GM\n\tlocal e = ((v2 - mu / d) * r - r:dot(v) * v) / mu\n\tlocal a = mu / (2 * mu / d - v2)\n\tlocal ecc = e:len()\n\tlocal dir = e:normalize()\n\tlocal pd = a * (1 - ecc)\n\tlocal ad = a * (1 + ecc)\n\tlocal per = pd * dir + body.center\n\tlocal apo = ecc <= 1 and -ad * dir + body.center or nil\n\tlocal trm = sqrt(a * mu * (1 - ecc * ecc))\n\tlocal Period = apo and 2 * pi * sqrt(a ^ 3 / mu)\n\t\tlocal trueAnomaly = acos((e:dot(r)) / (ecc * d))\n\tif r:dot(v) < 0 then\n\t\ttrueAnomaly = -(trueAnomaly - 2 * pi)\n\tend\n\t\tlocal EccentricAnomaly = acos((cos(trueAnomaly) + ecc) / (1 + ecc * cos(trueAnomaly)))\n\t\t\tlocal timeTau = EccentricAnomaly\n\tif timeTau < 0 then\n\t\ttimeTau = timeTau + 2 * pi\n\tend\n\t\t\tlocal MeanAnomaly = timeTau - ecc * sin(timeTau)\n\tlocal TimeSincePeriapsis = 0\n\tlocal TimeToPeriapsis = 0\n\tlocal TimeToApoapsis = 0\n\tif Period ~= nil then\n\t\tTimeSincePeriapsis = MeanAnomaly / (2 * pi / Period)\n\t\t\t\t\n\t\tTimeToPeriapsis = Period - TimeSincePeriapsis\n\t\tTimeToApoapsis = TimeToPeriapsis + Period / 2\n\t\tif trueAnomaly - pi > 0 then \t\t\tTimeToPeriapsis = TimeSincePeriapsis\n\t\t\tTimeToApoapsis = TimeToPeriapsis + Period / 2\n\t\tend\n\t\tif TimeToApoapsis > Period then\n\t\t\tTimeToApoapsis = TimeToApoapsis - Period\n\t\tend\n\tend\n\treturn {\n\t\tperiapsis = {\n\t\t\tposition = per,\n\t\t\tspeed = trm / pd,\n\t\t\tcircularOrbitSpeed = uround(sqrt(mu / pd)),\n\t\t\taltitude = uround(pd - body.radius)\n\t\t},\n\t\tapoapsis = {\n\t\t\tposition = apo,\n\t\t\tspeed = trm / ad,\n\t\t\tcircularOrbitSpeed = uround(sqrt(mu / ad)),\n\t\t\taltitude = uround(ad - body.radius)\n\t\t},\n\t\tcurrentVelocity = v,\n\t\tcurrentPosition = pos,\n\t\teccentricity = ecc,\n\t\tperiod = Period,\n\t\teccentricAnomaly = EccentricAnomaly,\n\t\tmeanAnomaly = MeanAnomaly,\n\t\ttimeToPeriapsis = uround(TimeToPeriapsis),\n\t\ttimeToApoapsis = uround(TimeToApoapsis),\n\t\ttrueAnomaly = trueAnomaly\n\t}\nend\n\nfunction getOrbitalSpeed(altitude, planet)\n\t\t\t\t\tlocal distance = altitude + planet.radius\n\n\tif distance > 0 then\n\t\tlocal orbit = sqrt(planet.GM/distance)\n\t\treturn orbit\n\tend\n\treturn nil\nend\n\nfunction getOrbitFocus(cData)\n\tlocal apo = cData.orbitalParameters.apoapsis.altitude\n\tlocal peri = cData.orbitalParameters.periapsis.altitude\n\tlocal timeApo = cData.orbitalParameters.timeToApoapsis\n\tlocal timePer = cData.orbitalParameters.timeToPeriapsis\n\tlocal orbitSpeed = 0\n\tif timeApo <= timePer then\n\t\torbitAltTarget = apo\n\t\torbitSpeed = cData.orbitalParameters.apoapsis.circularOrbitSpeed\n\telse\n\t\torbitAltTarget = peri\n\t\torbitSpeed = cData.orbitalParameters.periapsis.circularOrbitSpeed\n\tend\n\n\treturn {orbitAltTarget = orbitAltTarget, orbitSpeed = orbitSpeed}\nend\nend)\npackage.preload['Saga:helpers/table.lua']=(function()\ntable = _G['table']\n\n\n\nfunction table.add(target, source)\n\tif source == nil then return target end\n\tfor k,v in pairs(source) do\n\t\ttable.insert(target, v)\n\tend\n\treturn target\nend\n\nfunction table.contains(needle, haystack, asKey)\n\tif asKey == nil then asKey = false end\n\tlocal found = false\n\tlocal foundValue = nil\n\tlocal foundKey = nil\n\tfor k,h in pairs(haystack) do\n\t\tif type(h) == \"table\" then\n\t\t\tfound = table.contains(needle, h)\n\t\t\tif found then break end\n\t\telseif h == needle then\n\t\t\tfound = true\n\t\t\tfoundValue = h\n\t\t\tfoundKey = k\n\t\t\tbreak\n\t\tend\n\tend\n\treturn ternary(asKey, foundKey, found)\nend\n\nfunction table.find(needle, haystack)\n\treturn table.contains(needle, haystack, true)\nend\n\nfunction table.keys(t)\n\tlocal keys = {}\n\tfor k,_ in pairs(t) do\n\t\ttable.insert(keys, k)\n\tend\n\treturn keys\nend\n\n\n\n\n\n\n\nfunction table.isArray(t)\n  local i = 0\n  for _ in pairs(t) do\n\t  i = i + 1\n\t  if t[i] == nil then return false end\n  end\n  return true\nend\nend)\npackage.preload['Saga:helpers/vector_math.lua']=(function()\nlocal uround, r2d = utils.round, constants.rad2deg\nspcVector = 'none'\n\nfunction signedRotationAngle(normal, vecA, vecB)\n\tvecA = vecA:project_on_plane(normal)\n\tvecB = vecB:project_on_plane(normal)\n\treturn atan(vecA:cross(vecB):dot(normal), vecA:dot(vecB))\nend\n\nfunction vectorRotated(vector, direction)\n\treturn vec3(vector):cross(vec3(direction))\nend\n\nfunction projectedDistance(point, position)\n\tif not point then return 0 end\n\tif position == nil then\n\t\tposition = cData.position\n\tend\n\tposition = position:project_on_plane(cData.wVert)\n\treturn uround(vec3(position - (point:project_on_plane(cData.wVert))):len(),0.01)\nend\n\nfunction vectorToPoint(point, position)\n\tlocal pos = position or cData.position\n\treturn vec3(pos - point):normalize()\nend\n\nfunction vectorToPoint2(point, position)\n\tlocal pos = position or cData.position\n\treturn vec3(point - pos):normalize()\nend\n\nfunction circleNormal(point)\n\tlocal body = findClosestBody(cData.position)\n\tif not body then return vec3() end\n\tlocal vecToA = cData.position - body.center\n\tlocal vecToB = point - body.center\n\tlocal circleNormal = vecToB:cross(vecToA):normalize()\n\treturn (circleNormal:cross(vecToA)):normalize()\nend\n\nfunction variousVectors(vector)\n\tlocal gL, cD = globals, cData\n\tlocal autoPilot = AutoPilot\n\tlocal angleToPoint = -cD.wVelDir:angle_between(vector) * r2d\n\tlocal v90 = (vector - (-cD.wVelDir))\n\tlocal vecHalf = (v90 + vector):normalize()\n\tlocal vecMain = v90 + vector + v90\n\tif gL.apMode == 'Transfer' or gL.apMode == 'standby' then\n\t\tif cD.speedKph >= autoPilot.maxSpaceSpeed then\n\t\t\tspcVector = 'ninety'\n\t\t\tvecMain = (vector:normalize() - (-cD.wVelDir:normalize()))\n\t\telseif cD.speedKph > (autoPilot.maxSpaceSpeed/3) and cD.speedKph < autoPilot.maxSpaceSpeed then\n\t\t\tspcVector = 'main'\n\t\t\tvecMain = v90 + (vector + (v90 * (20 * (1 - clamp(getSpaceVelocityTargetAngle()/45,0,1)))))\n\t\telse\n\t\t\tspcVector = 'main2'\n\t\t\tvecMain = v90 + vector + v90 + v90\n\t\tend\n\telse\n\t\tspcVector = 'none'\n\t\tvecMain = v90 + vector + v90\n\tend\n\treturn {angleToPoint = angleToPoint, ninety = v90,vecHalf = vecHalf, vecMain = vecMain}\nend\n\nfunction getVelocityAngle()\n\tif cData.constructSpeed < 1 then return 0 end\n\treturn uround(((cData.wFwd):angle_between(cData.wVelDir))*r2d,0.0001)\nend\n\nfunction getVelocityWorldAngle()\n\tif cData.constructSpeed < 1 then return 0 end\n\treturn uround(((cData.wVelDir:project_on_plane(cData.wVert)):angle_between(cData.wVelDir))*r2d,0.0001)\nend\n\nfunction targetAngularVelocityAngle()\n\tif globals.apMode == 'Transfer' and cData.constructSpeed > 1 then\n\t\t\t\treturn uround(vectorToPoint(variousVectors(AutoPilot.target).vecMain):angle_between(vectorToPoint(cData.wFwd))*r2d,0.0001)\n\tend\n\treturn 0\nend\n\nfunction getTargetWorldAngle()\n\tlocal cD, ap = AutoPilot, cData\n\tif sameBody and ap.targetBody ~= nil then\n\t\treturn uround(vectorToPoint(ap.targetBody.center,ap.target):angle_between(vectorToPoint(ap.targetBody.center,cD.position))*r2d,0.0001)\n\tend\n\tif not cD.body then return 0 end\n\treturn uround(vectorToPoint(ap.target,cD.body.center):angle_between(vectorToPoint(cD.position,cD.body.center))*r2d,0.0001)\nend\n\nfunction getTargetAngle(target, inRad)\n\tlocal t = target or AutoPilot.target\n\tif t == nil then return 0 end\n\tlocal rad = signedRotationAngle(cData.worldUp, -cData.wFwd, vectorToPoint(t):project_on_plane(cData.wVert))\n\treturn uround(ternary(inRad, rad, -deg(rad)),0.0001)\nend\n\nfunction getVelocityTargetAngle(target)\n\tlocal t = target or AutoPilot.target\n\treturn uround(-deg(signedRotationAngle(cData.worldUp, -cData.wVelDir:project_on_plane(cData.wVert), circleNormal(t):project_on_plane(cData.wVert))),0.0001)\nend\n\nfunction getSpaceVelocityTargetAngle(target)\n\tif cData.constructSpeed < 1 then return 0 end\n\tlocal t = target or AutoPilot.target\n\treturn uround(cData.wVelDir:angle_between(-vectorToPoint(t))*r2d,0.0001)\nend\n\nfunction getReticle(vector)\n\treturn {cData.position.x + vector.x, cData.position.y + vector.y, cData.position.z + vector.z}\nend\n\nfunction getXYZ(vector)\n\treturn {vector.x, vector.y, vector.z}\nend\nend)\npackage.preload['Saga:hud/widgets/aggInfo.lua']=(function()\nWidgets.aggInfo = Widget:new{class = 'aggInfo'}\nfunction Widgets.aggInfo:build()\n\tlocal agd, sgrn = aggData, 'springgreen'\n\tif agd == nil then return \"\" end\n\tlocal agStat = 'Offline'\n\tlocal agColor = 'orangered'\n\tlocal bCol = agColor\n\tif agd.aggState then\n\t\tagColor = sgrn\n\t\tagStat = 'Online'\n\tend\n\tif agd.aggBubble then bCol = sgrn end\n\tlocal strings = {}\n\tstrings[#strings+1] = boldSpan('AGG INFO')\n\tstrings[#strings+1] = 'Status: '..colorSpan(agColor,agStat)\n\tstrings[#strings+1] = 'Target Alt: '..agd.aggTarget\n\tstrings[#strings+1] = 'Current Alt: '..agd.aggAltitude\n\t\t\t\tstrings[#strings+1] = 'Power: '..round2(agd.aggPower*100,2)..' %'\n\tstrings[#strings+1] = 'In Bubble: '..colorSpan(bCol, tostring(agd.aggBubble))\n\tself.rowCount = #strings\n\treturn table.concat(strings, '<br>')\nend\nend)\npackage.preload['Saga:hud/widgets/controls.lua']=(function()\nWidgets.controls = Widget:new{class = 'controlsBox'}\nfunction Widgets.controls:build()\n\tlocal ct, s, tos, gC, ap = colIfTrue, {}, tostring, globals, AutoPilot\n\ts[#s+1] = 'Alt-1| Toggle AP - '..ct(ap.enabled)\n\ts[#s+1] = 'Alt-2| Altitude Hold - '..ct(gC.altitudeHold)\n\ts[#s+1] = 'Alt-3| Orbital Hold - '..ct(gC.orbitalHold)\n\ts[#s+1] = 'Alt-4| Radial Hold - '..tos(gC.radialMode)\n\ts[#s+1] = 'Alt-5| Engine Mode - '..tos(gC.boostMode)\n\ts[#s+1] = 'Alt-6| Prev Route'\n\ts[#s+1] = 'Alt-7| Next Route'\n\t\t\tlocal damp = ternary(gC.maneuverMode, 'Forward', 'Rotation')\n\ts[#s+1] = 'Alt-8| '..damp..' Damp. - '..ct(gC.rotationDampening)\n\ts[#s+1] = 'Alt-9| Flight Mode - '..(gC.maneuverMode and 'Maneuver' or 'Standard')\n\n\ts[#s+1] = '<br>Alt-Shift-1| Toggle Main Menu'\n\tif gC.maneuverMode then\n\t\ts[#s+1] = 'Alt-Shift-6| Activate Base'\n\t\ts[#s+1] = 'Alt-Shift-7| Set Base'\n\telse\n\t\ts[#s+1] = 'Alt-Shift-2| Follow Mode - '..ct(gC.followMode)\n\tend\n\ts[#s+1] = 'Alt-Shift-8| Slow Flat - '..ct(ap.userConfig.slowFlat)\n\ts[#s+1] = '<br>G| Parking - '..ct(ap.landingMode)\n\ts[#s+1] = 'Alt + CTRL | Brake Lock - '..ct(inputs.manualBrake)\n\tself.rowCount = #s\n\treturn table.concat(s, '<br>')\nend\nend)\npackage.preload['Saga:hud/widgets/core.lua']=(function()\nWidgets.core = Widget:new{\n\tclass = 'coreInfo',\n\tcore = links.core,\n\tshield = links.shield,\n\tlastUpd = ''\n}\nfunction Widgets.core:build()\n\tif not HUD.Config.coreWidget then return '' end\n\n\tlocal gCache = globals\n\tif not gCache.updatecore then return self.lastUpd end\n\tgCache.updatecore = false\n\n\tlocal coreHealth = math.abs((self.core.getCoreStressRatio()*100)-100)\n\tlocal coreStress = self.core.getCoreStress()\n\tlocal coreMaxStress = self.core.getMaxCoreStress()\n\tlocal cD = cData\n\tif cD.pvpZone then\n\t\tself.class = 'coreInfo alert'\n\tend\n\tlocal green = 'springgreen'\n\tlocal ored = 'orangered'\n\tlocal cColor = green\n\tif coreHealth <= 20 then\n\t\tcColor = ored\n\telseif coreHealth <= 50 then\n\t\tcColor = 'goldenrod'\n\tend\n\n\tlocal strings = {}\n\tstrings[#strings+1] = 'Core: '..colorSpan(cColor, coreHealth..'%')\n\tstrings[#strings+1] = 'Core Stress: '..colorSpan(cColor, coreMaxStress - coreStress)..' / '..coreMaxStress\n\tlocal ssh = self.shield\n\tif ssh ~= nil then\n\t\tlocal shp = ssh.getShieldHitpoints()\n\t\tlocal mshp = ssh.getMaxShieldHitpoints()\n\t\tlocal sHealth = ((shp / mshp) * 100)\n\t\tlocal shieldActiveColor = ored\n\t\tlocal shieldColor = green\n\t\tif sHealth <= 20 then\n\t\t\tshieldColor = ored\n\t\telseif sHealth <= 50 then\n\t\t\tshieldColor = 'goldenrod'\n\t\tend\n\t\tif ssh.isActive() == 1 then\n\t\t\tshieldActiveColor = green\n\t\tend\n\n\t\tlocal shieldStateStr = colorSpan(shieldActiveColor,'Shield')\n\t\tlocal shieldHealthStr = colorSpan(shieldColor,sHealth..'%')\n\t\tlocal shieldHpStr = colorSpan(shieldColor,shp)..' / '..mshp\n\t\tstrings[#strings+1] = shieldStateStr..': '..shieldHealthStr\n\t\tstrings[#strings+1] = 'Shield Health: '..shieldHpStr\n\tend\n\tif cD.pvpZone then\n\t\tstrings[#strings+1] = 'PvP Timer: '..cD.pvpTimer\n\tend\n\tself.rowCount = #strings\n\tself.lastUpd = table.concat(strings,' | ')\n\treturn self.lastUpd\nend\nend)\npackage.preload['Saga:hud/widgets/fuelInfo.lua']=(function()\nWidgets.fuelInfo = Widget:new{class = 'fuelInfo'}\nfunction Widgets.fuelInfo:build()\n    local strings = {}\n    strings[#strings+1] = 'Fuel Tanks'\n\n    for key, tanks in pairs(fuels) do\n\t\tif #tanks > 0 then\n            strings[#strings+1] = ''\n            strings[#strings+1] = key\n        end\n        for i, tank in ipairs(tanks) do\n            local pColor = 'ivory'\n\t\t\tif tank.percent <= 20 then\n\t\t\t\tpColor = 'orangered'\n\t\t\telseif tank.percent <= 50 then\n\t\t\t\tpColor = 'goldenrod'\n\t\t\tend\n\t\t\tstrings[#strings+1] = tank.name..' - <span style=\"color: '..pColor..'\">'..tank.percent..'%</span>'\n        end\n    end\n    self.rowCount = #strings\n    return table.concat(strings, '<br>')\nend\nend)\npackage.preload['Saga:hud/widgets/infos.lua']=(function()\nWidgets.infos = Widget:new{class = 'infos'}\nfunction Widgets.infos:build()\n\tlocal gC, cD, ap = globals, cData, AutoPilot\n\tlocal s, cs, rnd = {}, colorSpan, round2\n\tlocal rpy, gFM = cD.rpy, gC.maneuverMode\n    local fm = ternary(gFM, ternary(ship.landingMode,'LANDING','Maneuver'),'Standard')\n\ts[#s+1] = boldSpan('FLIGHT MODE: ')..cs(ternary(gFM,'orange','springgreen'),fm)\n\n\t\tif ap.target then\n\t\tlocal sT = boldSpan('TARGET: ')\n\t\tlocal rIdx = tonumber(ap.currentRouteIndex)\n\t\tif rIdx and rIdx > 0 then\n\t\t\tlocal tmpR = RouteDatabase.routes[rIdx]\n\t\t\tif tmpR and tmpR.name then\n\t\t\t\ts[#s+1] = sT..cs('springgreen',tostring(tmpR.name))\n\t\t\tend\n\t\telse\n\t\t\tif ap.targetLoc then\n\t\t\t\ts[#s+1] = sT..cs('springgreen',tostring(ap.targetLoc))\n\t\t\tend\n\t\tend\n\t\tif gC.maneuverMode and cD.inAtmo then\n\t\t\ts[#s+1] = boldSpan('Travel alt.: ')..cs('springgreen',round2(ap.userConfig.travelAlt,2))\n\t\tend\n\tend\n\n\t\t\n\ts[#s+1] = 'Throttle = ' .. rnd(cD.curThrottle,2)\n\ts[#s+1] = 'Pitch = ' .. rnd(rpy.pitch,2)\n\ts[#s+1] = 'Yaw = ' .. rnd(rpy.yaw,2)\n\ts[#s+1] = 'Roll = ' .. rnd(rpy.roll,2)\n\t\t\t\t\t\t\t\t\ts[#s+1] = '<br>Burn Protection = ' .. tostring(ap.userConfig.throttleBurnProtection)\n\tif not cD.inAtmo then\n\t\ts[#s+1] = 'Max Space V = ' .. tostring(rnd(ap.maxSpaceSpeed))\n\tend\n\ts[#s+1] = 'Brake Dist = ' .. printDistance(cD.brakes.distance, true)\n\ts[#s+1] = 'Mass = ' .. rnd(cD.mass/1000, 3) .. ' T'\n\tif gC.altitudeHold and gC.holdAltitude > 0 then\n\t\ts[#s+1] = 'Alt. Hold = ' .. round2(gC.holdAltitude,0)\n\tend\n\t\t\t\t\t\t\t\t\tif ap.userConfig.hoverHeight then\n\t\ts[#s+1] = \"Hover: \"..round2(ap.userConfig.hoverHeight or 0,2)\n\tend\n\tif ap.userConfig.agl then\n\t\ts[#s+1] = \"AGL: \"..round2(ap.userConfig.agl or 0,2)\n\tend\n\ts[#s+1] = \"Ground: \"..round2(cD.GrndDist or 0,2)\n\n\tif vec3.isvector(ap.target) then\n\t\tlocal distanceToTarget = vector.dist(ap.target, cD.position)\n\t\ts[#s+1] = '<br>Target = ' .. printDistance(distanceToTarget)\n\t\tlocal speed = cD.constructSpeed\n\t\tlocal eta = 'ETA = '\n\t\tif speed >= 1 then\n\t\t\tlocal secondsToTarget = distanceToTarget / speed\n\t\t\ts[#s+1] = eta..formatTimeString(secondsToTarget) .. ' (' .. rnd(speed) .. ' m/s)'\n\t\telse\n\t\t\ts[#s+1] = eta..' (0 m/s)'\n\t\tend\n\t\tif ship.angle then\n\t\t\ts[#s+1] = 'Angle: '..round2(ship.angle,4)\n\t\tend\n\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\tself.rowCount = #s\n\treturn table.concat(s, '<br>')\nend\nend)\npackage.preload['Saga:hud/widgets/mainMenu.lua']=(function()\nWidgets.mainMenu = Widget:new{\n\tclass = 'mainMenu',\n\tanchor = anchorENUM.topRight,\n\tpadding = 4,\n\trowHeight = 16,\n\trowMargin = 4,\n\theaderHeight = 20\n}\n\ncategoryENUM = {\n\tRouteList = 'RouteList',\n\tRouteListAll = 'RouteListAll',\n\tRouteListByPlanet = 'RouteListByPlanet',\n\tEditRoute = 'EditRoute',\n\tAutopilot = 'Autopilot',\n\tSettings = 'Settings',\n\tAutopilotConfig = 'AutopilotConfig',\n\tDatabanks = 'Databanks',\n\tDatabanksConfig = 'DatabanksConfig',\n\tDatabanksRoute = 'DatabanksRoute',\n\tDatabanksUSB = 'DatabanksUSB',\n\tScale = 'Scale',\n\tHUD = 'HUD'\n\t}\n\nfunction Widgets.mainMenu:init()\n\tlocal categoryENUM = categoryENUM\n\tself.optionMenu = MenuSystem\n\n\tself.tooltips = {\n\t\tmaxSpaceSpeed = {'Maximum space travel speed', 'Set to 0 for automatic detection', maxSpaceSpeed .. ' Default'},\n\t\tmaxPitch = {'How steep to pitch in atmo in degrees', maxPitch .. ' Default'},\n\t\tmaxRoll = {'How steep to roll in atmo in degrees', maxRoll .. ' Default'},\n\t\twingStallAngle = {'Degrees from your trajectory your ship', 'stalls at, based on majority of airfoil', 'type used for lift (Ailerons 35,', 'Wings 50, Stabilizers 70)', wingStallAngle .. ' Default'},\n\t\thoverHeight = {'Hover height in meters', hoverHeight .. ' Default'},\n\t\tthrottleBurnProtection = {'Will take over throttle/brakes to prevent', 'burning in atmosphere. Use brakes or', 'change throttle to take manual control again.'},\n\t\tshieldManage = {'Automatic shield state and resistance control'},\n\t\tradarBoxes = {'Show radar contacts in the HUD'},\n\t\tradarWidget = {'Show the default radar widget'},\n\t\tslowFlat = {'Levels the ship when','below 100km / hr and in atmo'},\n\t\tspaceCapableOverride = {'Rarely used, only if engines are angled', 'in a way where space capability isnt', 'detected automatically correctly.'},\n\t\ttravelAlt = {'Maneuver Mode only!','Default altitude at which to travel via Autopilot targets.','Default: 1500m'}\n\t}\n\n\tConfig.defaults[configDatabankMap.menuKeyLegend] = self.optionMenu.config.legendVisible\n\tEventSystem:register('ConfigDBChanged', self.applyConfig, self)\n\tself:applyConfig()\n\n\t\tself.optionMenu.config.optionWidth = self.width - self.padding * 2\n\tself.optionMenu.config.optionHeight = self.rowHeight\n\tself.optionMenu.config.optionMargin = self.rowMargin\n\tself.optionMenu.config.headerHeight = self.headerHeight\n\n\tself.optionMenu:addCategory('Routes', categoryENUM.RouteList)\n\tself.optionMenu:addCategory('All Routes', categoryENUM.RouteListAll, categoryENUM.RouteList)\n\t\n\tself.optionMenu:addCategory('Autopilot Controls', categoryENUM.Autopilot)\n\n\tself.optionMenu:addCategory('Settings', categoryENUM.Settings)\n\tself.optionMenu:addCategory('Autopilot Configuration', categoryENUM.AutopilotConfig, categoryENUM.Settings)\n\tself.optionMenu:addCategory('Databanks', categoryENUM.Databanks, categoryENUM.Settings)\n\tself.optionMenu:addCategory('Visuals', categoryENUM.HUD, categoryENUM.Settings)\n\tself.optionMenu:addCategory('Scale', categoryENUM.Scale, categoryENUM.HUD, { getValue = {\n\t\tfunc = function() return (Config:getValue(configDatabankMap.hudScale) * 100) .. '%' end },\n\t\tinput = { func = setConfigInput, arg = configDatabankMap.hudScale,\n\t\tfilter = function(input) return clamp(tonumber(input), 30, 250) / 100 end } } )\n\n\tself.optionMenu:addCategory('Config DB', categoryENUM.DatabanksConfig, categoryENUM.Databanks, { getValue = { func = getActiveDbName, arg = 'config' } })\n\tself.optionMenu:addCategory('Route DB', categoryENUM.DatabanksRoute, categoryENUM.Databanks, { getValue = { func = getActiveDbName, arg = 'routes' } })\n\tself.optionMenu:addCategory('USB DB', categoryENUM.DatabanksUSB, categoryENUM.Databanks, { getValue = { func = getActiveDbName, arg = 'usb' } })\n\n\tself.optionMenu:addOption('Toggle On/Off', categoryENUM.Autopilot, { main = { func = AutoPilot.toggleState }, getValue = { func = function() return AutoPilot.enabled end } })\n\tself.optionMenu:addOption('New Route', categoryENUM.RouteList, { main = { func = newRoute } })\n\n\tself.optionMenu:addCategory('Route', categoryENUM.EditRoute, categoryENUM.EditRoute, { back = { func = unEditRoute, arg = i } }, true)\n\tself.optionMenu:addOption('Name', categoryENUM.EditRoute, { input = { func = editRouteName }, getValue = { func = getEditRouteName } }, true)\n\tself.optionMenu:addOption('Add Current Position', categoryENUM.EditRoute, { main = { func = addCurrentPos } }, true)\n\tself.optionMenu:addOption('Add ::pos{} Location', categoryENUM.EditRoute, { input = { func = addCustomPos } }, true)\n\n\tfor i = 0, 22 do\n\t\tlocal multiplier = i + 3\n\t\tlocal scaleStr = (multiplier * 10) .. '%'\n\t\tself.optionMenu:addOption(scaleStr, categoryENUM.Scale, {\n\t\t\tgetActive = { func = function(option, multi) return Config:getValue(configDatabankMap.hudScale) == multi end, arg = multiplier / 10 },\n\t\t\tmain = { func = setConfig, arg = { key = configDatabankMap.hudScale, value = multiplier / 10 } }\n\t\t})\n\tend\n\tEventSystem:register('ConfigChange' .. configDatabankMap.hudScale, HUD.updateScale)\n\tEventSystem:register('RoutesUpdated', self.updateRoutes, self)\n\n\tself.optionMenu:addOption('Core Widget', categoryENUM.HUD, { main = { func = function() HUD.toggleCoreWidget() end }, getValue = { func = function() return HUD.Config.coreWidget end } })\n\tself.optionMenu:addOption('Docking Widget', categoryENUM.HUD, { main = { func = function() HUD.toggleDockWidget() end }, getValue = { func = function() return HUD.Config.dockWidget end } })\n\tself.optionMenu:addOption('Unit Widget', categoryENUM.HUD, { main = { func = function() HUD.toggleUnitWidget() end }, getValue = { func = function() return HUD.Config.unitWidgetVisible end } })\n\tif #links.radars > 0 then\n\t\tself.optionMenu:addOption('Radar Boxes', categoryENUM.HUD, { main = { func = function() Radar.toggleBoxes(nil) end }, getValue = { func = function() return Radar.boxesVisible == true end }, tooltip = self.tooltips.radarBoxes })\n\t\tself.optionMenu:addOption('Radar Widget', categoryENUM.HUD, { main = { func = function() Radar.toggleWidget(nil) end }, getValue = { func = function() return Radar.widgetId ~= nil end }, tooltip = self.tooltips.radarWidget })\n\tend\n\tself.optionMenu:addOption('Menu Action Legend', categoryENUM.HUD, { main = { func = function() self.optionMenu:toggleLegend() end }, getValue = { func = function() return self.optionMenu.config.legendVisible end } })\n\n\tself.optionMenu:addOption('Max Space Speed', categoryENUM.AutopilotConfig, { input = { func = function(text) Config:setValue(configDatabankMap.maxSpaceSpeed, tonumber(text)) AutoPilot:applyConfig() end }, getValue = { func = function() return AutoPilot.userConfig.maxSpaceSpeed end }, tooltip = self.tooltips.maxSpaceSpeed })\n\tself.optionMenu:addOption('Max Pitch', categoryENUM.AutopilotConfig, { input = { func = function(text) Config:setValue(configDatabankMap.maxPitch, tonumber(text)) AutoPilot:applyConfig() end }, getValue = { func = function() return AutoPilot.userConfig.maxPitch end }, tooltip = self.tooltips.maxPitch })\n\tself.optionMenu:addOption('Max Roll', categoryENUM.AutopilotConfig, { input = { func = function(text) Config:setValue(configDatabankMap.maxRoll, tonumber(text)) AutoPilot:applyConfig() end }, getValue = { func = function() return AutoPilot.userConfig.maxRoll end }, tooltip = self.tooltips.maxRoll })\n\tself.optionMenu:addOption('Wing Stall Angle', categoryENUM.AutopilotConfig, { input = { func = function(text) Config:setValue(configDatabankMap.wingStallAngle, tonumber(text)) AutoPilot:applyConfig() end }, getValue = { func = function() return AutoPilot.userConfig.wingStallAngle end }, tooltip = self.tooltips.wingStallAngle })\n\tself.optionMenu:addOption('Hover Height', categoryENUM.AutopilotConfig, { input = { func = function(text) Config:setValue(configDatabankMap.hoverHeight, tonumber(text)) AutoPilot:applyConfig() end }, getValue = { func = function() return AutoPilot.userConfig.hoverHeight end }, tooltip = self.tooltips.hoverHeight })\n\tself.optionMenu:addOption('Shield Management', categoryENUM.AutopilotConfig, { main = { func = AutoPilot.toggleShieldManage }, getValue = { func = function() return AutoPilot.userConfig.shieldManage end }, tooltip = self.tooltips.shieldManage })\n\tself.optionMenu:addOption('Burn Protection', categoryENUM.AutopilotConfig, { main = { func = AutoPilot.toggleThrottleBurnProtection }, getValue = { func = function() return AutoPilot.userConfig.throttleBurnProtection end }, tooltip = self.tooltips.throttleBurnProtection })\n\tself.optionMenu:addOption('Slow Flat', categoryENUM.AutopilotConfig, { main = { func = AutoPilot.toggleSlowFlat }, getValue = { func = function() return AutoPilot.userConfig.slowFlat end }, tooltip = self.tooltips.slowFlat })\n\tself.optionMenu:addOption('Space Capable Override', categoryENUM.AutopilotConfig, { main = { func = AutoPilot.toggleSpaceCapableOverride }, getValue = { func = function() return AutoPilot.userConfig.spaceCapableOverride end },tooltip = self.tooltips.spaceCapableOverride })\n\tself.optionMenu:addOption('Travel Altitude', categoryENUM.AutopilotConfig, { input = { func = function(text) Config:setValue(configDatabankMap.travelAlt, tonumber(text)) AutoPilot:applyConfig() end }, getValue = { func = function() return AutoPilot.userConfig.travelAlt end }, tooltip = self.tooltips.travelAlt })\n\n\t\tself.optionMenu.onClose = function()\n\t\tHUD.Config.mainMenuVisible = false\n\tend\n\n\tself:updateDatabanks()\n\tself:updateRoutes()\nend\n\nfunction Widgets.mainMenu:applyConfig()\n\tself.optionMenu.config.legendVisible = Config:getValue(configDatabankMap.menuKeyLegend)\nend\n\nfunction Widgets.mainMenu:update()\n\tself.optionMenu:updateInputs()\nend\n\nfunction Widgets.mainMenu:build()\n\tlocal rendered = ''\n\n\tlocal screenWidth = HUD.screenWidth\n\tlocal screenHeight = HUD.screenHeight\n\tlocal padding = self.padding * HUD.Config.scaleMultiplier\n\t\trendered = rendered .. '<style>' .. HUD.staticCSS.menuCss .. '></style>'\n\n\t\trendered = rendered .. '<svg style=\"position:absolute;top:' .. padding .. ';left:' .. padding .. ';\" height=\"100vh\" viewBox=\"0 0 '..screenWidth..' '..screenHeight..'\" preserveAspectRatio=\"xMidYMid\" overflow=\"visible\" xmlns=\"http://www.w3.org/2000/svg\">\\n'\n\n\trendered = rendered .. '<defs>' .. HUD.staticCSS.gradientDefs .. '</defs>'..\n\t\t'<g class=\"mainMenu\">' .. self.optionMenu:render() .. '</g></svg>'\n\n\t\tself.rowCount = self.optionMenu.rowCount\n\treturn rendered\nend\n\nfunction Widgets.mainMenu:updateDatabanks()\n\tself.optionMenu:clearCategory(categoryENUM.DatabanksConfig)\n\tself.optionMenu:clearCategory(categoryENUM.DatabanksRoute)\n\tself.optionMenu:clearCategory(categoryENUM.DatabanksUSB)\n\tfor _, databank in ipairs(links.databanks) do\n\t\tself.optionMenu:addOption(databank.name, categoryENUM.DatabanksConfig, {\n\t\t\tmain = { func = selectDatabank, arg = { type = 'config', databank = databank } },\n\t\t\tgetActive = { func = function(option, dbk) return Config.databank == dbk end, arg = databank },\n\t\t})\n\t\tself.optionMenu:addOption(databank.name, categoryENUM.DatabanksRoute, {\n\t\t\tmain = { func = selectDatabank, arg = { type = 'route', databank = databank } },\n\t\t\tgetActive = { func = function(option, dbk) return RouteDatabase.databank == dbk end, arg = databank },\n\t\t})\n\t\tself.optionMenu:addOption(databank.name, categoryENUM.DatabanksUSB, {\n\t\t\tmain = { func = selectDatabank, arg = { type = 'usb', databank = databank } }\n\t\t})\n\tend\nend\n\nfunction Widgets.mainMenu:onEditedRouteChanged()\n\t\tself.optionMenu:clearCategory(categoryENUM.EditRoute)\n\n\t\tlocal invalidRoute = RouteDatabase.routes[RouteDatabase.currentEditId] == nil\n\tlocal routeIsEmpty = #RouteDatabase.routes[RouteDatabase.currentEditId].points == 0\n\tif invalidRoute or routeIsEmpty then return end\n\n\t\tfor i, point in pairs(RouteDatabase.routes[RouteDatabase.currentEditId].points) do\n\t\tlocal actions = {\n\t\t\tmain = { func = setPointDestination, arg = i, text = 'Set Destination' },\n\t\t\tshift = { func = deletePoint, arg = i, text = 'Delete', hold = 2 },\n\t\t\talt = { func = printPoint, arg = i, text = 'Print Coordinates' },\n\t\t\taltUpDown = { func = movePoint, arg = i, text = 'Change point order' },\n\t\t\tinput = { func = editPointName, arg = i },\n\t\t\tgetActive = { func = function(option, arg) return AutoPilot.currentPointIndex == arg end, arg = i },\n\t\t}\n\t\tself.optionMenu:addOption(point.name, categoryENUM.EditRoute, actions)\n\tend\nend\n\nfunction Widgets.mainMenu:updateRoutes()\n\tself.optionMenu:clearCategory(categoryENUM.RouteListAll)\n\tfor i, route in ipairs(RouteDatabase.routes) do\n\t\tlocal pointCount = RouteDatabase:getRoutePointCount(i)\n\t\tif pointCount == 0 then pointCount = '-' end\n\t\tlocal actions = {\n\t\t\tmain = { func = setRouteDestination, arg = i, text = 'Set Destination' },\n\t\t\tshift = { func = deleteRoute, arg = i, text = 'Delete', hold = 2 },\n\t\t\talt = { func = editRoute, arg = i, text = 'Open' },\n\t\t\tgetValue = '( ' .. pointCount .. ' )',\n\t\t\tgetActive = { func = function(option, arg) return AutoPilot.currentRouteIndex == arg end, arg = i },\n\t\t}\n\t\tself.optionMenu:addOption(route.name, categoryENUM.RouteListAll, actions)\n\tend\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\n\t\tend\nend)\npackage.preload['Saga:hud/widgets/radarContacts.lua']=(function()\nradarWidgetTemplate = {\n\tclass = 'radar',\n\tanchor = anchorENUM.bottom,\n\twidth = 280\n}\nlocal function getWidget()\n    return Widget:new{ class = radarWidgetTemplate.class, anchor = radarWidgetTemplate.anchor, width = radarWidgetTemplate.width }\nend\n\nWidgets.radarDynamic = getWidget()\nfunction Widgets.radarDynamic:build()\n\treturn buildContactListTest(self, 'Dynamic', Radar.radarDynamic)\nend\nWidgets.radarStatic = getWidget()\nfunction Widgets.radarStatic:build()\n\treturn buildContactListTest(self, 'Static', Radar.radarStatic)\nend\nWidgets.radarAbandoned = getWidget()\nfunction Widgets.radarAbandoned:build()\n\treturn buildContactListTest(self, 'Abandoned', Radar.radarAbandoned, true)\nend\nWidgets.radarAlien = getWidget()\nfunction Widgets.radarAlien:build()\n\treturn buildContactListTest(self, 'Alien', Radar.radarAlien)\nend\nWidgets.radarSpace = getWidget()\nfunction Widgets.radarSpace:build()\n\treturn buildContactListTest(self, 'Space', Radar.radarSpace)\nend\nWidgets.radarFriend = getWidget()\nfunction Widgets.radarFriend:build()\n\treturn buildContactListTest(self, 'Friend', Radar.radarFriend)\nend\nWidgets.radarThreat = getWidget()\nfunction Widgets.radarThreat:build()\n\treturn buildContactListTest(self, 'Threat', Radar.radarDynamic)\nend\n\nfunction buildContactListTest(self, headerText, contactList, doPrint)\n\tlocal rType = headerText\n\tlocal contacts = contactList\n\tself.rowCount = #contacts + 1\n\tlocal count = 0\n\n\tlocal strings = {}\n\tstrings[#strings+1] = headerText .. ' - ' .. #contacts\n\tfor i,contact in ipairs(contacts) do\n\t\tif rType == 'Threat' then\n\t\t\tif contacts[i]['targetThreatState'] == 0 then\n\t\t\t\tgoto continue\n\t\t\tend\n\t\tend\n\n\t\tlocal nameText = contact['constructId'] .. ' [' .. contact['size'] .. '] ' .. contact['name']\n        if doPrint == true then                     end\n\t\tstrings[#strings+1] = '<div class=\"radarRow\">'\n\t\tstrings[#strings+1] = '<div class=\"radarText\" style=\"left: 0.5vh; width: 5vh;\">' .. contact['constructId'] .. '</div>'\n\t\tstrings[#strings+1] = '<div class=\"radarText\" style=\"left: 5.5vh; width: 2.5vh;\">[' .. contact['size'] .. ']</div>'\n\t\tstrings[#strings+1] = '<div class=\"radarText\" style=\"left: 8vh; width: 15vh;\">' .. contact['name'] .. '</div>'\n\t\tstrings[#strings+1] = '<div class=\"radarText\" style=\"right: 0.5vh;\">' .. thousands(math.ceil(contact['distance'])) .. '</div>'\n\t\tstrings[#strings+1] = '</div>'\n\t\tcount = count + 1\n\t\tif count >= 10 then\n\t\t\tbreak\n\t\tend\n\t\t::continue::\n\tend\n\tself.visible = count > 0\n\treturn table.concat(strings, '')\nend\nend)\npackage.preload['Saga:hud/widgets/warpInfo.lua']=(function()\nWidgets.warpInfo = Widget:new{\n\tclass = 'warpInfo',\n\twarpData = warpData\n}\nfunction Widgets.warpInfo:build()\n\tself.warpData = warpData\n\tlocal cs = colorSpan\n\tlocal isReady, cells = self.warpData.status == 'Ready', self.warpData.warpCells >= self.warpData.warpCellsNeeded\n\tlocal cColor = ternary(cells, 'springgreen', 'orangered')\n\tlocal tColor = ternary(isReady and cells, 'springgreen', 'orangered')\n\n\tlocal s = {}\n\ts[#s+1] = boldSpan('WARP DRIVE INFO')\n\ts[#s+1] = 'Status : '..cs(tColor,self.warpData.status)\n\ts[#s+1] = 'Destination : ' .. self.warpData.warpDestination\n\ts[#s+1] = 'Distance : ' .. printDistance(self.warpData.warpDistance, true)\n\ts[#s+1] = 'Cells: ' .. cs(cColor,self.warpData.warpCellsNeeded) .. ' ('..self.warpData.warpCells..')'\n\ts[#s+1] = cs(tColor,'ENGAGE WARP: ALT-J')\n\tself.rowCount = #s\n\treturn table.concat(s, '<br>')\nend\nend)\npackage.preload['Saga:hud/debug.lua']=(function()\nfunction HUD.constructDebug()\n\t\t\tlocal gC, rnd, cD, ap = globals, round2, cData, AutoPilot\n\tlocal bDist = cD.brakes.distance\n\tlocal cPitch = rnd(cD.rpy.pitch)\n\t\n\tupdateTanksCo()\n\n\t\t\t\t\t\n\tlocal bColor, oRed, br, eDiv = 'ivory', 'orangered', '<br>', '</div>'\n\tlocal html = {}\n\thtml[#html+1] = getTDiv(\"speedBar\", 50, 50, HUD.dynamicSVG.speedBar)\n\thtml[#html+1] = getTDiv(\"throttleBar\", 50, 50, HUD.dynamicSVG.throttleBar)\n\n\t\n\tlocal bD2, planetStr = rnd(cD.brakes.distance*1.1,1), ''\n\tif cD.body then\n\t\tlocal dist = 0\n\t\tif cD.body.hasAtmosphere then \t\t\tdist = rnd(cD.body.atmoRadius - vector.dist(cD.body.center,cD.position),1)\n\t\t\tplanetStr = 'Atmo Dist = '\n\t\telse \t\t\tdist = rnd(vector.dist(cD.body.center,cD.position)-(cD.body.radius*1.05))\n\t\t\tplanetStr = 'Surf Dist ~ '\n\t\tend\n\t\tplanetStr = br..planetStr..printDistance(dist)\n\t\tif bD2 > dist and dist > 0 then bColor = oRed end\n\t\thtml[#html+1] = getTDiv(\"altBar\", 50, 50, HUD.dynamicSVG.altitudeBar)\n\t\t\tend\n\thtml[#html+1] = [[<div class=\"atmoAlert\">Brake Dist = ]]..\n\t\tcolorSpan(bColor,printDistance(bD2, true))..planetStr..eDiv\n\thtml[#html+1] = [[<div class=\"atmoAlert\" style=\"transform:translate(36.2vw,0vh);text-align:right;\">Vertical Speed: ]]..\n\t\t(rnd(cD.zSpeedKPH,1))..eDiv\n\n\tif ap.enabled and not gC.maneuverMode then\n\t\thtml[#html+1] = getAPDiv(\"AUTOPILOT\")\n\telseif ap.landingMode or ship.landingMode or cD.isLanded then\n\t\thtml[#html+1] = getAPDiv(\"PARKING MODE\")\n\telseif ship.takeoff then\n\t\thtml[#html+1] = getAPDiv(\"TAKEOFF\")\n\telseif ship.vertical then\n\t\thtml[#html+1] = getAPDiv(\"VERTICAL\")\n\telseif ship.gotoLock ~= nil then\n\t\thtml[#html+1] = getAPDiv(\"TRAVEL\")\n\tend\n\n\tif gC.safetyThrottle then\n\t\thtml[#html+1] = getBrakeDiv(\"SAFETY THROTTLE\", oRed)\n\telseif gC.altitudeHold then\n\t\thtml[#html+1] = getBrakeDiv(\"HODOR!   \"..rnd(ship.holdAltitude or 0,1)..\"m\", oRed)\n\telseif inputs.brakeLock then\n\t\thtml[#html+1] = getBrakeDiv(\"BRAKE LOCK\", oRed)\n\telseif inputs.brake == 1 then\n\t\thtml[#html+1] = getBrakeDiv(\"BRAKE\", oRed)\n\tend\n\t\t\t\n\tlocal collisionStatus = false\n\tif gC and type(gC.collision) == 'table' then\n\t\tlocal bDist2 = rnd(bDist*1.2)\n\t\tlocal vSpeed = cD.zSpeedKPH\n\n\t\tif gC.collision and gC.collision.hasAtmosphere then\n\t\t\tlocal atmoColDist2 = rnd(vector.dist(cD.body.center,cD.position)-(gC.collision.atmoRadius))\n\t\t\tif bDist2 > atmoColDist2 and atmoColDist2 > 0 and vSpeed < 0 and cD.constructSpeed > cD.burnSpeed then\n\t\t\t\tcollisionStatus = true\n\t\t\tend\n\t\telse\n\t\t\tlocal moonColDist = rnd(vector.dist(cD.body.center,cD.position)-(gC.collision.radius*1.1))\n\t\t\tif bDist2 > moonColDist and moonColDist > 0 and vSpeed < 0 then\n\t\t\t\tcollisionStatus = true\n\t\t\tend\n\t\tend\n\t\tif collisionStatus then\n\t\t\thtml[#html+1] = getDiv(\"collision\", \"Collision Alert: \"..tostring(gC.collision.name or \"(unknown)\"))\n\t\tend\n\t\t\t\t\t\tif ap.userConfig.throttleBurnProtection and not gC.orbitalHold\n\t\t\tand not ap.enabled and not ap.landingMode and cData.inAtmo then\n\t\t\tif collisionStatus then\n\t\t\t\tgC.safetyThrottle = true\n\t\t\t\tif controlMode() == 'cruise' then\n\t\t\t\t\tswapControl()\n\t\t\t\tend\n\t\t\t\tif cPitch < 5 then\n\t\t\t\t\tnavCom:setThrottleCommand(axisCommandId.longitudinal, 0)\n\t\t\t\tend\n\t\t\tend\n\t\t\tif gC.safetyThrottle and collisionStatus then\n\t\t\t\tgC.collisionBrake = true\n\t\t\t\tbrakeCtrl = 30\n\t\t\t\tinputs.brake = 1\n\t\t\tend\n\t\tend\n\tend\n\tif not collisionStatus and gC.collisionBrake then\n\t\tbrakeCtrl = 31\n\t\tgC.collisionBrake = false\n\t\tif not gC.brakeState then\n\t\t\tinputs.brake = 0\n\t\tend\n\tend\n\thtml[#html+1] = '<style>' .. HUD.staticCSS.css .. '></style>'\n\n\tlocal targetPoint = nil\n\tif ap.target ~= nil then\n\t\ttargetPoint = library.getPointOnScreen(getXYZ(ap.target)) \tend\n\n\t\t\tlocal coord =  vec3(cD.wFwd) * 20 + vec3(cD.worldUp) * 2\n\tlocal reticle1 = getReticle(coord)\n\tlocal point1 = library.getPointOnScreen(reticle1)\n\n\tlocal vector2 = vectorRotated(targetAngularVelocity,cD.wFwd)\n\tlocal reticle2 = getReticle(vector2*10)\n\t\tlocal point2 = library.getPointOnScreen(reticle2)\n\n\tlocal predict = cD.wVelDir*cD.constructSpeed\n\tlocal reticle3 = getReticle(predict)\n\tlocal point3 = library.getPointOnScreen(reticle3) \tlocal reticle4 = getReticle(-predict)\n\tlocal point4 = library.getPointOnScreen(reticle4) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif point1[1] <= 1 and point1[2] <= 1 then\n\t\tlocal crosshair = [[\n\t<div class=\"crosshair\" style=\"position:absolute;left:]]..(point1[1]*98)..[[%;top:]]..(point1[2]*101)..[[%;margin-top:0em;margin-left:0em;\">\n\t<svg style=\"width:2vw;height:2vh;\" viewBox=\"0 0 40 40\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n\t<path d=\"M23.6465 37.8683L24.0001 38.2218L24.3536 37.8683L26.3536 35.8684L26.5 35.7219V35.5148V26.5H35.5148H35.7219L35.8684 26.3536L37.8684 24.3536L38.2219 24L37.8684 23.6465L35.8684 21.6465L35.7219 21.5H35.5148H26.5V12.4852V12.2781L26.3536 12.1317L24.3536 10.1317L24.0001 9.77818L23.6465 10.1317L21.6465 12.1318L21.5 12.2782V12.4854V21.5H12.4854H12.2782L12.1318 21.6465L10.1318 23.6465L9.77824 24L10.1318 24.3536L12.1318 26.3536L12.2782 26.5H12.4854H21.5V35.5147V35.7218L21.6465 35.8682L23.6465 37.8683Z\" fill=\"#00dd00\" stroke=\"#333333\"/>\n\t</svg></div>]]\n\t\thtml[#html+1] = crosshair\n\tend\n\n\tif targetPoint ~= nil then\n\t\thtml[#html+1] = getTDivP(\"dot\", targetPoint, HUD.staticSVG.targetReticle)\n\t\thtml[#html+1] = getTDivP(\"dottext\", targetPoint, HUD.dynamicSVG.targetReticle2)\n\tend\n\thtml[#html+1] = getTDivP(\"dot\", point2, HUD.staticSVG.centerofMass)\n\thtml[#html+1] = getTDivP(\"dot\", point3, HUD.staticSVG.progradeReticle)\n\thtml[#html+1] = getTDivP(\"dot\", point4, HUD.staticSVG.retrogradeReticle)\n\t\t\n\treturn table.concat(html)\nend\nend)\npackage.preload['Saga:hud/widget.lua']=(function()\nanchorENUM = {\n\ttop = 'top',\n\ttopLeft = 'topLeft',\n\ttopRight = 'topRight',\n\tbottom = 'bottom',\n\tbottomLeft = 'bottomLeft',\n\tbottomRight = 'bottomRight',\n}\nWidget = {\n\tanchor = nil,\n\twidth = 200, \tedgeMargin = 45, \tmargin = 10, \theaderHeight = 0, \tpadding = 0, \trowCount = 0, \trowHeight = 0,\n\trowMargin = 0, \tvisible = true\n}\n\nfunction Widget:new(o)\n\to = o or {}\n\tsetmetatable(o, self)\n\tself.__index = self\n\treturn o\nend\n\nfunction Widget:init()\n\tend\n\nfunction Widget:build()\n\tend\n\nfunction Widget:render(anchorUsedWidth, anchorMaxWidth)\n\tif self.build ~= nil and type(self.build) == 'function' then\n\t\tif anchorUsedWidth == nil then anchorUsedWidth = 0 end\n\n\t\tlocal scaleMultiplier = HUD.Config.scaleMultiplier\n\t\tlocal nativeScaleMultiplier = HUD.Config.nativeScaleMultiplier\n\t\tlocal content = self:build()\n\n\t\tif not self.visible then return '' end\n\n\t\t\t\tlocal classes = {}\n\t\tif self.class ~= nil then classes = { self.class } end\n\t\ttable.insert(classes, 'widget')\n\t\tlocal classStr = ' class=\"' .. table.concat(classes, ' ') .. '\"'\n\n\t\t\t\tlocal anchorWidth = anchorMaxWidth * scaleMultiplier\n\t\tlocal widgetWidth = self.width * scaleMultiplier\n\t\tlocal widgetContentHeight = self.rowCount * (self.rowHeight + self.rowMargin) - self.rowMargin + self.headerHeight\n\t\tlocal widgetHeight = (widgetContentHeight + self.padding * 2) * scaleMultiplier\n\t\tlocal edgeMargin = self.edgeMargin * scaleMultiplier\n\t\tlocal xOffset = anchorUsedWidth * scaleMultiplier\n\t\tlocal yOffset = edgeMargin\n\t\tlocal anchorStr = ''\n\t\tif self.anchor == anchorENUM.top then\n\t\t\tyOffset = 4 * scaleMultiplier\n\t\t\txOffset = xOffset + HUD.screenWidth / 2 - widgetWidth / 2\n\t\t\tanchorStr = 'top: ' .. yOffset .. 'px; left: ' .. xOffset .. 'px;'\n\t\telseif self.anchor == anchorENUM.topLeft then\n\t\t\txOffset = xOffset + edgeMargin\n\t\t\tanchorStr = 'top: ' .. yOffset .. 'px; left: ' .. xOffset .. 'px;'\n\t\telseif self.anchor == anchorENUM.topRight then\n\t\t\txOffset = xOffset + edgeMargin\n\t\t\txOffset = xOffset + 440 * nativeScaleMultiplier\n\t\t\tanchorStr = 'top: ' .. yOffset .. 'px; right: ' .. xOffset .. 'px;'\n\t\telseif self.anchor == anchorENUM.bottom then\n\t\t\txOffset = xOffset + HUD.screenWidth / 2 - anchorWidth / 2\n\t\t\tanchorStr = 'bottom: ' .. yOffset .. 'px; left: ' .. xOffset .. 'px;'\n\t\telseif self.anchor == anchorENUM.bottomLeft then\n\t\t\txOffset = xOffset + edgeMargin\n\t\t\tanchorStr = 'bottom: ' .. yOffset .. 'px; left: ' .. xOffset .. 'px;'\n\t\telseif self.anchor == anchorENUM.bottomRight then\n\t\t\txOffset = xOffset + edgeMargin\n\t\t\tanchorStr = 'bottom: ' .. yOffset .. 'px; right: ' .. xOffset .. 'px;'\n\t\telse\n\t\t\tanchorStr = 'top: 50%; left: ' .. xOffset .. 'px;'\n\t\tend\n\n\t\tlocal borderWidth = 2 \t\tlocal sizeString = 'width:' .. (widgetWidth + borderWidth) .. 'px;'\n\t\tif widgetHeight > 0 then\n\t\t\tsizeString = 'width:' .. (widgetWidth + borderWidth) .. 'px;height:' .. (widgetHeight + borderWidth) .. 'px;'\n\t\tend\n\n\t\t\t\treturn '<div' .. classStr .. ' style=\"' .. anchorStr .. sizeString .. '\">' .. content .. '</div>'\n\tend\nend\nend)\npackage.preload['Saga:hud/menuSystem.lua']=(function()\nlocal mfloor, tinsert, tconcat = math.floor, table.insert, table.concat\nlocal svgBox = '<svg viewBox=\"0 0 100 100\" x=\"'\nMenuSystem = {\n\tconfig = {\n\t\toptionWidth = 50,\n\t\theaderHeight = 20,\n\t\toptionHeight = 20,\n\t\toptionMargin = 0,\n\t\tvisOptCnt = 12,\n\t\tactiveOption = 0,\n\t\tactiveCategory = nil,\n\t\tlegendVisible = true\n\t},\n\trowCount = 0,\n\toptions = {},\n\toptionCategories = {},\n\tconfirmCount = 0,\n\tlastOptionChangeTime = 0,\n\tlastInputs = {},\n\tlastInputTimes = {},\n\n\taddCategory = function(this, categoryText, categoryKey, parentCategoryKey, actions, permanent)\n\t\tlocal category = {\n\t\t\ttext = categoryText,\n\t\t\tkey = categoryKey,\n\t\t\tparentKey = parentCategoryKey,\n\t\t\tactions = actions,\n\t\t\tstate = {\n\t\t\t\thovering = false,\n\t\t\t\tactive = false\n\t\t\t},\n\t\t\tpermanent = permanent\n\t\t}\n\t\ttinsert(this.optionCategories, category)\n\t\treturn category\n\tend,\n\n\taddOption = function(this, optionText, categoryKey, actions, permanent)\n\t\tlocal option = {\n\t\t\ttext = optionText,\n\t\t\tcategory = categoryKey,\n\t\t\tactions = actions,\n\t\t\tstate = {\n\t\t\t\thovering = false,\n\t\t\t\tactive = false\n\t\t\t},\n\t\t\tpermanent = permanent\n\t\t}\n\t\ttinsert(this.options, option)\n\t\treturn option\n\tend,\n\n\tclearCategory = function(this, categoryKey)\n\t\tfor i = #this.options,1,-1 do\n\t\t\tlocal option = this.options[i]\n\t\t\tif option.category == categoryKey and option.permanent ~= true then\n\t\t\t\ttable.remove(this.options, i)\n\t\t\tend\n\t\tend\n\t\tfor i = #this.optionCategories,1,-1 do\n\t\t\tlocal category = this.optionCategories[i]\n\t\t\tif category.parentKey == categoryKey and category.permanent ~= true then\n\t\t\t\ttable.remove(this.optionCategories, i)\n\t\t\tend\n\t\tend\n\tend,\n\n\t\tonClose = function(this)\n\tend,\n\n\ttoggleLegend = function(this)\n\t\tthis.config.legendVisible = not this.config.legendVisible\n\t\tConfig:setValue(configDatabankMap.menuKeyLegend, this.config.legendVisible)\n\tend,\n\n\tupdateState = function(this, option, hovering)\n\t\tif option.actions ~= nil and option.actions.getActive ~= nil then\n\t\t\toption.state.active = option.actions.getActive.func(option, option.actions.getActive.arg)\n\t\tend\n\t\toption.state.hovering = hovering\n\tend,\n\n\topenCategory = function(this, categoryKey, currentCategory)\n\t\tthis.config.activeOption = 0\n\t\tthis.config.activeCategory = categoryKey\n\t\tlocal i = 0\n\t\tfor _, category in ipairs(this.optionCategories) do\n\t\t\tif category.parentKey == categoryKey then\n\t\t\t\tif currentCategory ~= nil and category.key == currentCategory.key then\n\t\t\t\t\tthis.config.activeOption = i\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\t\ti = i + 1\n\t\t\tend\n\t\tend\n\tend,\n\n\trender = function(this)\n\t\tlocal html = {}\n\t\tthis.rowCount = 0\n\t\tthis.hoveredEntry = nil\n\n\t\tlocal entryCount = 0\n\t\tfor _, category in ipairs(this.optionCategories) do\n\t\t\tif category.parentKey == this.config.activeCategory and category.key ~= this.config.activeCategory then\n\t\t\t\tentryCount = entryCount + 1\n\t\t\tend\n\t\tend\n\t\tfor _, option in ipairs(this.options) do\n\t\t\tif option.category == this.config.activeCategory then\n\t\t\t\tentryCount = entryCount + 1\n\t\t\tend\n\t\tend\n\n\t\t\t\tif entryCount - 1 < this.config.activeOption then\n\t\t\tthis.config.activeOption = entryCount - 1\n\t\telseif this.config.activeOption < 0 then\n\t\t\tthis.config.activeOption = 0\n\t\tend\n\n\t\thtml[#html+1] = this:renderCategory(this:getCategory(this.config.activeCategory))\n\n\t\treturn tconcat(html)\n\tend,\n\n\tsetActiveOption = function(this, entry)\n\t\tlocal categoryCount = 0\n\t\t\t\tlocal isCategory = type(entry) == 'table' and entry.key ~= nil\n\t\t\t\tfor _, category in ipairs(this.optionCategories) do\n\t\t\tif category.parentKey == this.config.activeCategory and category.key ~= this.config.activeCategory then\n\t\t\t\tcategoryCount = categoryCount + 1\n\t\t\t\tif isCategory and category.key == entry.key then\n\t\t\t\t\tthis.config.activeOption = categoryCount\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif type(entry) == 'number' then\n\t\t\tthis.config.activeOption = categoryCount + entry\n\t\tend\n\tend,\n\n\trenderCategory = function(this, renderCategory)\n\t\tlocal html = {}\n\n\t\t\t\tlocal parents = {}\n\t\tif renderCategory ~= nil and renderCategory.key ~= nil then\n\t\t\tlocal parentCategory = this:getCategory(renderCategory.key)\n\t\t\ttinsert(parents, 1, parentCategory)\n\t\t\twhile parentCategory.parentKey ~= nil and parentCategory.parentKey ~= parentCategory.key do\n\t\t\t\tparentCategory = this:getCategory(parentCategory.parentKey)\n\t\t\t\ttinsert(parents, 1, parentCategory)\n\t\t\tend\n\t\tend\n\n\t\t\t\tlocal parentNames = {}\n\t\tfor _, parentCategory in ipairs(parents) do\n\t\t\ttinsert(parentNames, parentCategory.text)\n\t\tend\n\t\tif #parentNames == 0 then tinsert(parentNames, 'Main Menu') end\n\t\tlocal parentString = tconcat(parentNames, ' > ')\n\n\t\t\t\tlocal HUDScale = HUD.Config.scaleMultiplier\n\t\tlocal optionHeight = this.config.optionHeight * HUDScale\n\t\tlocal optionMargin = this.config.optionMargin * HUDScale\n\t\tlocal optionOuterHeight = optionHeight + optionMargin\n\t\tlocal headerHeight = this.config.headerHeight * HUDScale\n\t\tlocal headerPadding = 4 * HUDScale\n\t\t\t\tlocal headerYMidFirst = mfloor(optionHeight / 2)\n\t\t\t\tlocal headerYEnd = mfloor(headerHeight - headerPadding)\n\t\thtml[#html+1] = '<text class=\"outlined\" x=\"' .. headerPadding .. '\" y=\"' .. (headerYMidFirst) .. '\">' .. parentString .. '</text>'\n\t\thtml[#html+1] = '<rect class=\"separator\" x=' .. headerPadding .. '\" y=\"' .. (headerYEnd) .. '\" width=\"' .. (this.config.optionWidth * HUDScale) .. '\" height=\"1\" />'\n\n\t\t\t\t\t\tlocal visibleIndexMin = 0\n\t\tlocal visibleIndexMax = this.config.visOptCnt\n\t\tif this.config.activeOption > this.config.visOptCnt then\n\t\t\tvisibleIndexMin = this.config.activeOption - this.config.visOptCnt\n\t\t\tvisibleIndexMax = this.config.activeOption\n\t\tend\n\n\t\tlocal categoryCount = 0\n\t\tlocal visCatCnt = 0\n\t\t\t\tfor _, category in ipairs(this.optionCategories) do\n\t\t\tif category.parentKey == renderCategory.key and category.key ~= renderCategory.key then\n\t\t\t\tif categoryCount <= visibleIndexMax and categoryCount >= visibleIndexMin then\n\t\t\t\t\tlocal hovering = categoryCount == this.config.activeOption\n\t\t\t\t\tif hovering then this.hoveredEntry = category end\n\t\t\t\t\tthis:updateState(category, hovering)\n\t\t\t\t\thtml[#html+1] = this:renderEntry(category, visCatCnt)\n\t\t\t\t\tvisCatCnt = visCatCnt + 1\n\t\t\t\tend\n\t\t\t\tcategoryCount = categoryCount + 1\n\t\t\tend\n\t\tend\n\n\t\tlocal OptCnt = 0\n\t\tlocal visOptCnt = 0\n\t\t\t\tfor _, option in ipairs(this.options) do\n\t\t\tif option.category == renderCategory.key then\n\t\t\t\tlocal effectiveIndex = OptCnt + categoryCount\n\t\t\t\tif effectiveIndex <= visibleIndexMax and effectiveIndex >= visibleIndexMin then\n\t\t\t\t\tlocal hovering = effectiveIndex == this.config.activeOption\n\t\t\t\t\tif hovering then this.hoveredEntry = option end\n\t\t\t\t\tthis:updateState(option, hovering)\n\t\t\t\t\thtml[#html+1] = this:renderEntry(option, visOptCnt + visCatCnt)\n\t\t\t\t\tvisOptCnt = visOptCnt + 1\n\t\t\t\tend\n\t\t\t\tOptCnt = OptCnt + 1\n\t\t\tend\n\t\tend\n\n\t\tlocal totalEntryCount = OptCnt + categoryCount\n\t\tlocal visibleEntryCount = visCatCnt + visOptCnt\n\t\tthis.rowCount = this.rowCount + visibleEntryCount\n\n\t\tif this.config.visOptCnt < totalEntryCount then\n\t\t\thtml[#html+1] = this:renderScrollBar(headerYEnd, totalEntryCount, visibleEntryCount, visibleIndexMin, visibleIndexMax)\n\t\tend\n\n\t\tlocal tooltipY = 0\n\t\tif this.config.legendVisible then\n\t\t\tlocal legendY = headerYEnd + optionOuterHeight * this.rowCount + optionOuterHeight\n\t\t\tlocal legendHtml, legendHeight = this:renderActionLegend(legendY)\n\t\t\ttooltipY = legendY + legendHeight\n\t\t\thtml[#html+1] = legendHtml\n\t\telse\n\t\t\ttooltipY = headerYEnd + optionOuterHeight * this.rowCount + 10 * HUDScale\n\t\tend\n\t\tif this.hoveredEntry ~= nil then\n\t\t\thtml[#html+1] = this:renderTooltip(tooltipY, this.config.legendVisible)\n\t\tend\n\t\treturn tconcat(html)\n\tend,\n\n\trenderScrollBar = function(this, yPos, totalEntryCount, visibleEntryCount, visibleIndexMin, visibleIndexMax)\n\t\tlocal html = {}\n\t\tlocal HUDScale = HUD.Config.scaleMultiplier\n\t\tlocal optionHeight = this.config.optionHeight * HUDScale\n\t\tlocal optionMargin = this.config.optionMargin * HUDScale\n\t\tlocal optionOuterHeight = optionHeight + optionMargin\n\t\tlocal barYMargin = 10 * HUDScale\n\t\tlocal barY = yPos + optionMargin / 2 + barYMargin / 2\n\t\tlocal barX = -12 * HUDScale\n\t\tlocal barFullHeight = visibleEntryCount * optionOuterHeight - barYMargin\n\t\tlocal barWidth = 5 * HUDScale\n\t\tlocal barWidthTrack = 2 * HUDScale\n\t\tlocal barVisibleYStart = barY + visibleIndexMin / totalEntryCount * barFullHeight\n\t\tlocal barVisibleYEnd = barY + (visibleIndexMax + 1) / totalEntryCount * barFullHeight\n\t\tlocal barHeight = barVisibleYEnd - barVisibleYStart\n\n\t\tlocal arrowMargin = 5 * HUDScale\n\t\tlocal arrowSize = 10 * HUDScale\n\n\t\thtml[#html+1] = svgBox .. (barX - arrowSize / 2) .. '\" y=\"' .. (barY - arrowSize - arrowMargin) .. '\" width=\"' .. arrowSize .. '\" height=\"' .. arrowSize .. '\">'\n\t\thtml[#html+1] = HUD.staticSVG.upKey..'</svg>'\n\n\t\thtml[#html+1] = svgBox .. (barX - arrowSize / 2) .. '\" y=\"' .. (barY + barFullHeight + arrowMargin ) .. '\" width=\"' .. arrowSize .. '\" height=\"' .. arrowSize .. '\">'\n\t\thtml[#html+1] = HUD.staticSVG.downKey..'</svg>'\n\n\t\thtml[#html+1] = '<rect class=\"separator\" x=\"' .. (barX - barWidthTrack / 2) .. '\" y=\"' .. barY .. '\" width=\"' .. barWidthTrack .. '\" height=\"' .. barFullHeight .. '\"/>'\n\t\thtml[#html+1] = '<rect class=\"separator\" x=\"' .. (barX - barWidth / 2) .. '\" y=\"' .. barVisibleYStart .. '\" width=\"' .. barWidth .. '\" height=\"' .. barHeight .. '\"/>'\n\n\t\treturn tconcat(html)\n\tend,\n\n\trenderActionLegend = function(this, yPos)\n\t\tlocal hoveredEntry = this.hoveredEntry\n\t\tlocal html = {}\n\t\tactions = {}\n\t\tif hoveredEntry ~= nil then\n\t\t\tactions.back = {}\n\t\t\tif hoveredEntry.key ~= nil then \t\t\t\tactions.main = {}\n\t\t\tend\n\t\t\tif hoveredEntry.actions ~= nil then\n\t\t\t\tif hoveredEntry.actions.back ~= nil then\n\t\t\t\t\tactions.back = hoveredEntry.actions.back\n\t\t\t\tend\n\t\t\t\tif hoveredEntry.actions.main ~= nil then\n\t\t\t\t\tactions.main = hoveredEntry.actions.main\n\t\t\t\tend\n\t\t\t\tif hoveredEntry.actions.alt ~= nil then\n\t\t\t\t\tactions.alt = hoveredEntry.actions.alt\n\t\t\t\tend\n\t\t\t\tif hoveredEntry.actions.shift ~= nil then\n\t\t\t\t\tactions.shift = hoveredEntry.actions.shift\n\t\t\t\tend\n\t\t\t\tif hoveredEntry.actions.altUpDown ~= nil then\n\t\t\t\t\tactions.altUpDown = hoveredEntry.actions.altUpDown\n\t\t\t\tend\n\t\t\t\tif hoveredEntry.actions.input ~= nil then\n\t\t\t\t\tactions.input = hoveredEntry.actions.input\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tlocal actionsArr = {\n\t\t\t{action = actions.back},\n\t\t\t{action = actions.main},\n\t\t\t{action = actions.alt},\n\t\t\t{action = actions.shift},\n\t\t}\n\t\tif actions.altUpDown ~= nil then actionsArr[#actionsArr+1] = {action = actions.altUpDown} end\n\t\tif actions.input ~= nil then actionsArr[#actionsArr+1] = {action = actions.input} end\n\n\t\tlocal HUDScale = HUD.Config.scaleMultiplier\n\t\t\t\t\t\tlocal optionMargin = this.config.optionMargin * HUDScale\n\t\tlocal rowHeight = 10 * HUDScale\n\t\tlocal keyX = 50 * HUDScale\n\t\tlocal textX = keyX + 12 * HUDScale\n\t\tfor i,actionArr in ipairs(actionsArr) do\n\t\t\tlocal active = false\n\t\t\tif i == 3 and inputs.alt then active = true\n\t\t\telseif i == 5 and inputs.alt then active = true\n\t\t\telseif i == 4 and inputs.shift and not inputs.alt then active = true\n\t\t\tend\n\t\t\thtml[#html+1] = '<g class=\"menuLegend\" data-active=\"' .. tostring(active) .. '\">'\n\t\t\tlocal action = actionArr.action\n\t\t\tlocal keyY = yPos + rowHeight * (i - 1)\n\t\t\tlocal keySize = rowHeight * 0.55\n\t\t\tif i <= 5 then\n\t\t\t\thtml[#html+1] = '<svg class=\"menuLegendGlyph\" viewBox=\"0 0 100 100\" x=\"' .. keyX .. '\" y=\"' .. (keyY - (rowHeight - keySize)) .. '\" width=\"' .. keySize .. '\" height=\"' .. keySize .. '\">'\n\t\t\t\tlocal keyGlyph = HUD.staticSVG.leftKey\n\t\t\t\tif i > 1 then keyGlyph = HUD.staticSVG.rightKey end\n\t\t\t\tif i == 5 and actions.altUpDown ~= nil then keyGlyph = HUD.staticSVG.upDownKey end\n\t\t\t\thtml[#html+1] = keyGlyph\n\t\t\t\thtml[#html+1] = '</svg>'\n\t\t\tend\n\t\t\tlocal t = '<text class=\"menuLegendKey\" x=\"'.. (keyX - optionMargin) .. '\" y=' .. keyY\n\t\t\tif i == 3 then\n\t\t\t\thtml[#html+1] = t .. '>alt +</text>'\n\t\t\telseif i == 4 then\n\t\t\t\thtml[#html+1] = t .. '>shift +</text>'\n\t\t\telseif i == 5 and actions.altUpDown ~= nil then\n\t\t\t\thtml[#html+1] = t .. '>alt +</text>'\n\t\t\tend\n\t\t\tif action ~= nil then\n\t\t\t\tlocal actionText = 'Open'\n\t\t\t\tif hoveredEntry and hoveredEntry.key == nil then actionText = 'Select' end\n\t\t\t\tif i == 1 then actionText = 'Back' end\n\t\t\t\tif i == #actionsArr then actionText = 'Lua chat input is active' end\n\t\t\t\tif action.text ~= nil then actionText = action.text end\n\t\t\t\thtml[#html+1] = '<text class=\"menuLegendText\" x=\"' .. textX .. '\" y=' .. keyY .. '>' .. actionText .. '</text>'\n\t\t\tend\n\t\t\thtml[#html+1] = '</g>'\n\t\tend\n\t\treturn tconcat(html), #actionsArr * rowHeight\n\tend,\n\n\trenderEntry = function(this, option, index)\n\t\tlocal html = {}\n\n\t\tlocal HUDScale = HUD.Config.scaleMultiplier\n\t\tlocal hovering = option.state.hovering\n\t\tlocal active = option.state.active\n\n\t\tlocal dataParams = {}\n\t\tif hovering then\n\t\t\ttinsert(dataParams, 'data-hover=\"true\"')\n\t\tend\n\t\tif active then\n\t\t\ttinsert(dataParams, 'data-active=\"true\"')\n\t\tend\n\t\tlocal dataString = ' ' .. tconcat(dataParams, ' ')\n\t\tlocal classString = class('menuOption')\n\n\t\t\t\tlocal optionWidth = this.config.optionWidth * HUDScale\n\t\tlocal optionHeight = this.config.optionHeight * HUDScale\n\t\tlocal optionMargin = this.config.optionMargin * HUDScale\n\t\tlocal optionOuterHeight = optionHeight + optionMargin\n\t\tlocal headerHeight = this.config.headerHeight * HUDScale\n\t\tlocal cornerLength = mfloor(5 * HUDScale)\n\t\tlocal lineWidth = 1 * HUDScale\n\n\t\tlocal optionYStart = mfloor(optionOuterHeight * index + headerHeight)\n\t\tlocal optionYMid = mfloor(optionYStart + optionHeight / 2)\n\t\tlocal optionYEnd = mfloor(optionYStart + optionHeight)\n\t\tlocal optionXStart = 0\n\t\tlocal optionXStartPad = mfloor(optionMargin)\n\t\t\t\tlocal optionXEnd = mfloor(optionWidth)\n\t\tlocal optionXEndPad = mfloor(optionWidth - optionMargin)\n\n\t\thtml[#html+1] = '<g' .. classString .. dataString .. '>'\n\n\t\tlocal valueXPad, cornerPadding, now = 0, 0, system.getArkTime()\n\n\t\t\t\tif option.category == nil then\n\t\t\tvalueXPad = mfloor(optionHeight)\n\t\t\tlocal indicatorSize = mfloor(optionHeight * 0.75)\n\t\t\tlocal indicatorY = mfloor((optionHeight - indicatorSize) / 2)\n\t\t\thtml[#html+1] = svgBox .. (optionXEnd - indicatorSize) .. '\" y=\"' .. (optionYStart + indicatorY) .. '\" width=\"' .. indicatorSize .. '\" height=\"' .. indicatorSize .. '\">' .. HUD.staticSVG.categoryIndicator .. '</svg>'\n\t\tend\n\n\t\t\t\tif hovering then\n\t\t\tlocal tweenTime = 0.2\n\t\t\tlocal optionChangeT = (now - this.lastOptionChangeTime) / tweenTime \t\t\toptionChangeT = clamp(optionChangeT, 0, 1)\n\n\t\t\t\t\t\tcornerPadding = 2 * (1 - optionChangeT)\n\n\t\t\t\t\t\tlocal heightNow = optionChangeT * optionHeight\n\t\t\tlocal heightMid = optionYMid - heightNow / 2\n\t\t\thtml[#html+1] = '<rect x=\"0\" y=\"' .. heightMid .. '\" width=\"' .. (optionWidth - valueXPad) .. '\" height=\"' .. heightNow .. '\" />'\n\n\t\t\tif inputs.mr and this.holdAction ~= nil and not this.holdActionTriggered then\n\t\t\t\tlocal timeSinceHoldStart = (now - this.lastInputTimes.right) / this.holdAction.hold\n\t\t\t\thtml[#html+1] = '<rect class=\"inputHold\" x=\"0\" y=\"' .. heightMid .. '\" width=\"' .. ((optionWidth - valueXPad) * timeSinceHoldStart) .. '\" height=\"' .. heightNow .. '\" />'\n\t\t\tend\n\t\tend\n\n\t\t\t\tif active then\n\t\t\tcornerLength = cornerLength * 2\n\t\t\t\t\tend\n\n\t\t\t\tlocal boxCornerLinesInner = generateRectCorners(\n\t\t\toptionXStart + cornerPadding, \t\t\toptionYStart + cornerPadding, \t\t\toptionXEnd - cornerPadding - valueXPad, \t\t\toptionYEnd - cornerPadding, \t\t\tcornerLength, \t\t\tlineWidth \t\t)\n\n\t\tif active or hovering then\n\t\t\thtml[#html+1] = boxCornerLinesInner\n\t\tend\n\n\t\t\t\thtml[#html+1] = '<text x=\"' .. optionXStartPad .. '\" y=\"' .. optionYMid .. '\">' .. option.text .. '</text>'\n\n\t\tif option.actions ~= nil and option.actions.input ~= nil and hovering then\n\t\t\tlocal indicatorSize = mfloor(optionHeight * 0.6)\n\t\t\tlocal indicatorMargin = mfloor((optionHeight - indicatorSize) / 2)\n\t\t\thtml[#html+1] = svgBox .. (optionXEnd - valueXPad - indicatorSize - indicatorMargin) .. '\" y=\"' .. (optionYStart + indicatorMargin) .. '\" width=\"' .. indicatorSize .. '\" height=\"' .. indicatorSize .. '\">'\n\t\t\thtml[#html+1] = HUD.staticSVG.editableBg\n\t\t\tif system.getArkTime() / 0.75 % 1 > 0.5 then html[#html+1] = HUD.staticSVG.editableGlyph end\n\t\t\thtml[#html+1] = '</svg>'\n\t\t\tvalueXPad = valueXPad + indicatorSize + indicatorMargin\n\t\tend\n\n\t\t\t\tif option.actions ~= nil and option.actions.getValue ~= nil then\n\t\t\tlocal valueResult = nil\n\t\t\tif type(option.actions.getValue) == 'table' then\n\t\t\t\tvalueResult = option.actions.getValue.func(option, option.actions.getValue.arg)\n\t\t\telseif type(option.actions.getValue) == 'boolean' then\n\t\t\t\tvalueResult = option.actions.getValue\n\t\t\telseif type(option.actions.getValue) == 'string' or type(option.actions.getValue) == 'number' then\n\t\t\t\tvalueResult = option.actions.getValue\n\t\t\tend\n\n\t\t\tif type(valueResult) == 'boolean' then\n\t\t\t\tlocal indicatorSize = mfloor(optionHeight * 0.6)\n\t\t\t\tlocal indicatorMargin = mfloor((optionHeight - indicatorSize) / 2)\n\t\t\t\thtml[#html+1] = svgBox .. (optionXEnd - valueXPad - indicatorSize - indicatorMargin) .. '\" y=\"' .. (optionYStart + indicatorMargin) .. '\" width=\"' .. indicatorSize .. '\" height=\"' .. indicatorSize .. '\">'\n\t\t\t\thtml[#html+1] = ternary(valueResult, HUD.staticSVG.checkBoxChecked, HUD.staticSVG.checkBoxUnchecked)\n\t\t\t\thtml[#html+1] = '</svg>'\n\t\t\telseif valueResult ~= nil then\n\t\t\t\thtml[#html+1] = '<text class=\"valueText\" x=\"' .. (optionXEndPad - valueXPad) .. '\" y=\"' .. optionYMid .. '\">' .. valueResult .. '</text>'\n\t\t\tend\n\t\tend\n\n\t\thtml[#html+1] = '</g>'\n\n\t\treturn tconcat(html)\n\tend,\n\n\trenderTooltip = function(this, yPos, showSeparator)\n\t\tif this.hoveredEntry.actions == nil or this.hoveredEntry.actions.tooltip == nil then return end\n\n\t\t\t\tlocal html = {}\n\n\t\tlocal HUDScale = HUD.Config.scaleMultiplier\n\t\tlocal optionWidth = this.config.optionWidth * HUDScale\n\t\t\t\t\t\tlocal rowHeight = 11 * HUDScale\n\t\tlocal startY = 10 * HUDScale + yPos\n\t\tlocal textX = 10 * HUDScale\n\t\tlocal separatorMargin = 5 * HUDScale\n\n\t\thtml[#html+1] = '<g class=\"menuTooltip\">'\n\t\tif showSeparator then\n\t\t\thtml[#html+1] = '<rect class=\"separator\" x=\"' .. separatorMargin .. '\" y=\"' .. yPos .. '\" width=\"' .. (optionWidth - separatorMargin * 2) .. '\" height=\"1\"/>'\n\t\tend\n\n\t\tlocal tooltipRows = this.hoveredEntry.actions.tooltip\n\t\tif type(this.hoveredEntry.actions.tooltip) == 'string' then tooltipRows = {this.hoveredEntry.actions.tooltip} end\n\n\t\tfor i,tooltip in ipairs(tooltipRows) do\n\t\t\tlocal rowY = startY + rowHeight * (i - 1)\n\t\t\thtml[#html+1] = '<text class=\"menuTooltipText\" x=\"' .. textX .. '\" y=\"' .. rowY .. '\">' .. tooltip .. '</text>'\n\t\tend\n\t\thtml[#html+1] = '</g>'\n\t\treturn tconcat(html)\n\tend,\n\n\tupdateInputs = function(this)\n\t\tlocal inputs = inputs\n\t\tlocal now = system.getArkTime()\n\t\tlocal inputRepeatDelay = 0.2\n\t\tlocal holdNil = this.holdAction == nil\n\t\tlocal upTriggered = inputs.mu and (not this.lastInputs.up or holdNil and (now - this.lastInputTimes.up > inputRepeatDelay))\n\t\tlocal downTriggered = inputs.md and (not this.lastInputs.down or holdNil and (now - this.lastInputTimes.down > inputRepeatDelay))\n\t\tlocal leftTriggered = inputs.ml and (not this.lastInputs.left or holdNil and (now - this.lastInputTimes.left > inputRepeatDelay))\n\t\tlocal rightTriggered = inputs.mr and (not this.lastInputs.right or holdNil and (now - this.lastInputTimes.right > inputRepeatDelay))\n\n\t\tthis.lastInputs = {\n\t\t\tup = inputs.mu,\n\t\t\tdown = inputs.md,\n\t\t\tleft = inputs.ml,\n\t\t\tright = inputs.mr\n\t\t}\n\t\tlocal hoveredEntry = this.hoveredEntry\n\t\tif upTriggered then\n\t\t\tif inputs.alt and hoveredEntry ~= nil and hoveredEntry.actions ~= nil and hoveredEntry.actions.altUpDown ~= nil then\n\t\t\t\thoveredEntry.actions.altUpDown.func(true, hoveredEntry.actions.altUpDown.arg)\n\t\t\telse\n\t\t\t\tthis.config.activeOption = this.config.activeOption - 1\n\t\t\tend\n\t\t\tthis.lastOptionChangeTime = now\n\t\t\tthis.lastInputTimes.up = now\n\t\tend\n\t\tif downTriggered then\n\t\t\tif inputs.alt and hoveredEntry ~= nil and hoveredEntry.actions ~= nil and hoveredEntry.actions.altUpDown ~= nil then\n\t\t\t\thoveredEntry.actions.altUpDown.func(false, hoveredEntry.actions.altUpDown.arg)\n\t\t\telse\n\t\t\t\tthis.config.activeOption = this.config.activeOption + 1\n\t\t\tend\n\t\t\tthis.lastOptionChangeTime = now\n\t\t\tthis.lastInputTimes.down = now\n\t\tend\n\t\tif leftTriggered then\n\t\t\tthis.lastInputTimes.left = now\n\t\t\t\t\t\tlocal currentCategory = this:getCategory(this.config.activeCategory)\n\t\t\tif currentCategory.previousCategoryKey ~= nil then\n\t\t\t\tthis:openCategory(currentCategory.previousCategoryKey, currentCategory)\n\t\t\telseif currentCategory.parentKey ~= nil then\n\t\t\t\tthis:openCategory(currentCategory.parentKey, currentCategory)\n\t\t\telse\n\t\t\t\tthis:openCategory(nil, currentCategory)\n\t\t\t\t\t\t\tend\n\n\t\t\t\t\t\tif hoveredEntry ~= nil and hoveredEntry.actions ~= nil and hoveredEntry.actions.back ~= nil then\n\t\t\t\tcurrentCategory.actions.back.func(currentCategory, currentCategory.actions.back.arg)\n\t\t\t\thoveredEntry.actions.back.func(hoveredEntry, hoveredEntry.actions.back.arg)\n\t\t\telseif currentCategory.actions ~= nil and currentCategory.actions.back ~= nil then\n\t\t\t\tcurrentCategory.actions.back.func(currentCategory, currentCategory.actions.back.arg)\n\t\t\tend\n\t\tend\n\t\tif rightTriggered then\n\t\t\tthis.lastInputTimes.right = now\n\t\t\t\t\t\t\t\t\tlocal hoveredEntry = this.hoveredEntry\n\t\t\tif hoveredEntry ~= nil then\n\t\t\t\tif hoveredEntry.actions == nil and hoveredEntry.key ~= nil then\n\t\t\t\t\tthis:openCategory(hoveredEntry.key)\n\t\t\t\telse\n\t\t\t\t\tif inputs.alt and hoveredEntry.actions.alt ~= nil then\n\t\t\t\t\t\tif hoveredEntry.actions.alt.hold ~= nil then this.holdAction = hoveredEntry.actions.alt this.holdActionTriggered = false\n\t\t\t\t\t\telse hoveredEntry.actions.alt.func(hoveredEntry, hoveredEntry.actions.alt.arg) end\n\t\t\t\t\telseif inputs.shift and hoveredEntry.actions.shift ~= nil then\n\t\t\t\t\t\tif hoveredEntry.actions.shift.hold ~= nil then this.holdAction = hoveredEntry.actions.shift this.holdActionTriggered = false\n\t\t\t\t\t\telse hoveredEntry.actions.shift.func(hoveredEntry, hoveredEntry.actions.shift.arg) end\n\t\t\t\t\telseif hoveredEntry.actions.main ~= nil then\n\t\t\t\t\t\tif hoveredEntry.actions.main.hold ~= nil then this.holdAction = hoveredEntry.actions.main this.holdActionTriggered = false\n\t\t\t\t\t\telse hoveredEntry.actions.main.func(hoveredEntry, hoveredEntry.actions.main.arg) end\n\t\t\t\t\telseif hoveredEntry.key ~= nil then\n\t\t\t\t\t\tthis:openCategory(hoveredEntry.key)\n\t\t\t\t\telseif hoveredEntry.actions.input ~= nil then\n\t\t\t\t\t\tP('[I] Enter any text here in chat to input a new value')\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\telseif inputs.mr and this.holdAction ~= nil then\n\t\t\tlocal timeSinceHoldStart = now - this.lastInputTimes.right\n\t\t\tif this.holdAction.hold < timeSinceHoldStart and not this.holdActionTriggered then\n\t\t\t\tthis.holdActionTriggered = true\n\t\t\t\tthis.holdAction.func(this.hoveredEntry, this.holdAction.arg)\n\t\t\tend\n\t\telseif this.holdAction ~= nil then\n\t\t\tthis.holdAction = nil\n\t\tend\n\tend,\n\n\tsetPreviousCategoryKey = function(this, categoryKey, previousCategoryKey)\n\t\tlocal category = this:getCategory(categoryKey)\n\t\tif category ~= nil then\n\t\t\tcategory.previousCategoryKey = previousCategoryKey\n\t\tend\n\tend,\n\n\tgetCategory = function(this, categoryKey)\n\t\tif categoryKey == nil then return { key = nil, parentKey = nil } end\n\t\tfor _, category in ipairs(this.optionCategories) do\n\t\t\tif category.key == categoryKey then\n\t\t\t\treturn category\n\t\t\tend\n\t\tend\n\tend,\n\n\tgetHoveredEntry = function(this)\n\t\tlocal i = 0\n\t\tfor _, category in ipairs(this.optionCategories) do\n\t\t\tif category.parentKey == this.config.activeCategory and category.parentKey ~= category.key then\n\t\t\t\tif this.config.activeOption == i then\n\t\t\t\t\treturn category\n\t\t\t\tend\n\t\t\t\ti = i + 1\n\t\t\tend\n\t\tend\n\n\t\tfor _, option in ipairs(this.options) do\n\t\t\tif option.category == this.config.activeCategory then\n\t\t\t\tif this.config.activeOption == i then\n\t\t\t\t\treturn option\n\t\t\t\tend\n\t\t\t\ti = i + 1\n\t\t\tend\n\t\tend\n\tend\n}\n\nfunction generateRectCorners(x1, y1, x2, y2, cornerLength, lineWidth)\n\tif lineWidth == nil then lineWidth = 1 end\n\tlocal html, rct, wdt, ht, ct, y = {}, '<rect class=\"separator\" x=\"', '\" width=\"', '\" height=\"', '\" />', '\" y=\"'\n\thtml[#html+1] = rct .. x1 .. y .. y1 .. wdt .. cornerLength .. ht .. lineWidth .. ct\n\thtml[#html+1] = rct .. x1 .. y .. y1 .. wdt .. lineWidth .. ht .. cornerLength .. ct\n\thtml[#html+1] = rct .. x1 .. y .. (y2 - lineWidth) .. wdt .. cornerLength .. ht .. lineWidth .. ct\n\thtml[#html+1] = rct .. x1 .. y .. (y2 - cornerLength) .. wdt .. lineWidth .. ht .. cornerLength .. ct\n\thtml[#html+1] = rct .. (x2 - cornerLength) .. y .. y1 .. wdt .. cornerLength .. ht .. lineWidth .. ct\n\thtml[#html+1] = rct .. (x2 - lineWidth) .. y .. y1 .. wdt .. lineWidth .. ht .. cornerLength .. ct\n\thtml[#html+1] = rct .. (x2 - cornerLength) .. y .. (y2 - lineWidth) .. wdt .. cornerLength .. ht .. lineWidth .. ct\n\thtml[#html+1] = rct .. (x2 - lineWidth) .. y .. (y2 - cornerLength) .. wdt .. lineWidth .. ht .. cornerLength .. ct\n\treturn tconcat(html)\nend\nend)\npackage.preload['Saga:hud/mainMenuActions.lua']=(function()\nfunction addCustomPos(input)\n\tlocal pos = parsePosString(input)\n\tif pos.altitude == nil then\n\t\treturn P('[E] Invalid ::pos{...} string')\n\tend\n\taddPos(pos)\nend\n\nfunction addCurrentPos()\n\t\t\tlocal pos = {\n\t\tlatitude\t= round2(cData.position.x, 5),\n\t\tlongitude\t= round2(cData.position.y, 5),\n\t\taltitude\t= round2(cData.position.z, 5),\n\t}\n\taddPos(pos)\nend\n\nfunction addPos(pos)\n\tlocal worldCoords = mapPosToWorldPos(pos)\n\tif worldCoords == nil then return P('[E] Invalid ::pos string') end\n\t\t\t\tlocal bodyId =  ternary(pos.bodyId == 0, nil, pos.bodyId)\n\tlocal coordinates = { x = pos.latitude, y = pos.longitude, z = pos.altitude }\n\tlocal coordBody = findClosestBody(worldCoords)\n\tlocal coordAlt = getAltitude(worldCoords)\n\tlocal coordLoc = getLoc(coordBody, coordAlt)\n\tlocal name = (coordBody ~= nil and coordBody.name or 'Space') ..\n\t\t' ' .. coordLoc .. ' [' .. math.ceil(coordAlt) .. 'm]'\n\tlocal point = {\n\t\tname = name,\n\t\tcoordinates = coordinates,\n\t\tsystemId = nil, \t\tbodyId = bodyId\n\t}\n\tRouteDatabase:addPoint(RouteDatabase.currentEditId, point)\n\tWidgets.mainMenu:onEditedRouteChanged()\nend\n\nfunction printPoint(option, arg)\n\tlocal routeIndex = tonumber(RouteDatabase.currentEditId)\n\tif arg ~= nil and routeIndex ~= nil then\n\t\tP(RouteDatabase:getPointPosString(routeIndex, arg))\n\tend\nend\n\nfunction setRouteDestination(option, arg)\n\tAutoPilot:setActiveRoute(arg)\nend\n\nfunction setPointDestination(option, arg)\n\tAutoPilot:setActiveRoute(RouteDatabase.currentEditId, arg)\nend\n\nfunction newRoute(option, arg)\n\tRouteDatabase:newRoute()\n\tWidgets.mainMenu:onEditedRouteChanged()\n\tWidgets.mainMenu.optionMenu:setPreviousCategoryKey(categoryENUM.EditRoute, categoryENUM.RouteList)\n\tWidgets.mainMenu.optionMenu:openCategory(categoryENUM.EditRoute)\nend\n\nfunction editRouteName(input, arg)\n\tRouteDatabase:renameRoute(RouteDatabase.currentEditId, input)\nend\n\nfunction editPointName(input, arg)\n\tlocal rdb = RouteDatabase\n\trdb:renamePoint(rdb.currentEditId, arg, input)\n\tP('Renamed [' .. rdb.currentEditId .. '] point [' .. arg .. '] to ' .. input)\n\tWidgets.mainMenu:onEditedRouteChanged()\nend\n\nfunction getEditRouteName(option, arg)\n\tlocal rdb = RouteDatabase\n\tif rdb.currentEditId ~= nil and rdb.routes[rdb.currentEditId] ~= nil then\n\t\treturn rdb.routes[rdb.currentEditId].name\n\tend\n\treturn 'Invalid route id'\nend\n\nfunction editRoute(option, arg)\n\t\tRouteDatabase.currentEditId = arg\n\tWidgets.mainMenu:onEditedRouteChanged()\n\tWidgets.mainMenu.optionMenu:setPreviousCategoryKey(categoryENUM.EditRoute, categoryENUM.RouteListAll)\n\tWidgets.mainMenu.optionMenu:openCategory(categoryENUM.EditRoute)\nend\n\nfunction unEditRoute(option, arg)\n\tWidgets.mainMenu.optionMenu:setActiveOption(RouteDatabase.currentEditId - 1)\n\tRouteDatabase.currentEditId = nil\nend\n\nfunction deleteRoute(option, arg)\n\tRouteDatabase:deleteRoute(arg)\nend\n\nfunction deletePoint(option, arg)\n\tRouteDatabase:deletePoint(RouteDatabase.currentEditId, arg)\n\tWidgets.mainMenu:onEditedRouteChanged()\nend\n\nfunction movePoint(up, arg)\n\tlocal newPointIndex = RouteDatabase:movePoint(RouteDatabase.currentEditId, arg, ternary(up, arg - 1, arg + 1))\n\tWidgets.mainMenu.optionMenu:setActiveOption(newPointIndex + 2)\n\tWidgets.mainMenu:onEditedRouteChanged()\nend\n\nfunction selectDatabank(option, arg)\n\tif arg.type == 'config' then\n\t\tConfig:selectDb(arg.databank)\n\telseif arg.type == 'route' then\n\t\tRouteDatabase:selectDb(arg.databank)\n\telseif arg.type == 'usb' then\n\t\tRouteDatabase:selectUsbDb(arg.databank)\n\tend\nend\n\nfunction setConfig(option, arg)\n\tConfig:setValue(arg.key, arg.value)\nend\n\nfunction setConfigInput(input, arg)\n\tConfig:setValue(arg, input)\nend\n\nfunction getActiveDbName(option, arg)\n\tif arg == 'config' and Config.databank ~= nil then\n\t\treturn Config.databank.name\n\telseif arg == 'routes' and RouteDatabase.databank ~= nil then\n\t\treturn RouteDatabase.databank.name\n\telseif arg == 'usb' and RouteDatabase.usbDatabank ~= nil then\n\t\treturn RouteDatabase.usbDatabank.name\n\tend\n\treturn '-'\nend\n\nfunction menuActionTemplate(option, arg)\nend\nend)\npackage.preload['Saga:hud/static_svg.lua']=(function()\nHUD.staticSVG = {\n    categoryIndicator = '<path d=\"M0,0 L0,100 L100,50 Z\"/>',\n    upKey = '<path class=\"menuLegendKey\" d=\"M50,0 L0,100 L100,100 Z\"/>',\n    downKey = '<path class=\"menuLegendKey\" d=\"M0,0 L100,0 L50,100 Z\"/>',\n    rightKey = '<path class=\"menuLegendKey\" d=\"M0,0 L0,100 L100,50 Z\"/>',\n    leftKey = '<path class=\"menuLegendKey\" d=\"M0,50 L100,100 L100,0 Z\"/>',\n    upDownKey = '<path class=\"menuLegendKey\" d=\"M0,0 L50,100 L-50,100 Z\"/><path class=\"menuLegendKey\" d=\"M50,0 L150,0 L100,100 Z\"/>',\n    checkBoxChecked = '<rect class=\"checkBox checked\" width=\"100\" height=\"100\" y=\"0\"/>',\n    checkBoxUnchecked = '<rect class=\"checkBox\" width=\"100\" height=\"100\" y=\"0\"/>',\n    editableBg = '<rect class=\"editableBg\" width=\"100\" height=\"100\"/>',\n    editableGlyph = '<rect class=\"editableGlyph\" width=\"80\" height=\"15\" x=\"10\" y=\"75\"/>',\n    progradeReticle = [[\n        <svg viewBox=\"0 0 100 100\">\n        <circle style=\"stroke-width: 4px; stroke: rgb(20, 220, 40); fill: none;\" cx=\"75\" cy=\"75\" r=\"33.333\" transform=\"matrix(1, 0, 0, 0.999999, -24.999976, -24.999961)\" bx:origin=\"0.331 0.224\"/>\n        <path style=\"fill: rgb(46, 139, 87); stroke-width: 4px; stroke: rgb(20, 220, 40);\" d=\"M 83.333 50 L 100 50\" bx:origin=\"-2.677 0\"/>\n        <path style=\"fill: rgb(46, 139, 87); stroke-width: 4px; stroke: rgb(20, 220, 40);\" d=\"M 60.767 50 L 77.433 50\" transform=\"matrix(-1, 0, 0, -1, 77.435763, 100.000003)\" bx:origin=\"-1.323 0\"/>\n        <path style=\"fill: rgb(46, 139, 87); stroke-width: 4px; stroke: rgb(20, 220, 40);\" d=\"M 101.733 31.6 L 118.4 31.6\" transform=\"matrix(0, 1, -1, 0, 81.598635, -18.398635)\" bx:origin=\"-3.104 0\"/>\n        <path style=\"fill: rgb(46, 139, 87); stroke-width: 4px; stroke: rgb(20, 220, 40);\" d=\"M 64.933 31.6 L 81.6 31.6\" transform=\"matrix(0, -1, 1, 0, 18.399367, 81.599368)\" bx:origin=\"-0.896 0\"/>\n        <circle style=\"fill: rgb(46, 139, 87); fill-opacity: 0; stroke: rgb(20, 220, 40); stroke-width: 2px;\" cx=\"50\" cy=\"50\" r=\"2.5\" bx:origin=\"0.5 0.5\"/>\n        </svg>\n    ]],\n    retrogradeReticle = [[\n        <svg viewBox=\"125 125 150 150\">\n        <path style=\"fill: rgb(46, 139, 87); stroke-width: 4px; stroke: rgb(20, 220, 40);\" d=\"M 150 150 L 250 250\" bx:origin=\"0.5 0.5\"/>\n        <path style=\"fill: rgb(46, 139, 87); stroke-width: 4px; stroke: rgb(20, 220, 40);\" d=\"M 150 150 L 250 250\" transform=\"matrix(0, 1, -1, 0, 400.000012, 0)\" bx:origin=\"0.5 0.5\"/>\n        <circle style=\"stroke-width: 4px; stroke: rgb(20, 220, 40); fill: none;\" cx=\"200\" cy=\"200\" r=\"50\"/>\n        <path style=\"fill: rgb(46, 139, 87); stroke-width: 4px; stroke: rgb(20, 220, 40);\" d=\"M 250 200 L 275 200\"/>\n        <path style=\"fill: rgb(46, 139, 87); stroke-width: 4px; stroke: rgb(20, 220, 40);\" d=\"M 125 200 L 150 200\" transform=\"matrix(-1, 0, 0, -1, 275.000008, 400.000012)\"/>\n        <path style=\"fill: rgb(46, 139, 87); stroke-width: 4px; stroke: rgb(20, 220, 40);\" d=\"M 249.725 200.275 L 274.725 200.275\" transform=\"matrix(0, 1, -1, 0, 400.275006, 0.274988)\" bx:origin=\"-1.989 0\"/>\n        <path style=\"fill: rgb(46, 139, 87); stroke-width: 4px; stroke: rgb(20, 220, 40);\" d=\"M 250.275 200.275 L 275.275 200.275\" transform=\"matrix(0, -1, 1, 0, -0.275, 400.275006)\" bx:origin=\"-2.011 0\"/>\n        </svg>\n    ]],\n                                    targetReticle = [[\n        <svg viewBox=\"-62.5 -62.5 125 125\">\n        <path d=\"M 62.5 0 A 62.5 62.5 0 0 1 0 62.5 A 62.5 62.5 0 0 1 -62.5 0 A 62.5 62.5 0 0 1 0 -62.5 A 62.5 62.5 0 0 1 62.5 0 Z\" style=\"fill: none; stroke-dasharray: 65; stroke: rgb(246, 0, 254); stroke-width: 6px;\"/>\n        <path d=\"M 5 0 A 5 5 0 0 1 0 5 A 5 5 0 0 1 -5 0 A 5 5 0 0 1 0 -5 A 5 5 0 0 1 5 0 Z\" style=\"fill: rgb(246, 0, 254); stroke: rgb(246, 0, 254);\"/>\n        </svg>\n    ]],\n    maneuverNode = [[\n        <svg viewBox=\"-3.175 0 106.391 103.181\">\n        <path style=\"fill: rgb(216, 216, 216); stroke-width: 5px; stroke: rgb(21, 0, 255);\" d=\"M 22.767 1.724 L 76.628 1.715\" transform=\"matrix(-1, 0, 0, -1, 99.718166, 3.439)\" bx:origin=\"0.5 -5363.962451\"/>\n        <path style=\"fill: rgb(216, 216, 216); stroke: rgb(21, 0, 255); stroke-width: 3px;\" d=\"M 34.86 15.167 L 65.007 15.161\" transform=\"matrix(0, 1, -1, 0, 65.187944, -34.859944)\" bx:origin=\"1.658538 1.046562\"/>\n        <path d=\"M 52.5 50 C 52.5 51.381 51.38 52.5 50 52.5 C 48.619 52.5 47.5 51.381 47.5 50 C 47.5 48.619 48.619 47.5 50 47.5 C 51.38 47.5 52.5 48.619 52.5 50 Z\" style=\"stroke: rgb(21, 0, 255); fill: rgb(21, 0, 255);\" bx:origin=\"0 0\"/>\n        <path style=\"fill: rgb(216, 216, 216); stroke-width: 5px; stroke: rgb(21, 0, 255);\" d=\"M 23.09 98.285 L 76.951 98.276\" transform=\"matrix(0.707107, -0.707107, 0.707107, 0.707107, -20.694729, 50.010377)\" bx:origin=\"0.5 -5363.962451\"/>\n        <path style=\"fill: rgb(216, 216, 216); stroke: rgb(21, 0, 255); stroke-width: 3px;\" d=\"M 0.021 50 L 30.168 49.994\" transform=\"matrix(-0.707107, -0.707107, 0.707107, -0.707107, 50.035558, 120.725971)\" bx:origin=\"1.658538 1.046562\"/>\n        <path style=\"fill: rgb(216, 216, 216); stroke-width: 5px; stroke: rgb(21, 0, 255);\" d=\"M 23.09 98.285 L 76.951 98.276\" transform=\"matrix(0.707107, 0.707107, -0.707107, 0.707107, 49.996057, -20.729293)\" bx:origin=\"0.5 -5363.962451\"/>\n        <path style=\"fill: rgb(216, 216, 216); stroke: rgb(21, 0, 255); stroke-width: 3px;\" d=\"M 0.021 50 L 30.168 49.994\" transform=\"matrix(0.707107, -0.707107, 0.707107, 0.707107, -20.704741, 50.014894)\" bx:origin=\"1.658538 1.046562\"/>\n        </svg>\n    ]],\n    centerofMass = [[\n        <svg viewBox=\"-74.652 -64 148.511 131.373\" >\n        <path style=\"fill: rgb(216, 216, 216); stroke-width: 5px; stroke: rgb(255, 60, 0);\" d=\"M -42.75 -62.99 L 42.25 -63\" transform=\"matrix(-1, 0, 0, -1, 0.01, -125.990009)\" bx:origin=\"0.503 0.5\"/>\n        <path style=\"fill: rgb(216, 216, 216); stroke: rgb(255, 60, 0); stroke-width: 3px;\" d=\"M -17.6 -46.39 L 17.4 -46.4\" transform=\"matrix(0, 1, -1, 0, -46.390001, -46.400003)\" bx:origin=\"0.503 0.5\"/>\n        <path style=\"fill: rgb(216, 216, 216); stroke-width: 5px; stroke: rgb(255, 60, 0);\" d=\"M 9.977 30.349 L 94.977 30.339\" transform=\"matrix(0.5, -0.866025, 0.866025, 0.5, 0.08732, 60.839247)\" bx:origin=\"0.503 0.5\"/>\n        <path style=\"fill: rgb(216, 216, 216); stroke: rgb(255, 60, 0); stroke-width: 3px;\" d=\"M 20.751 22.051 L 55.751 22.041\" transform=\"matrix(-0.866025, -0.5, 0.5, -0.866025, 60.550264, 60.316404)\" bx:origin=\"0.503 0.5\"/>\n        <path style=\"fill: rgb(216, 216, 216); stroke-width: 5px; stroke: rgb(255, 60, 0);\" d=\"M -96.025 30.583 L -11.025 30.573\" transform=\"matrix(0.5, 0.866025, -0.866025, 0.5, -0.153671, 61.422167)\" bx:origin=\"0.503 0.5\"/>\n        <path style=\"fill: rgb(216, 216, 216); stroke: rgb(255, 60, 0); stroke-width: 3px;\" d=\"M -56.499 22.283 L -21.499 22.273\" transform=\"matrix(0.866025, -0.5, 0.5, 0.866025, -16.349816, -16.462319)\" bx:origin=\"0.503 0.5\"/>\n        <path d=\"M 5 0 A 5 5 0 0 1 0 5 A 5 5 0 0 1 -5 0 A 5 5 0 0 1 0 -5 A 5 5 0 0 1 5 0 Z\" style=\"stroke: rgb(255, 60, 0); fill: rgb(255, 60, 0);\"/>\n        </svg>\n    ]]\n                                                                                                        }\nend)\npackage.preload['Saga:hud/static_css.lua']=(function()\nfunction HUD.refreshStaticCss()\n\tlocal cnf, sat, hue = HUD.Config, HUD.Config.saturation, HUD.Config.mainHue\n\tlocal s3, s4, s5 = sat*30, sat*40, sat*50\n\tHUD.staticCSS = {\n\t\tgradientDefs = [[\n]]..gradient('mainBg', {\n\t[0] = 'hsl('..hue..','..s4..'%,10%)',\n\t[100] = 'hsl('..hue..','..s4..'%,5%)',\n}, true)..[[\n]]..gradient('bg', {\n\t[0] = 'hsl('..hue..','..s3..'%,15%)',\n\t[100] = 'hsl('..hue..','..s3..'%,10%)',\n}, true)..[[\n]]..gradient('bgTransparent', {\n\t[0] = {'hsl('..hue..','..s4..'%,15%)', 0.5},\n\t[100] = {'hsl('..hue..','..s4..'%,10%)', 0.5},\n}, true)..[[\n]]..gradient('bgStroke', {\n\t[10] = 'hsl('..hue..','..s5..'%,50%)',\n\t[90] = 'hsl('..hue..','..s4..'%,40%)',\n}, true)..[[\n]]..gradient('fadeToBg', {\n\t[60] = 'hsl('..hue..','..s4..'%,20%)',\n\t[90] = 'hsl('..hue..','..s4..'%,15%)',\n}, true)..[[\n]]..gradient('fadeToBgStroke', {\n\t[60] = 'hsl('..hue..','..s5..'%,50%)',\n\t[90] = 'hsl('..hue..','..s4..'%,15%)',\n}, true)..[[\n\t\t]],\n\t\tmenuCss = [[\n.mainMenu {font-size:]]..(cnf.scaleMultiplier * 10)..[[px;font-family: 'Montserrat'}\n.mainMenu text { alignment-baseline: middle;text-shadow: none;stroke-width: 0;white-space: pre;fill: hsl(0,0%,95%);text-anchor: start}\n.menuOption text {alignment-baseline: central}\ntext.valueText {text-anchor: end}\n.mainMenu path {fill:hsla(]]..hue..[[,]]..s5..[[%,80%,0.5)} ]]..\n[[\n[data-hover=true] text {fill:hsl(]]..hue..[[,]]..s5..[[%,100%)}\n[data-hover=true] rect {fill:hsla(]]..hue..[[,]]..s5..[[%,50%,0.5)}\n[data-hover=true] path {fill:hsla(]]..hue..[[,]]..s5..[[%,100%,0.7)}\n[data-hover=true] rect.separator {fill: hsl(0,0%,85%)}\n/* active */\n[data-active=true] rect.separator {fill: hsl(0,0%,100%)}\n/* active hover */\n[data-active=true][data-hover=true] rect{}\nrect.inputHold {fill:hsl(0,0%,75%) }\ntext.outlined {text-shadow:0 0 1vh black}\nrect.separator {fill:hsl(0,0%,100%)}\nrect.checkBox {fill:hsl(0,0%,70%)}\nrect.checkBox.checked {fill:hsl(0,0%,100%)}\nrect.editableBg {fill:hsla(0,0%,0%,0.3)}\nrect.editableGlyph {fill:hsl(0,0%,95%)}\n.menuLegendGlyph {overflow:visible}\ntext.menuLegendText {fill:hsl(0,0%,88%)}\ntext.menuLegendKey {fill:hsl(58,89%,44%);text-anchor:end}\npath.menuLegendKey {fill:hsl(0,0%,95%)}\n.menuLegend[data-active=true] text, .menuLegend[data-active=true] path {fill:hsl(0,0%,100%)}\n]],\n\tcss = [[\n.widget {\n\tposition: absolute;\n\twhite-space: pre;\n\tfont-size: ]]..(cnf.scaleMultiplier*10)..[[px;\n\tfont-family: 'Montserrat';\n\tcolor: hsl(0,0%,95%);\n\tbackground-color: hsla(0,0%,0%,0.2);\n\tborder:0.1vh solid hsl(0,0%,95%);\n\ttext-shadow: 0.2vh 0.2vh 1vh black;\n\tpadding: ]]..(cnf.scaleMultiplier*5)..[[px;\n}\n.widget.alert {border-color: hsl(16,100%,50%)}\n.radarRow {display: relative;height: 1.2vh}\n.radarText {position: absolute;overflow: hidden}\n.coreInfo {text-align: center}\n.dottext {position:absolute; width:6vh; height:6vh; left:-6vh; top:-6vh; border-radius:1vh}\n.dot {position:absolute; width:3vh; height:3vh; left:-1.5vh; top:-1.5vh; border-radius:1vh}\n.planets {position:absolute; width:2vh; height:2vh; left:-1vh; top:-1vh; border-radius:1vh}\n.ptext {position:absolute; width:3vh; height:3vh; left:-1.5vh; top:-3vh; border-radius:1vh}\n.mtext {position:absolute; width:3vh; height:3vh; left:-1.5vh; top:3vh; border-radius:1vh}\n.collision {position:absolute; top:94vh; right:80vw; width:18vw; padding-left: 1vh; padding-top: 1vh; padding-right: 1vh; padding-bottom: 1vh; border:0.1vh; border-style: solid; border-color: orangered}\n.radar1 {position:absolute; top:83vh; right:25vw; width:12vw; padding-left: 1vh; padding-right: 1vh; padding-top: 1vh; padding-bottom: 1vh; border:0.1vh; border-style: solid; border-color: ivory}\n.radar2 {position:absolute; top:83vh; right:38vw; width:12vw; padding-left: 1vh; padding-right: 1vh; padding-top: 1vh; padding-bottom: 1vh; border:0.1vh; border-style: solid; border-color: ivory}\n.radar3 {position:absolute; top:83vh; right:51vw; width:12vw; padding-left: 1vh; padding-right: 1vh; padding-top: 1vh; padding-bottom: 1vh; border:0.1vh; border-style: solid; border-color: ivory}\n.speedBar{position:absolute; width:11.5vh; height:11.5vh; left:32vh; top:-12vh; border-radius:1vh;}\n.throttleBar{position:absolute; width:11.5vh; height:11.5vh; left:37vh; top:-8vh; border-radius:1vh;}\n.altBar{position:absolute; width:14vh; height:11.5vh; left:-43vh; top:-12vh; border-radius:1vh;}\n.svg {background: #eee;}\n\n.atmoAlert\t{position:absolute; top:74vh;\tright:62.9vw;\twidth:10vw; padding:0.2vh; border:0.2vh;\n\tfont-size: 1vh;color: ivory; text-shadow:0.2vh 0.2vh 1vh black;}\n.apAlert\t{position:absolute; top:25vh;\tleft:72vw;\twidth:10vw; padding: 1vh;\n\tborder:0.2vh; border-style: solid; border-color: orangered}\n.brakeAlert\t{position:absolute; top:5vh;\tleft:44vw;\twidth:10vw; padding: 1vh}\n]]\n}\nend\nend)\npackage.preload['Saga:hud/dynamic_svg.lua']=(function()\nfunction dynamicSVG()\n\tlocal umap, uround = utils.map, utils.round\n\tlocal gCache, cD = globals, cData\n\tlocal conSpd, maxSpd = 0,0\n\tlocal speedFill = 0\n\tlocal rColor, gColor, bColor = 150, 150, 150\n\tlocal curThrottle = cD.curThrottle\n\tlocal maxThrottle, throttleFill = 100, 0\n\tlocal curAlt, maxAlt = 0, 0\n\tlocal altFill = 0\n\tlocal tMode = 'Travel'\n\tlocal trgtDistance = ''\n\n\tif cD.position ~= nil and AutoPilot.target ~= nil then\n\t\ttrgtDistance = printDistance((round2(vector.dist(AutoPilot.target,cD.position),2)), true)\n\tend\n\n\tif cD.constructSpeed ~= nil then\n\t\t\t\tconSpd = round2((ship.landingMode or ship.vertical) and cD.zSpeedKPH or cD.speedKph,1)\n\t\tif cD.inAtmo then\n\t\t\tmaxSpd = math.ceil(uround(cD.burnSpeedKph))\n\t\telse\n\t\t\tmaxSpd = math.ceil(uround(cD.maxSpeed*3.6))\n\t\tend\n\t\tif conSpd ~= 0 and maxSpd ~= 0 then\n\t\t\tspeedFill = clamp(conSpd/maxSpd*200,0,200)\n\t\t\trColor = uround(umap(clamp(speedFill,170,200),170,200,150,255))\n\t\t\tgColor = uround(umap(clamp(speedFill,170,200),170,200,150,40))\n\t\t\tbColor = uround(umap(clamp(speedFill,170,200),170,200,150,0))\n\t\tend\n\t\tif controlMode() == 'travel' then\n\t\t\tthrottleFill = 200*(abs(curThrottle)/100)\n\t\telse\n\t\t\tif conSpd <= 1000 then\n\t\t\t\tmaxThrottle = 1000\n\t\t\telseif conSpd <= 5000 then\n\t\t\t\tmaxThrottle = 5000\n\t\t\telseif conSpd <= 10000 then\n\t\t\t\tmaxThrottle = 10000\n\t\t\telseif conSpd <= 20000 then\n\t\t\t\tmaxThrottle = 20000\n\t\t\telse\n\t\t\t\tmaxThrottle = 30000\n\t\t\tend\n\t\t\tcurThrottle = curThrottle/100\n\t\t\tthrottleFill = clamp(abs(curThrottle)/maxThrottle*200,0,200)\n\t\tend\n\t\tif cD.body then\n\t\t\tcurAlt, maxAlt = getAltitude(), 200000\n\t\t\tif cD.body and cD.inAtmo then\n\t\t\t\tmaxAlt = uround(cD.body.atmoAltitude)\n\t\t\t\taltFill = clamp(curAlt/maxAlt*200,0,200)\n\t\t\telseif cD.body and cD.body.hasAtmosphere and gCache.collision ~= nil and curAlt <= maxAlt then\n\t\t\t\taltFill = clamp(((curAlt-cD.body.atmoAltitude)/maxAlt)*200,0,200)\n\t\t\telseif curAlt <= maxAlt then\n\t\t\t\taltFill = clamp((curAlt/maxAlt)*200,0,200)\n\t\t\tend\n\t\tend\n\t\ttMode = controlMode()\n\tend\n\n\tlocal fnt = 'Bank' -- for all below svg's\n\tHUD.dynamicSVG = {\n\t\ttargetReticle2 = [[\n<svg viewBox=\"-77.91 -57.847 135.41 86.458\">\n<text style=\"fill: rgb(204, 204, 204); font-family:SegoeUI,sans-serif; font-size: 30px; paint-order: fill; stroke: rgb(0, 0, 0); stroke-width: 2px; white-space: pre;\" transform=\"matrix(0.955784, 0, 0, 1.03899, -3.444869, 2.252162)\" x=\"-77.91\" y=\"-30.551\">]]..trgtDistance..[[</text>\n<path style=\"fill: none; stroke: rgb(204, 204, 204);\" d=\"M -77.91 -22.808 L 0.342 -22.808 L 57.5 28.611\"/>\n</svg>]],\n\t\tspeedBar = [[\n<svg viewBox=\"-29 -24 72 240\">\n<rect width=\"5\" height=\"200\" style=\"fill: rgb(255, 255, 255); fill-opacity: 0; paint-order: stroke; stroke: rgb(94, 94, 94);\" transform=\"matrix(-1, 0, 0, -1, 0, 0)\" x=\"-5\" y=\"-200\" bx:origin=\"0 0\"/>\n<rect width=\"5\" height=\"]]..speedFill..[[\" style=\"stroke: rgb(0,0,0); stroke-opacity: 0; fill: rgb(]]..tonumber(rColor)..[[, ]]..tonumber(gColor)..[[, ]]..tonumber(bColor)..[[);\" transform=\"matrix(-1, 0, 0, -1, 0, 0)\" x=\"-5\" y=\"-200\" bx:origin=\"0 0\"/>\n<text style=\"white-space: pre; fill: #eee; font-family:]]..fnt..[[, sans-serif;\n\tfont-size:12px; paint-order: fill; stroke: #b80000; stroke-width: 3px; text-anchor: middle;\"\n\tx=\"1.4\" y=\"-2.6\" transform=\"matrix(1.1, 0, 0, 1, 1, 0)\">]]..conSpd..[[</text>\n<text style=\"fill: rgb(200, 200, 200); font-family:]]..fnt..[[, sans-serif; font-size: 12px; paint-order: fill; stroke: rgb(0, 0, 0); stroke-width: 2px; white-space: pre;\" transform=\"matrix(0, -1, 1, 0, -102, 9.5)\" x=\"-100\" y=\"100\">Speed</text>\n<text style=\"fill: rgb(200, 200, 200); font-family:]]..fnt..[[, sans-serif; font-size: 10px; paint-order: fill; stroke: rgb(0, 0, 0); stroke-width: 1px; white-space: pre;\" x=\"6\" y=\"5.5\">]]..maxSpd..[[</text>\n</svg>]],\n\t\tthrottleBar = [[\n<svg viewBox=\"-29 -24 72 240\">\n<rect width=\"5\" height=\"200\" style=\"fill: rgb(255, 255, 255); fill-opacity: 0; paint-order: stroke; stroke: rgb(94, 94, 94);\" transform=\"matrix(-1, 0, 0, -1, 0, 0)\" x=\"-5\" y=\"-200\" bx:origin=\"0 0\"/>\n<rect width=\"5\" height=\"]]..throttleFill..[[\" style=\"stroke: rgb(0,0,0); stroke-opacity: 0; fill: rgb(150, 150, 150);\" transform=\"matrix(-1, 0, 0, -1, 0, 0)\" x=\"-5\" y=\"-200\" bx:origin=\"0 0\"/>\n<text style=\"white-space: pre; fill: rgb(200, 200, 200); font-family:]]..fnt..[[, sans-serif; font-size: 12px; paint-order: fill; stroke: #b80000; stroke-width: 2px; text-anchor: middle;\" x=\"1.4\" y=\"-2.6\" transform=\"matrix(1.1, 0, 0, 1, 1, 0)\">]]..uround(curThrottle)..[[</text>\n<text style=\"fill: rgb(200, 200, 200); font-family:]]..fnt..[[, sans-serif; font-size: 14px; paint-order: fill; stroke: rgb(0, 0, 0); stroke-width: 2px; white-space: pre;\" transform=\"matrix(0, -1, 1, 0, -102, 9.5)\" x=\"-100\" y=\"100\">]]..tMode..[[</text>\n<text style=\"fill: rgb(200, 200, 200); font-family:]]..fnt..[[, sans-serif; font-size: 10px; paint-order: fill; stroke: rgb(0, 0, 0); stroke-width: 1px; white-space: pre;\" x=\"6\" y=\"5.5\">]]..maxThrottle..[[</text>\n</svg>]],\n\t\taltitudeBar = [[\n<svg viewBox=\"-39 -24 100 240\">\n<rect width=\"5\" height=\"200\" style=\"fill: rgb(255, 255, 255); fill-opacity: 0; paint-order: stroke; stroke: rgb(94, 94, 94);\" transform=\"matrix(-1, 0, 0, -1, 0, 0)\" x=\"-15\" y=\"-200\" bx:origin=\"0 0\"/>\n<rect width=\"5\" height=\"]]..altFill..[[\" style=\"stroke: rgb(0,0,0); stroke-opacity: 0; fill: rgb(150, 150, 150);\" transform=\"matrix(-1, 0, 0, -1, 0, 0)\" x=\"-5\" y=\"-200\" bx:origin=\"0 0\"/>\n<text style=\"white-space: pre; fill: #eee; font-family:]]..fnt..[[, sans-serif;\n\tfont-size:12px; paint-order: fill; stroke: #b80000; stroke-width: 3px; text-anchor: middle;\"\n\tx=\"2\" y=\"-2.6\" transform=\"matrix(1.1, 0, 0, 1, 1, 0)\">]]..curAlt..[[</text>\n<text style=\"fill: rgb(200, 200, 200); font-family:]]..fnt..[[, sans-serif; font-size: 14px; paint-order: fill;\n\tstroke: rgb(0, 0, 0); stroke-width: 2px; white-space: pre;\" transform=\"matrix(0, -1, 1, 0, -102, 9.5)\" x=\"-100\" y=\"100\">Altitude</text>\n<text style=\"fill: rgb(200, 200, 200); font-family:]]..fnt..[[, sans-serif; font-size: 10px; paint-order: fill;\n\tstroke: rgb(0, 0, 0); stroke-width: 1px; white-space: pre;\" x=\"15\" y=\"8.5\">]]..maxAlt..[[</text>\n</svg>]]\n\t}\nend\nend)\npackage.preload['Saga:hud/hud.lua']=(function()\nlocal dockPanelId, dockWdgId = nil, nil\n\nHUD = {}\nHUD.Config = {\n\tcoreWidget = false,\n\tdockWidget = false,\n\tmainMenuVisible = false,\n\tmainHue = 240,\n\tmainHueShiftRight = 245,\n\tmainHueShiftLeft = 235,\n\tnativeScaleMultiplier = nil,\n\tsaturation = 0,\n\tscaleMultiplier = nil,\n\tunitWidgetVisible = false,\n}\n\nfunction HUD:init()\n\tlocal cfg, cfgMap = Config.defaults, configDatabankMap\n\tcfg[cfgMap.hudScale] = 1\n\tcfg[cfgMap.unitWidgetVisible] = self.Config.unitWidgetVisible\n\tcfg[cfgMap.mainMenuVisible] = self.Config.mainMenuVisible\n\tcfg[cfgMap.coreWidget] = self.Config.coreWidget\n\tcfg[cfgMap.dockWidget] = self.Config.dockWidget\n\n\tEventSystem:register('ConfigDBChanged', self.applyConfig, self)\n\n\tsystem.showScreen(1)\n\tself.updateScale()\n\tself:applyConfig()\n\n\tWidgets = {}\n\trequire('Saga:hud/widgets/aggInfo.lua')\n\trequire('Saga:hud/widgets/controls.lua')\n\trequire('Saga:hud/widgets/core.lua')\n\t\trequire('Saga:hud/widgets/fuelInfo.lua')\n\trequire('Saga:hud/widgets/infos.lua')\n\trequire('Saga:hud/widgets/mainMenu.lua')\n\trequire('Saga:hud/widgets/radarContacts.lua')\n\trequire('Saga:hud/widgets/warpInfo.lua')\n\tfor _,widget in pairs(Widgets) do\n\t\twidget:init()\n\tend\nend\n\nfunction HUD:applyConfig()\n\tself.Config.unitWidgetVisible = Config:getValue(configDatabankMap.unitWidgetVisible)\n\tself.Config.mainMenuVisible = Config:getValue(configDatabankMap.mainMenuVisible)\n\tself.Config.coreWidget = Config:getValue(configDatabankMap.coreWidget)\n\tself.Config.dockWidget = Config:getValue(configDatabankMap.dockWidget)\n\tself.applyDockWidget()\n\tself.applyUnitWidget()\nend\n\nfunction HUD.updateScale()\n\tHUD.screenWidth = system.getScreenWidth()\n\tHUD.screenHeight = system.getScreenHeight()\n\tlocal newScaleMultiplier = HUD.screenHeight / 1080 * (Config:getValue(configDatabankMap.hudScale) or 1)\n\tlocal newNativeScaleMultiplier = HUD.screenHeight / 1080\n\tif newScaleMultiplier ~= nil and HUD.Config.scaleMultiplier ~= newScaleMultiplier then\n\t\tHUD.Config.scaleMultiplier = newScaleMultiplier\n\t\tHUD.Config.nativeScaleMultiplier = newNativeScaleMultiplier\n\t\tHUD.refreshStaticCss()\n\tend\nend\n\nfunction HUD.update()\n\tHUD.updateScale()\n\tlocal rendered, gC = '', globals\n\n\tif HUD.dynamicSVG == nil then\n\t\tdynamicSVG()\n\tend\n\trendered = HUD.constructDebug()\n\n\tlocal widgets = {}\n\n\t\t\t\t\t\n\ttable.insert(widgets, Widgets.controls)\n\tWidgets.controls.anchor = anchorENUM.topRight\n\tWidgets.controls.width = 180\n\tif HUD.Config.mainMenuVisible then\n\t\ttable.insert(widgets, Widgets.mainMenu)\n\tend\n\ttable.insert(widgets, Widgets.fuelInfo)\n\tWidgets.fuelInfo.anchor = anchorENUM.topLeft\n\tWidgets.fuelInfo.width = 220\n\ttable.insert(widgets, Widgets.infos)\n\tWidgets.infos.width = 150\n\tWidgets.infos.anchor = anchorENUM.topLeft\n\t\tif HUD.Config.coreWidget then\n\t\ttable.insert(widgets, Widgets.core)\n\tend\n\n\tWidgets.core.anchor = anchorENUM.top\n\tWidgets.core.width = 800\n\tif links.antigrav then\n\t\ttable.insert(widgets, Widgets.aggInfo)\n\t\tWidgets.aggInfo.anchor = anchorENUM.topLeft\n\t\tWidgets.aggInfo.width = 150\n\tend\n\tif links.warpdrive ~= nil then\n\t\ttable.insert(widgets, Widgets.warpInfo)\n\t\tWidgets.warpInfo.anchor = anchorENUM.topLeft\n\t\tWidgets.warpInfo.width = 180\n\tend\n\tgC.radarD = #Radar.radarDynamic > 0\n\tgC.radarSt = #Radar.radarStatic > 0\n\tgC.radarA = #Radar.radarAbandoned > 0\n\tgC.radarAl = #Radar.radarAlien > 0\n\tgC.radarSp = #Radar.radarSpace > 0\n\tgC.radarF = #Radar.radarFriend > 0\n\tif Radar.radar ~= nil and Radar.boxesVisible then\n\t\tif gC.radarA then table.insert(widgets, Widgets.radarAbandoned) end\n\t\tif gC.radarSt then table.insert(widgets, Widgets.radarStatic) end\n\t\tif gC.radarD then table.insert(widgets, Widgets.radarDynamic) end\n\t\tif gC.radarF then table.insert(widgets, Widgets.radarFriend) end\n\t\tif gC.radarAl then table.insert(widgets, Widgets.radarAlien) end\n\t\tif gC.radarSp then table.insert(widgets, Widgets.radarSpace) end\n\t\ttable.insert(widgets, Widgets.radarThreat)\n\tend\n\n\t\tlocal sizeString = 'width:' .. HUD.screenWidth .. 'px; height:' .. HUD.screenHeight .. 'px;'\n\trendered = rendered .. '<div style=\"position:fixed; top:0; left:0; ' .. sizeString .. '\">'\n\tlocal anchorUsedWidth = {}\n\tlocal anchorMaxWidth = {}\n\tfor _,widget in ipairs(widgets) do\n\t\tif anchorMaxWidth[widget.anchor] == nil then anchorMaxWidth[widget.anchor] = 0 end\n\t\tif anchorMaxWidth[widget.anchor] > 0 then anchorMaxWidth[widget.anchor] = anchorMaxWidth[widget.anchor] + widget.margin end\n\t\tanchorMaxWidth[widget.anchor] = anchorMaxWidth[widget.anchor] + widget.width\n\tend\n\tfor _, widget in ipairs(widgets) do\n\t\tif widget.update ~= nil then widget:update() end\n\t\tif anchorUsedWidth[widget.anchor] == nil then anchorUsedWidth[widget.anchor] = 0 end\n\t\trendered = rendered .. widget:render(anchorUsedWidth[widget.anchor], anchorMaxWidth[widget.anchor])\n\t\tanchorUsedWidth[widget.anchor] = anchorUsedWidth[widget.anchor] + widget.width + widget.margin\n\tend\n\trendered = rendered..'</div>'\n\n\t\t\t\n\tsystem.setScreen(rendered)\nend\n\nfunction HUD.toggleMainMenu(state)\n\tif state == nil then state = not HUD.Config.mainMenuVisible end\n\tHUD.Config.mainMenuVisible = state\n\tConfig:setValue(configDatabankMap.mainMenuVisible, HUD.Config.mainMenuVisible)\nend\n\nfunction HUD.toggleCoreWidget(state)\n\tif state == nil then state = not HUD.Config.coreWidget end\n\tHUD.Config.coreWidget = state\n\tConfig:setValue(configDatabankMap.coreWidget, HUD.Config.coreWidget)\nend\n\nfunction HUD.toggleDockWidget(state)\n\tif state == nil then state = not HUD.Config.dockWidget end\n\tHUD.Config.dockWidget = state\n\tConfig:setValue(configDatabankMap.dockWidget, HUD.Config.dockWidget)\n\tHUD.applyDockWidget()\nend\n\nfunction HUD.toggleUnitWidget(state)\n\tif state == nil then state = not HUD.Config.unitWidgetVisible end\n\tHUD.Config.unitWidgetVisible = state\n\tConfig:setValue(configDatabankMap.unitWidgetVisible, HUD.Config.unitWidgetVisible)\n\tHUD.applyUnitWidget()\nend\n\nfunction HUD.applyDockWidget()\n\tif not HUD.Config.dockWidget and dockWdgId ~= nil then\n\t\tsystem.destroyWidget(dockWdgId)\n\t\tsystem.destroyWidgetPanel(dockPanelId)\n\t\tdockWdgId = nil\n\t\tdockPanelId = nil\n\telseif HUD.Config.dockWidget then\n\t\tdockPanelId = system.createWidgetPanel(\"Docking\")\n\t\tdockWdgId = system.createWidget(dockPanelId,\"parenting\")\n\t\tsystem.addDataToWidget(unit.getWidgetDataId(),dockWdgId)\n\tend\nend\n\nfunction HUD.applyUnitWidget()\n\tif HUD.Config.unitWidgetVisible then\n\t\tunit.showWidget()\n\telse\n\t\tunit.hideWidget()\n\tend\nend\n\nrequire('Saga:hud/debug.lua') require('Saga:hud/widget.lua')\nrequire('Saga:hud/menuSystem.lua')\nrequire('Saga:hud/mainMenuActions.lua')\nrequire('Saga:hud/static_svg.lua')\nrequire('Saga:hud/static_css.lua')\nrequire('Saga:hud/dynamic_svg.lua')\nend)\npackage.preload['Saga:lib/serialize.lua']=(function()\nfunction serialize(v)\n\tif type(v) == 'table' then -- it's a table\n\t\tlocal tableString = '{'\n\t\tif table.isArray(v) then \t\t\tfor k,v in ipairs(v) do\n\t\t\t\ttableString = tableString .. serializeValue(v) .. ','\n\t\t\tend\n\t\telse \t\t\tlocal tbl = {}\n\t\t\tfor k,v in pairs(v) do\n\t\t\t\t\t\t\t\ttable.insert(tbl, k .. '=' .. serializeValue(v))\n\t\t\tend\n\t\t\ttableString = tableString .. table.concat(tbl, ',')\n\t\tend\n\t\ttableString = tableString .. '}'\n\t\treturn tableString\n\telse\n\t\treturn serializeValue(v)\n\tend\nend\n\nfunction serializeValue(v)\n\tif v == nil then\n\t\treturn 'nil'\n\telseif type(v) == 'table' then\n\t\treturn serialize(v)\n\telseif type(v) == 'string' then\n\t\treturn '\"' .. v:format(\"%q\") .. '\"'\n\telseif type(v) == 'number' then\n\t\treturn v\n\telseif type(v) == 'boolean' then\n\t\treturn ternary(v, 'true', 'false')\n\tend\nend\nend)\npackage.preload['Saga:lib/SVG.lua']=(function()\nfunction class(class) \tlocal classes = {}\n\tif class ~= nil then\n\t\tif type(class) == 'table' then\n\t\t\ttable.add(classes, class)\n\t\telseif type(class) == 'string' then\n\t\t\ttable.insert(classes, class)\n\t\tend\n\tend\n\tlocal s = ternary(#classes > 0, ' class=\"'..(table.concat(classes, ' '))..'\"', '')\n\treturn s\nend\n\nfunction gradient(id, data, vertical) \tlocal coords = ternary(vertical,'x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\"', 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"')\n\tlocal def = '<linearGradient id=\"'..id..'\"'..coords..'>'\n\tlocal stopKeys = table.keys(data)\n\ttable.sort(stopKeys)\n\tfor i,k in ipairs(stopKeys) do\n\t\tlocal stop, val = k, data[k]\n\t\tlocal pre = '<stop offset=\"'..stop..'%\" stop-color=\"'\n\t\tif type(val) == 'table' then\n\t\t\tval = data[k][1]\n\t\t\tdef = def..pre..val..'\" stop-opacity=\"'..data[k][2]..'\"/>'\n\t\telse\n\t\t\tdef = def..pre..val..'\"/>'\n\t\tend\n\tend\n\tdef = def..'</linearGradient>'\n\treturn def\nend\nend)\npackage.preload['Saga:libmain.lua']=(function()\nship = {}\n\nabs, atan, rad, floor, format, sub, acos, sqrt = math.abs, math.atan, math.rad, math.floor, string.format, string.sub, math.acos, math.sqrt\ncos, sin, deg, ceil, max, clamp, sign, round = math.cos, math.sin, math.deg, math.ceil, math.max, utils.clamp, utils.sign, utils.round\n\nfunction round2(num, numDecimalPlaces)\n        if type(num) ~= \"number\" then\n        P\"round2: The first argument (num) must be a number.\"\n        error(\"The first argument (num) must be a number.\")\n    end\n    if numDecimalPlaces and (type(numDecimalPlaces) ~= \"number\" or numDecimalPlaces < 0) then\n        error(\"The second argument (numDecimalPlaces) must be a non-negative number.\")\n    end\n    local mult = 10^(numDecimalPlaces or 0)\n    if num >= 0 then\n        return floor(num * mult + 0.5) / mult\n    end\n    return ceil(num * mult - 0.5) / mult\nend\nrequire('dkjson')\n\nrequire('Saga:events/keyboard.lua')\nrequire('Saga:events/system_flush.lua')\nrequire('Saga:events/system_input.lua')\nrequire('Saga:events/system_update.lua')\nrequire('Saga:events/timer_apu.lua')\nrequire('Saga:events/timer_fuel.lua')\nrequire('Saga:events/unit_start.lua')\nrequire('Saga:behaviour/kinematics.lua')\nrequire('Saga:behaviour/autopilot.lua')\nrequire('Saga:behaviour/electronics.lua')\nrequire('Saga:behaviour/ship_maneuver.lua')\nrequire('Saga:behaviour/ship.lua')\nrequire('Saga:data/aggData.lua')\nrequire('Saga:data/config.lua')\nrequire('Saga:data/configDatabankMap.lua')\nrequire('Saga:data/coroutine.lua')\nrequire('Saga:data/constructData.lua')\nrequire('Saga:data/eventSystem.lua')\nrequire('Saga:data/playerData.lua')\nrequire('Saga:data/radar.lua')\nrequire('Saga:data/routeDatabase.lua')\nrequire('Saga:data/tankData.lua')\nrequire('Saga:data/warpData.lua')\n\nrequire('Saga:helpers/common.lua')\nrequire('Saga:helpers/solar_system.lua')\nrequire('Saga:helpers/table.lua')\nrequire('Saga:helpers/vector_math.lua')\n\nrequire('Saga:hud/hud.lua')\n\nrequire('Saga:lib/serialize.lua')\nrequire('Saga:lib/SVG.lua')\nend)"},{"key":4,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":"library.addEventHandlers(library)\nlibrary.addEventHandlers(system)\nlibrary.addEventHandlers(player)\nlibrary.addEventHandlers(construct)\nlibrary.addEventHandlers(unit)"},{"key":5,"filter":{"slotKey":-4,"signature":"onActionStart(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionStart',action)"},{"key":6,"filter":{"slotKey":-4,"signature":"onActionLoop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionLoop',action)"},{"key":7,"filter":{"slotKey":-4,"signature":"onActionStop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionStop',action)"},{"key":8,"filter":{"slotKey":-4,"signature":"onUpdate()","args":[]},"code":"system:triggerEvent('onUpdate')"},{"key":9,"filter":{"slotKey":-4,"signature":"onFlush()","args":[]},"code":"system:triggerEvent('onFlush')"},{"key":10,"filter":{"slotKey":-4,"signature":"onInputText(text)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onInputText',text)"},{"key":11,"filter":{"slotKey":-4,"signature":"onCameraChanged(mode)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onCameraChanged',mode)"},{"key":12,"filter":{"slotKey":-3,"signature":"onParentChanged(oldId,newId)","args":[{"variable":"*"},{"variable":"*"}]},"code":"player:triggerEvent('onParentChanged',oldId,newId)"},{"key":13,"filter":{"slotKey":-2,"signature":"onDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onDocked',id)"},{"key":14,"filter":{"slotKey":-2,"signature":"onUndocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onUndocked',id)"},{"key":15,"filter":{"slotKey":-2,"signature":"onPlayerBoarded(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onPlayerBoarded',id)"},{"key":16,"filter":{"slotKey":-2,"signature":"onVRStationEntered(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onVRStationEntered',id)"},{"key":17,"filter":{"slotKey":-2,"signature":"onConstructDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onConstructDocked',id)"},{"key":18,"filter":{"slotKey":-2,"signature":"onPvPTimer(active)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onPvPTimer',active)"},{"key":19,"filter":{"slotKey":-1,"signature":"onStop()","args":[]},"code":"unit:triggerEvent('onStop')"},{"key":20,"filter":{"slotKey":-1,"signature":"onTimer(timerId)","args":[{"variable":"*"}]},"code":"unit:triggerEvent('onTimer',timerId)"},{"key":21,"filter":{"slotKey":-1,"signature":"onStart()","args":[]},"code":"spaceCapableOverride=false --export: (Space Capable Ship Override) true/false\nhoverHeight=40 --export: Hover Height: 0-50 default hover height (G key)\nthrottleBurnProtection=true --export: (Auto Throttle Burn Protection) true/false\nmaxPitch=35 --export: (Max Pitch) set between 5-80, 35 is default.\nmaxRoll=45 --export: (Max Roll) set between 5-80, 45 is default.\nwingStallAngle=35 --export: (Wing Stall Angle) 25-60.\nshieldManage=true --export: (Auto Shield Management) true/false\nmaxSpaceSpeed=0 --export: Max Space Speed in km/h\nradarOn=false --export: (Radar Widget) true/false\npitchSpeedFactor=0.8 --export: This factor will increase/decrease the player input along the pitch axis\nyawSpeedFactor=1 --export: This factor will increase/decrease the player input along the yaw axis\nrollSpeedFactor=1.5 --export: This factor will increase/decrease the player input along the roll axis\nbrakeSpeedFactor=3 --export: When braking, this factor will increase the brake force\nbrakeFlatFactor=1 --export: Flat braking factor (0.01+)\nautoRoll=true --export: [Only in atmosphere]\nautoRollFactor=2 --export: [Only in atmosphere]\nturnAssist=true --export: [Only in atmosphere]\nturnAssistFactor=2 --export: [Only in atmosphere]\ntorqueFactor=2 --export: Force factor applied to reach rotationSpeed\natmoTankHandling=5 --export: (Atmospheric Fuel Tank Handling) 0-5\nspaceTankHandling=5 --export: (Space Fuel Tank Handling) 0-5\nrocketTankHandling=0 --export: (Rocket Fuel Tank Handling) 0-5\nfuelTankOptimization=5 --export: Talents Fuel Tank Optimization: 0-5\ncontainerOptimization=5 --export: Talents Container Optimization: 0-5\nboostModeOverride='off' --export: (Engine Throttle Mode Override) 'off' , 'all' , 'hybrid', 'primary'\naimStrength=0.3 --export: Aim Strength (0.05 to ~3)\ncoreWidget=false --export: Show Core info panel. Only needed for PvP (FPS impact!)\nagl=0 --export: Above ground landed (in m): Ground distance when landed\ndockingMode=1 --export: Docking mode (1 = manual, 2 = Automatic, 3 = Owner)\ndockWidget=true --export: Show docking widget (toggle with /dock command)\nvelocityVector=true --export: Display velocity indicator\nmaxLandingSpeedHigh=200 --export: Maneuver mode: Max landing speed above 1 km altitude. Default: 200\nmaxLandingSpeedLow=100 --export: Maneuver mode: Max landing speed below 1 km altitude. Default: 100\ntravelAlt=900 --export: Maneuver mode: default travel altitude for AP targets. Default: 900\ncustomAtlas=\"atlas\" --export: (Default \"atlas\") Custom atlas file to override NQ atlas (file need to be located in autoconf/custom/)\nP = system.print\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDEBUG = false \n\nglobals = {\n\tadvAtmoEngines = false,\n\tadvSpaceEngines = false,\n\taggAP = false,\n\taimTarget = 'none',\n\taltitudeHold = false,\n\tapMode = 'standby',\n\tarMode = 'none',\n\tboostMode = 'all',\n\tbrakeState = false,\n\tbrakeTrigger = false,\n\tcameraAim = false,\n\tcollision = nil,\n\tcollisionAlert = false,\n\tcollisionBrake = false,\n\tdbgTxt = '', \tdebug = DEBUG, \tfarSide = nil,\n\tfollowMode = false,\n\tfollowReposition = false,\n\tholdAltitude = 2500,\n\thorizontalStopped = false,\n\tinAtmo = false,\n\tinOrbit = false,\n\tinitTurn = nil,\n\tlastProjectedDistance = 10000000,\n\tlenTest = 0,\n\tmanualOrbitAlt = 0,\n\tmaxDefaultKP = {0,0,0,0},\n\tmaxPrimaryKP = {0,0,0,0},\n\tmaxSecondaryKP = {0,0,0,0},\n\tmaxTertiaryKP = {0,0,0,0},\n\tmissedTarget = false,\n\tnearSide = nil,\n\torbitLock = false,\n\torbitPitch = 0,\n\torbitalHold = false,\n\tradarA = false,\n\tradarAl = false,\n\tradarD = false,\n\tradarF = false,\n\tradarSp = false,\n\tradarSt = false,\n\tradialIn = false,\n\tradialMode = 'none',\n\tradialOut = false,\n\trotationDampening = true,\n\tsafetyThrottle = false,\n\tsmoothClimb = false,\n\tspaceBrakeTrigger = false,\n\tspaceCapable = spaceCapable,\n\tstallProtect = false,\n\ttankData = tankData,\n\ttarget = vec3(),\n\ttargetOrbitAlt = 100000,\n\ttargetPitch = 0,\n\ttargetThrottleOne = 0,\n\ttargetThrottleThree = 0,\n\ttargetThrottleTwo = 0,\n\tverticalState = false,\n\twaitForBubble = false,\n\twaterAlt = -10000000,\n\twaterMode = false,\n\twaterState = false,\n\tupdatecore = true,\n\tstartup = true\n}\n\nlinks = {}\ncData = {}\nAxis = {}\nscrnData = {}\ndeltaTime = system.getUtcTime()\nlastTime = deltaTime\n\nrequire('cpml/vec3')\nrequire('cpml/pid')\nrequire('AxisCommand')\nrequire('Navigator')\nNav = Navigator.new(system, links.core, unit)\nnavCom = Nav.axisCommandManager\n\nrequire('Saga:data/links.lua')\nrequire('Saga:libmain.lua')\nkinematics = Kinematics()\n\nprintHello()\n\nsystem:onEvent('onActionStart', function (self, action) onActionStart(action) end)\nsystem:onEvent('onActionStop', function (self, action) onActionEnd(action) end)\nsystem:onEvent('onActionLoop', function (self, action) onActionLoop(action) end)\nsystem:onEvent('onInputText', function (self, text) onInput(text) end)\n\nsystem:onEvent('onFlush', function (self) onSystemFlush() end)\nsystem:onEvent('onUpdate', function (self) onSystemUpdate() end)\nunit:onEvent('onStop', function ()\n\tif links.electronics ~= nil then links.electronics:SwitchesOff() end\nend)\nunit:onEvent('onTimer', function (unit, id)\n\tif id == \"SYSUPDATE\" then\n\t\tdynamicSVG()\n\t\tif not globals.maneuverMode then onTimerAPU() end\n\telseif id == \"FUELUPDATE\" then\n\t\tonTimerFuelUpdate()\n\telseif id == \"BRAKEUPD\" then\n\t\tlocal tmpB = construct.getMaxBrake()\n\t\tif tmpB and tmpB > 1 then\n\t\t\tglobals.maxBrake = tmpB\n\t\tend\n\telseif id == \"COREUPDATE\" then\n\t\tglobals.updatecore = true\n\t\tRadar:update()\n\tend\nend)\nonUnitStart()\nunit.setTimer(\"FUELUPDATE\", 3)\nunit.setTimer(\"COREUPDATE\", 0.5)\nunit.setTimer(\"BRAKEUPD\", 0.1)\nunit.setTimer(\"SYSUPDATE\", 0.0166)"}],"events":[],"methods":[]}